{"version":3,"sources":["webpack:///app.js","webpack:///./app/index.js","webpack:///./~/angular-ui-router/release/angular-ui-router.js","webpack:///./app/weather/index.js","webpack:///./~/angular-animate/index.js","webpack:///./~/angular-animate/angular-animate.js","webpack:///./~/angular-ui-bootstrap/index.js","webpack:///./~/angular-ui-bootstrap/dist/ui-bootstrap-tpls.js","webpack:///./app/weather/weather.routes.js","webpack:///./app/weather/weather.html","webpack:///./app/weather/weather.controller.js","webpack:///./app/weather/weather.service.js","webpack:///./app/index.config.js"],"names":["webpackJsonp","module","exports","__webpack_require__","_interopRequireDefault","obj","__esModule","default","_angular","_angular2","_angularUiRouter","_angularUiRouter2","_weather","_weather2","_index","_index2","config","window","angular","undefined","inherit","parent","extra","extend","prototype","merge","dst","forEach","arguments","value","key","hasOwnProperty","ancestors","first","second","path","n","push","objectKeys","object","Object","keys","result","val","indexOf","array","Array","Number","len","length","from","Math","ceil","floor","inheritParams","currentParams","newParams","$current","$to","parentParams","parents","inherited","inheritList","i","params","j","equalForKeys","a","b","k","filterByKeys","values","filtered","name","pick","copy","concat","apply","slice","call","omit","filter","collection","callback","isArray","map","$Resolve","$q","$injector","VISIT_IN_PROGRESS","VISIT_DONE","NOTHING","NO_DEPENDENCIES","NO_LOCALS","NO_PARENT","when","$$promises","$$values","this","study","invocables","visit","visited","cycle","splice","Error","join","isString","plan","get","annotate","param","pop","isResolve","isObject","then","invocableKeys","locals","self","done","wait","merged","$$inheritedValues","resolution","resolve","fail","reason","$$failure","reject","invoke","invocable","onfailure","invocation","proceed","isDefined","promise","e","defer","waitParams","dep","promises","ii","$TemplateFactory","$http","$templateCache","fromConfig","template","fromString","templateUrl","fromUrl","templateProvider","fromProvider","isFunction","url","cache","headers","Accept","response","data","provider","UrlMatcher","pattern","parentMatcher","addParameter","id","type","location","paramNames","test","$$UMFP","Param","quoteRegExp","string","squash","optional","surroundPattern","replace","matchDetails","m","isSearch","regexp","segment","cfg","substring","last","index","RegExp","caseInsensitive","placeholder","searchPlaceholder","compiled","segments","$$new","ParamSet","source","p","exec","isOptional","lastIndex","search","sourceSearch","sourcePath","strict","prefix","$$paramNames","Type","$UrlMatcherFactory","valToString","toString","valFromString","getDefaultConfig","isStrictMode","isCaseInsensitive","isInjectable","flushTypeQueue","typeQueue","shift","$types","injector","def","defaultSquashPolicy","enqueue","defaultTypes","encode","decode","is","int","parseInt","bool","date","getFullYear","getMonth","getDate","match","capture","Date","isNaN","valueOf","equals","toISOString","json","toJson","fromJson","any","identity","$$getDefaultValue","strictMode","compile","isMatcher","o","definition","definitionFn","$get","unwrapShorthand","isShorthand","$$fn","getType","urlType","getArrayMode","arrayDefaults","arrayParamNomenclature","getSquashPolicy","getReplace","arrayMode","configuredKeys","defaultPolicy","to","item","defaultValue","$value","hasReplaceVal","$replace","replacement","$normalize","$asArray","dynamic","$$parent","$$keys","chain","ignore","reverse","paramset","paramValues","$$equals","paramValues1","paramValues2","equal","left","right","$$validates","rawVal","normalized","encoded","$UrlRouterProvider","$locationProvider","$urlMatcherFactory","regExpPrefix","re","interpolate","what","handleIfMatch","handler","$match","$location","$rootScope","$browser","$sniffer","appendBasePath","isHtml5","absolute","baseHref","update","evt","check","rule","handled","defaultPrevented","lastPushedUrl","rules","otherwise","listen","listener","$on","interceptDeferred","sync","read","urlMatcher","options","format","$$avoidResync","href","validates","html5Mode","enabled","history","hashPrefix","slash","port","protocol","host","redirect","handlerIsString","strategies","matcher","regex","global","sticky","deferIntercept","$inject","$StateProvider","$urlRouterProvider","isRelative","stateName","findState","stateOrName","base","isStr","rel","split","pathLength","current","state","states","queueState","parentName","queue","flushQueuedChildren","queued","registerState","lastIndexOf","stateBuilder","$delegates","abstractKey","$stateParams","$state","navigable","transitionTo","isGlob","text","doesStateMatchGlob","glob","globSegments","l","unshift","MAX_VALUE","decorator","func","$view","$resolve","$urlRouter","handleRedirect","$broadcast","TransitionAborted","retry","$retry","TransitionFailed","retryTransition","transition","TransitionSuperseded","toParams","resolveState","paramsAreFiltered","resolveViews","viewsPromises","views","view","injectables","$template","load","globals","notify","controllerProvider","injectLocals","$$controller","controller","$$state","$$controllerAs","controllerAs","$$resolveAs","resolveAs","all","TransitionPrevented","root","reload","go","relative","fromParams","fromPath","toState","hash","redirectResult","toPath","keep","toLocals","reloadState","ownParams","shouldSkipReload","resolved","entering","exiting","onExit","onEnter","error","includes","lossy","nav","context","nonSearchParamsEqual","fromAndToState","notSearchParam","nonQueryParamKeys","nonQueryParams","nonQueryParamSet","reloadOnSearch","compositeName","charAt","","abstract","$ViewProvider","$templateFactory","defaults","async","$ViewScrollProvider","useAnchorScroll","$anchorScroll","$timeout","$element","scrollIntoView","$ViewDirective","$uiViewScroll","$interpolate","getService","service","has","getRenderer","attrs","scope","statics","enter","element","target","cb","after","leave","remove","$animate","version","minor","$animator","animate","directive","restrict","terminal","priority","transclude","tElement","tAttrs","$transclude","cleanupLastView","previousEl","currentScope","$destroy","currentEl","$uiViewData","renderer","$$animLeave","updateView","firstTime","newScope","getUiViewName","previousLocals","latestLocals","$new","$emit","clone","animEnter","animLeave","viewAnimData","$animEnter","$animLeave","autoScrollExp","$eval","onloadExp","onload","autoscroll","inheritedData","$ViewDirectiveFill","$compile","$controller","initial","html","resolveData","link","contents","$scope","$onInit","children","uiView","uiViewCreatedBy","parseStateRef","ref","parsed","preparsed","paramExpr","stateContext","el","stateData","getTypeInfo","isSvg","prop","isForm","nodeName","attr","isAnchor","toUpperCase","clickable","clickHook","button","which","ctrlKey","metaKey","shiftKey","preventDefault","ignorePreventDefaultCount","cancel","defaultOpts","$StateRefDirective","require","uiSrefActive","hookFn","uiSref","active","unlinkInfoFn","uiSrefOpts","$$addStateInfo","$set","$watch","bind","unbind","$StateRefDynamicDirective","runStateRefLink","group","uiState","uiStateParams","uiStateOpts","watch","$StateRefActiveDirective","$attrs","addState","stateParams","activeClass","stateHash","createStateHash","stateInfo","activeClasses","idx","anyMatch","addClass","removeClass","exactMatch","activeEqClass","className","uiSrefActiveEq","newState","deregister","$IsStateFilter","isFilter","$stateful","$IncludedByStateFilter","includesFilter","defaultConfig","searchParams","decodePathArray","reverseString","str","unquoteDashes","allReversed","paramName","parameters","nTotal","nPath","paramVal","encodeDashes","encodeURIComponent","c","charCodeAt","isPathParam","isDefaultValue","nextSegment","isFinalPathParam","$subPattern","sub","substr","mode","ArrayType","bindTo","callbackName","arrayWrap","arrayUnwrap","falsey","arrayHandler","allTruthyMode","arrayEqualsHandler","val1","val2","$arrayMode","run","factory","constant","autoinject","defineProperty","_angularAnimate","_angularAnimate2","_angularUiBootstrap","_angularUiBootstrap2","_weather3","_weather4","_weather5","_weather6","assertArg","arg","ngMinErr","mergeClasses","packageStyles","styles","pendClasses","classes","fix","isPrefix","klass","removeFromArray","arr","stripCommentsFromElement","jqLite","nodeType","ELEMENT_NODE","extractElementNode","elm","$$addClass","$$jqLite","$$removeClass","applyAnimationClassesFactory","prepareAnimationOptions","$$prepared","domOperation","noop","$$domOperationFired","applyAnimationStyles","applyAnimationFromStyles","applyAnimationToStyles","css","mergeAnimationDetails","oldAnimation","newAnimation","newOptions","toAdd","toRemove","resolveElementClasses","preparationClasses","concatWithSpace","realDomOperation","existing","splitClassesToLookup","ADD_CLASS","REMOVE_CLASS","flags","allow","getDomNode","applyGeneratedPreparationClasses","event","EVENT_CLASS_PREFIX","ADD_CLASS_SUFFIX","REMOVE_CLASS_SUFFIX","clearGeneratedClasses","blockTransitions","node","duration","applyInlineStyle","TRANSITION_DELAY_PROP","blockKeyframeAnimations","applyBlock","ANIMATION_PROP","ANIMATION_PLAYSTATE_KEY","styleTuple","style","getCssKeyframeDurationStyle","ANIMATION_DURATION_PROP","getCssDelayStyle","delay","isKeyframeAnimation","ANIMATION_DELAY_PROP","computeCssStyles","$window","properties","create","detectedStyles","getComputedStyle","formalStyleName","actualStyleName","parseMaxTime","maxValue","parseFloat","max","truthyTimingValue","getCssTransitionDurationStyle","applyOnlyDuration","TRANSITION_PROP","DURATION_KEY","createLocalCacheLookup","flush","count","entry","total","put","registerRestorableStyles","backup","getPropertyValue","TRANSITIONEND_EVENT","ANIMATIONEND_EVENT","isUndefined","isElement","ACTIVE_CLASS_SUFFIX","PREPARE_CLASS_SUFFIX","NG_ANIMATE_CLASSNAME","NG_ANIMATE_CHILDREN_DATA","CSS_PREFIX","ontransitionend","onwebkittransitionend","onanimationend","onwebkitanimationend","PROPERTY_KEY","DELAY_KEY","TIMING_KEY","ANIMATION_ITERATION_COUNT_KEY","SAFE_FAST_FORWARD_DURATION_VALUE","TRANSITION_DURATION_PROP","$$minErr","$$rAFSchedulerFactory","$$rAF","scheduler","tasks","nextTick","items","cancelFn","waitUntilQuiet","fn","$$AnimateChildrenDirective","setData","ngAnimateChildren","$observe","ANIMATE_TIMER_KEY","ONE_SECOND","ELAPSED_TIME_MAX_DECIMAL_PLACES","CLOSING_TIME_BUFFER","DETECT_CSS_PROPERTIES","transitionDuration","transitionDelay","transitionProperty","animationDuration","animationDelay","animationIterationCount","DETECT_STAGGER_CSS_PROPERTIES","$AnimateCssProvider","$animateProvider","gcsLookup","gcsStaggerLookup","$$AnimateRunner","$$forceReflow","$$rAFScheduler","$$animateQueue","gcsHashFn","extraClasses","KEY","parentNode","parentID","parentCounter","getAttribute","computeCachedCssStyles","cacheKey","timings","computeCachedCssStaggerStyles","stagger","staggerClassName","rafWaitQueue","pageWidth","computeTimings","aD","tD","maxDelay","maxDuration","applyAnimationClasses","initialOptions","endFn","close","rejected","animationClosed","animationCompleted","animationPaused","$$skipPreparationClasses","temporaryStyles","restoreStyles","setProperty","removeProperty","onDone","events","off","onAnimationProgress","animationTimerData","timer","removeData","runner","complete","applyBlocking","blockTransition","blockKeyframeAnimation","closeAndReturnNoopAnimator","end","$$willAnimate","start","stopPropagation","ev","originalEvent","timeStamp","$manualTimeStamp","now","elapsedTime","toFixed","startTime","maxDelayTime","triggerAnimationStart","recalculateTimingStyles","fullClassName","relativeDelay","hasTransitions","hasAnimations","applyAnimationDelay","delayStyle","maxDurationTime","easing","easeProp","easeVal","timerTime","endTime","animationsData","setupFallbackTimer","currentTimerData","expectedEndTime","onAnimationExpired","on","cleanupStyles","playPause","playAnimation","maxStagger","itemIndex","runnerHost","resume","pause","animations","transitions","method","isStructural","structural","structuralClassName","addRemoveClassName","applyClassesEarly","trim","hasToStyles","containsKeyframeAnimation","keyframeStyle","staggerVal","transitionStyle","durationStyle","staggerIndex","isFirst","skipBlocking","hasTransitionAll","applyTransitionDuration","applyAnimationDuration","applyTransitionDelay","$$AnimateCssDriverProvider","$$animationProvider","isDocumentFragment","drivers","NG_ANIMATE_SHIM_CLASS_NAME","NG_ANIMATE_ANCHOR_CLASS_NAME","NG_OUT_ANCHOR_CLASS_NAME","NG_IN_ANCHOR_CLASS_NAME","$animateCss","$rootElement","$document","filterCssClasses","getUniqueValues","prepareAnchoredAnimation","outAnchor","inAnchor","calculateAnchorStyles","anchor","coords","getBoundingClientRect","bodyNode","scrollTop","scrollLeft","prepareOutAnimation","animator","getClassVal","prepareInAnimation","endingClasses","startingClasses","cloneNode","rootBodyElement","append","animatorIn","animatorOut","startingAnimator","currentAnimation","prepareFromToAnchorAnimation","anchors","fromAnimation","prepareRegularAnimation","toAnimation","anchorAnimations","outElement","inElement","animationRunners","animation","status","animationDetails","body","rootNode","contains","$$AnimateJsProvider","lookupAnimations","matches","flagMap","animationFactory","$$registeredAnimations","applyOptions","executeAnimationFn","args","classesToAdd","classesToRemove","groupEventedAnimations","fnName","operations","ani","endProgressCb","onAnimationComplete","cancelled","packageAnimations","runners","animateFn","before","afterFn","beforeFn","onComplete","success","endAnimations","closeActiveAnimations","setHost","$$AnimateJsDriverProvider","$$animateJs","prepareAnimation","endFnFactory","NG_ANIMATE_ATTR_NAME","NG_ANIMATE_PIN_DATA","$$AnimateQueueProvider","makeTruthyCssClassMap","classString","ONE_SPACE","hasMatchingClasses","newClassString","currentClassString","currentClassMap","some","isAllowed","ruleType","previousAnimation","hasAnimationClasses","and","PRE_DIGEST_STATE","RUNNING_STATE","skip","nA","nR","cA","cR","$$HashMap","$$animation","$templateRequest","postDigestTaskFactory","postDigestCalled","$$postDigest","normalizeAnimationDetails","findCallbacks","targetNode","targetParentNode","entries","callbackRegistry","filterFromRegistry","list","matchContainer","matchCallback","containerNode","isMatch","cleanupEventListeners","phase","queueAnimation","notifyProgress","runInNextPostDigestOrNow","callbacks","progress","isAnimatableClassName","documentHidden","hidden","skipAnimations","animationsEnabled","disabledElementsLookup","existingAnimation","activeAnimationsLookup","hasExistingAnimation","areAnimationsAllowed","closeChildAnimations","skipAnimationFlag","cancelAnimationFlag","joinAnimationFlag","isValidAnimation","clearElementAnimationState","counter","markElementAnimationState","animationCancelled","parentElement","realRunner","querySelectorAll","child","removeAttribute","isMatchingElement","nodeOrElmA","nodeOrElmB","animateChildren","bodyElement","bodyElementDetected","rootElementDetected","parentAnimationDetected","elementDisabled","parentHost","details","parentElementDisabled","allowAnimation","setAttribute","oldValue","newValue","deregisterWatch","totalPendingRequests","isEmpty","classNameFilter","Node","compareDocumentPosition","container","eventType","pin","argCount","hasElement","recordExists","$$AnimationProvider","setRunner","RUNNER_STORAGE_KEY","removeRunner","getRunner","NG_ANIMATE_REF_ATTR","sortAnimations","processNode","processed","elementNode","domNode","lookup","parentEntry","tree","flatten","remainingLevelEntries","nextLevelEntries","row","childEntry","animationQueue","getAnchorNodes","SELECTOR","hasAttribute","groupAnimations","preparedAnimations","refLookup","enterOrMove","anchorNodes","direction","animationID","usedIndicesLookup","anchorGroups","indexKey","lookupKey","beforeStart","cssClassesIntersection","out","in","aa","invokeFirstDriver","driverName","driver","tempClasses","prepareClassName","updateAnimationRunners","newRunner","handleDestroyedElement","groupedAnimations","toBeSortedAnimations","animationEntry","startAnimationFn","closeFn","targetElement","operation","animationRunner","ngAnimateSwapDirective","ctrl","previousElement","previousScope","$watchCollection","ngAnimateSwap","$parse","expand","hasClass","expandingExpr","height","scrollHeight","expandDone","expandedExpr","collapse","collapsingExpr","collapseDone","collapsedExpr","expanding","expanded","collapsing","collapsed","uibCollapse","shouldCollapse","closeOthers","accordionConfig","groups","openGroup","isOpen","addGroup","groupScope","that","removeGroup","heading","panelClass","isDisabled","setHeading","accordionCtrl","openClass","toggleClass","toggleOpen","$event","$id","random","headingId","panelId","accordionGroupCtrl","getHeaderSelectors","uibAccordionTransclude","elem","querySelector","closeable","dismissOnTimeout","$parent","toggleEvent","buttonConfig","ctrls","buttonsCtrl","ngModelCtrl","uncheckableExpr","uibUncheckable","find","display","$render","$modelValue","uibBtnRadio","disabled","isActive","uncheckable","$apply","$setViewValue","getTrueValue","getCheckboxValue","btnCheckboxTrue","getFalseValue","btnCheckboxFalse","attribute","$interval","clearBufferedTransitions","bufferedTransitions","setActive","slides","slide","goNext","destroyed","currentIndex","$currentTransition","SLIDE_DIRECTION","currentIdx","getCurrentIndex","isNumber","nextSlide","nextIndex","nextDirection","restartTimer","findSlideIndex","resetTimer","currentInterval","resetTransition","interval","timerFn","isPlaying","next","addSlide","sort","select","play","newIndex","noWrap","prev","removeSlide","bufferedIndex","indexOfSlide","isPrevDisabled","isNextDisabled","noPause","noTransition","actual","carouselCtrl","beforeAddClass","stopped","directionClass","removeClassFn","beforeRemoveClass","$log","$locale","dateFilter","orderByFilter","createParser","quoteIndex","inLiteral","formatCodeToRegex","isValid","year","month","toInt","toTimezone","timezone","convertTimezoneToLocal","fromTimezone","timezoneToOffset","fallback","requestedTimezoneOffset","parse","addDateMinutes","minutes","getTime","setMinutes","getMinutes","dateTimezoneOffset","getTimezoneOffset","timezoneOffset","localeId","SPECIAL_CHARACTERS_REGEXP","init","parsers","formatters","formatter","_date","setFullYear","abs","DATETIME_FORMATS","MONTH","SHORTMONTH","DAY","SHORTDAY","hours","milliseconds","seconds","AMPMS","sign","ERANAMES","ERAS","isDate","parser","_format","reduce","mapper","endStr","input","baseDate","results","tzOffset","fields","dt","getHours","getSeconds","getMilliseconds","warn","datesetter","setUTCFullYear","timesetter","setUTCHours","setHours","ON_REGEXP","IS_REGEXP","linkFn","linkedScopes","instances","exps","exp","addForExp","removeScope","clazz","compareWithExp","expToData","watchFn","compareWithVal","newActivated","instance","thisVal","onExp","lastActivated","watcher","removedScope","targetScope","newWatchScope","onExpMatches","uibIsClass","expsStr","datepickerMode","formatDay","formatMonth","formatYear","formatDayHeader","formatDayTitle","formatMonthTitle","maxDate","maxMode","minDate","minMode","ngModelOptions","shortcutPropagation","showWeeks","yearColumns","yearRows","datepickerConfig","$datepickerLiteralWarning","$datepickerSuppressError","dateParser","setMode","datepickerOptions","watchListeners","modes","startingDay","FIRSTDAYOFWEEK","refreshView","uniqueId","ngDisabled","dateObject","compare","activeDate","activeDateId","uid","ngModelCtrl_","$options","initDate","$isEmpty","$invalid","render","$viewValue","selectedDt","_refreshView","activeDt","$setValidity","createDateObject","model","today","time","label","selected","past","future","customClass","dateDisabled","size","arrays","move","step","years","months","toggleMode","13","32","33","34","35","36","37","38","39","40","focusElement","focus","keydown","altKey","handleKeyDown","getDaysInMonth","DAYS_IN_MONTH","getISO8601WeekNumber","checkDate","setDate","getDay","setMonth","round","getDates","startDate","dates","firstDayOfMonth","difference","numDisplayedFromPreviousMonth","firstDate","days","secondary","labels","abbr","full","title","rows","weekNumbers","thursdayIndex","numWeeks","curWeek","date1","date2","_date1","_date2","min","getStartingYear","range","columns","yearpickerInit","datepickerCtrl","daypickerCtrl","monthpickerCtrl","SCROLLBAR_WIDTH","BODY_SCROLLBAR_WIDTH","OVERFLOW_REGEX","normal","PLACEMENT_REGEX","auto","primary","vertical","BODY_REGEX","getRawNode","parseStyle","isFinite","offsetParent","isStaticPositioned","position","documentElement","scrollbarWidth","isBody","bodyElem","innerWidth","clientWidth","scrollElem","offsetWidth","scrollbarPadding","elemStyle","paddingRight","paddingBottom","scrollParent","tagName","widthOverflow","scrollWidth","originalRight","heightOverflow","clientHeight","bottom","originalBottom","isScrollable","includeHidden","overflowRegex","overflow","overflowY","overflowX","includeSelf","documentEl","excludeStatic","spStyle","includeMagins","elemOffset","offset","top","marginTop","marginLeft","parentOffset","clientTop","clientLeft","width","offsetHeight","elemBCR","pageYOffset","pageXOffset","viewportOffset","useDocument","includePadding","offsetBCR","offsetParentBCR","offsetParentStyle","paddingTop","paddingLeft","parsePlacement","placement","autoPlace","positionElements","hostElem","targetElem","appendToBody","targetWidth","targetHeight","hostElemPos","targetElemPos","targetElemStyle","adjustedSize","marginRight","marginBottom","xOverflow","yOverflow","positionArrow","innerElem","isTooltip","arrowElem","arrowCss","borderProp","borderWidth","borderRadiusProp","borderRadius","altInputFormats","clearText","closeOnDateSelection","closeText","currentText","datepickerPopup","datepickerPopupTemplateUrl","datepickerTemplateUrl","html5Types","datetime-local","onOpenFocus","showButtonBar","$position","datepickerPopupConfig","$datepickerPopupLiteralWarning","parseDateString","viewValue","dateFormat","parseDate","ngModel","allowInvalid","validator","modelValue","ngRequired","documentClickBind","popup","$popup","dpContainsTarget","popupContainsTarget","inputKeydownBind","positionPopup","dpElement","popupPlacement","popupEl","datepickerEl","scrollParentEl","isHtml5DateInput","_ngModel_","datepickerAppendToBody","uibDatepickerPopup","newDateFormat","updateOnDefault","updateOn","ng-model","ng-change","template-url","$formatters","$$parserName","$validators","$parsers","$viewChangeListeners","$$phase","getText","dateSelection","debounceTime","timeoutPromise","appendToOpenClass","openScope","open","dropdownScope","closeDropdown","keybindFilter","getAutoClose","toggleElement","getToggleElement","dropdownElement","getDropdownElement","focusToggleElement","isKeynavEnabled","focusDropdownEntry","dropdownConfig","uibDropdownService","templateScope","getIsOpen","setIsOpen","toggleInvoker","onToggle","appendTo","keynavEnabled","assign","dropdownAppendTo","appendToEl","dropdownAppendToBody","keyboardNav","dropdownMenu","toggle","autoClose","getElement","keyCode","elems","eq","selectedOption","wasOpen","rightalign","pos","appendOffset","openContainer","hasOpenClass","dropdownMenuTemplateUrl","tplContent","newEl","replaceWith","dropdownCtrl","dropdownNested","tplUrl","toggleDropdown","aria-haspopup","aria-expanded","createNew","stack","add","removeTop","hasKey","resolver","setResolver","resolves","resolveObj","resolveIter","$modalStack","modalInClass","NOW_CLOSING_EVENT","setIsAsync","modalOptions","backdropClass","windowClass","windowTopClass","modal","getTop","backdrop","currentTarget","dismiss","$isRendered","modalRenderDeferObj","animationPromise","modalRendered","activeElement","inputWithAutofocus","modalAnimation","uibModalAnimationClass","empty","$$multiMap","$$stackedMap","$uibPosition","isVisible","getClientRects","backdropIndex","topBackdropIndex","opened","openedWindows","topModalIndex","removeModalWindow","modalInstance","elementToReceiveFocus","modalWindow","appendToElement","previousTopOpenedModal","modalDomEl","removeAfterAnimate","modalScope","modalBodyClass","openedClass","OPENED_MODAL_CLASS","openedClasses","areAnyOpen","toggleTopWindowClass","closedDeferred","checkRemoveBackdrop","toggleSwitch","backdropDomEl","backdropScopeRef","backdropScope","domEl","afterAnimating","asyncDeferred","asyncPromise","keydownListener","isDefaultPrevented","keyboard","loadFocusElementList","focusChanged","isFocusInFirstItem","isModalFocused","focusLastFocusableElement","isFocusInLastItem","focusFirstFocusableElement","broadcastClosing","resultOrReason","closing","tabableSelector","newBackdropIndex","modalOpener","deferred","renderDeferred","currBackdropIndex","angularDomEl","windowTemplateUrl","window-class","window-top-class","content","$$uibDestructionScheduled","dismissAll","topModal","srcElement","modalDomE1","elements","$modalProvider","$uibResolve","getTemplatePromise","$modal","promiseChain","getPromiseChain","resolveWithTemplate","templateAndResolvePromise","modalResultDeferred","modalOpenedDeferred","modalClosedDeferred","modalRenderDeferred","closed","rendered","samePromise","tplAndVars","providedScope","$close","$dismiss","ctrlInstance","ctrlInstantiate","ctrlLocals","$uibModalInstance","bindToController","setNumPages","numPages","_watchers","itemsPerPage","totalPages","calculateTotalPages","updatePage","newTotal","oldTotal","totalItems","page","selectPage","clickAllowed","blur","noPrevious","noNext","uibPaging","uibPagerConfig","align","previousText","nextText","paginationCtrl","uibPaginationConfig","makePage","number","getPages","currentPage","pages","startPage","endPage","isMaxSized","maxSize","rotate","pageLabel","forceEllipses","boundaryLinkNumbers","previousPageSet","secondPageLink","firstPageLink","nextPageSet","secondToLastPageLink","lastPageLink","$page","boundaryLinks","directionLinks","originalRender","firstText","lastText","snake_case","separator","letter","toLowerCase","defaultOptions","placementClassPrefix","popupDelay","popupCloseDelay","useContentExp","triggerMap","mouseenter","click","outsideClick","none","globalOptions","setTriggers","triggers","keypressListener","openedTooltips","ttType","defaultTriggerShow","getTriggers","trigger","show","hide","directiveName","startSym","startSymbol","endSym","endSymbol","tElem","tooltipLinker","tooltipCtrl","toggleTooltipBind","ttScope","hideTooltipBind","showTooltipBind","hasEnableExp","cancelHide","prepareTooltip","showTimeout","cancelShow","hideTimeout","createTooltip","$evalAsync","assignIsOpen","positionTooltip","positionTimeout","transitionTimeout","removeTooltip","tooltip","tooltipLinkedScope","prepObservers","unregisterObservers","contentParse","popupClass","lastPlacement","closeDelay","isOpenParse","observers","repositionScheduled","observer","bodyHideTooltipBind","prepTriggers","unregisterTriggers","ttPosition","origScope","contentExp","appendToBodyVal","appendKey","$sce","currentElement","tooltipTemplateTranscludeScope","changeCounter","cleanupLastIncludeContent","parseAsResourceUrl","uibTooltipTemplateTransclude","src","thisChangeId","tooltipAnimationClass","$uibTooltip","originScope","uibTitle","progressConfig","getMaxOrDefault","maxParam","bars","addBar","bar","recalculatePercentage","totalPercentage","percent","removeBar","progressCtrl","stateOn","stateOff","enableReset","titles","ratingConfig","tmpTitles","ratingStates","buildTemplateObjects","getTitle","rate","readonly","newViewValue","onHover","reset","onLeave","onKeydown","ratingCtrl","findTabIndex","tabs","oldIndex","previousIndex","previousSelected","tab","onDeselect","$selectedIndex","onSelect","addTab","t1","t2","newActiveIndex","removeTab","newActiveTabIndex","justified","tabsetCtrl","disable","t","$transcludeFn","isTabHeading","uibTabContentTransclude","headingElement","hourStep","minuteStep","secondStep","showMeridian","showSeconds","meridians","readonlyInput","mousewheel","arrowkeys","showSpinners","timepickerConfig","getHoursFromTemplate","valid","meridian","getMinutesFromTemplate","getSecondsFromTemplate","pad","noPad","refresh","keyboardChange","makeValid","updateTemplate","invalidHours","invalidMinutes","invalidSeconds","padHours","addSecondsToSelected","addSeconds","addMinutes","newDate","modelIsEmpty","watchers","tabindex","removeAttr","inputs","hoursInputEl","minutesInputEl","secondsInputEl","setupMousewheelEvents","setupArrowkeyEvents","setupInputEvents","noIncrementHours","incrementedSelected","noDecrementHours","decrementedSelected","noIncrementMinutes","noDecrementMinutes","noIncrementSeconds","noDecrementSeconds","noToggleMeridian","$error","isScrollingUp","delta","wheelDelta","deltaY","detail","incrementHours","decrementHours","incrementMinutes","decrementMinutes","incrementSeconds","decrementSeconds","updateHours","updateMinutes","updateSeconds","invalidate","$setDirty","$setTouched","setSeconds","toggleMeridian","uibTimepickerConfig","timepickerCtrl","TYPEAHEAD_REGEXP","itemName","viewMapper","modelMapper","originalScope","$$debounce","typeaheadParser","fireRecalculating","moveInProgress","$digest","debouncedRecalculate","recalculatePosition","modelCtrl","HOT_KEYS","eventDebounceTime","minLength","typeaheadMinLength","newVal","waitTime","typeaheadWaitMs","isEditable","typeaheadEditable","hasFocus","isLoadingSetter","typeaheadLoading","isSelectEvent","typeaheadShouldSelect","vals","onSelectCallback","typeaheadOnSelect","isSelectOnBlur","typeaheadSelectOnBlur","isNoResultsSetter","typeaheadNoResults","inputFormatter","typeaheadInputFormatter","typeaheadAppendToBody","typeaheadAppendTo","focusFirst","typeaheadFocusFirst","selectOnExact","typeaheadSelectOnExact","isOpenSetter","typeaheadIsOpen","showHint","typeaheadShowHint","parsedModel","invokeModelSetter","$setModelValue","getterSetter","$$$p","parserResult","uibTypeahead","offDestroy","popupId","aria-autocomplete","aria-owns","inputsContainer","hintInputElem","border-color","box-shadow","opacity","background","color","vertical-align","background-color","popUpEl","move-in-progress","query","assign-is-open","debounce","typeaheadTemplateUrl","typeaheadPopupTemplateUrl","resetHint","resetMatches","activeIdx","getMatchId","inputIsExactMatch","inputValue","getMatchesAsync","onCurrentRequest","debounceUpdate","firstLabel","scheduleSearchWithTimeout","cancelPreviousTimeout","$item","$model","$label","typeaheadFocusOnSelect","shouldSelect","offsetTop","editable","dismissClickHandler","_modelCtrl","_ngModelOptions","candidateViewValue","emptyViewValue","popupTemplateUrl","isDropdownOpen","matchIdx","selectActive","selectMatch","tplEl","escapeRegexp","queryToEscape","containsHtml","matchItem","isSanitizePresent","trustAsHtml","$$csp","noInlineStyle","$$uibCarouselCss","document","prepend","$$uibDatepickerCss","$$uibPositionCss","$$uibDatepickerpopupCss","$$uibTooltipCss","$$uibTimepickerCss","$$uibTypeaheadCss","routes","$stateProvider","_classCallCheck","Constructor","TypeError","WeatherCtrl","apiservice","_this","woeid","getWeather","forecast","_createClass","defineProperties","props","descriptor","enumerable","configurable","writable","protoProps","staticProps","GEOCODE_ENDPOINT","YAHOO_GEO_APP_ID","APP_ID","LOCATION","FLAGS","FORECAST_ENDPOINT","FORECAST_YQL_OPEN","FORECAST_YQL_CLOSE","routing"],"mappings":"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","file":"app.js","sourcesContent":["webpackJsonp([0,3],[\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _angularUiRouter = __webpack_require__(3);\n\t\n\tvar _angularUiRouter2 = _interopRequireDefault(_angularUiRouter);\n\t\n\tvar _weather = __webpack_require__(4);\n\t\n\tvar _weather2 = _interopRequireDefault(_weather);\n\t\n\tvar _index = __webpack_require__(13);\n\t\n\tvar _index2 = _interopRequireDefault(_index);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t_angular2.default.module('appNomin', [_angularUiRouter2.default, _weather2.default]).config(_index2.default);\n\n/***/ },\n/* 1 */,\n/* 2 */,\n/* 3 */\n/***/ function(module, exports) {\n\n\t/**\n\t * State-based routing for AngularJS\n\t * @version v0.3.1\n\t * @link http://angular-ui.github.com/\n\t * @license MIT License, http://www.opensource.org/licenses/MIT\n\t */\n\t\n\t/* commonjs package manager support (eg componentjs) */\n\tif (typeof module !== \"undefined\" && typeof exports !== \"undefined\" && module.exports === exports){\n\t  module.exports = 'ui.router';\n\t}\n\t\n\t(function (window, angular, undefined) {\n\t/*jshint globalstrict:true*/\n\t/*global angular:false*/\n\t'use strict';\n\t\n\tvar isDefined = angular.isDefined,\n\t    isFunction = angular.isFunction,\n\t    isString = angular.isString,\n\t    isObject = angular.isObject,\n\t    isArray = angular.isArray,\n\t    forEach = angular.forEach,\n\t    extend = angular.extend,\n\t    copy = angular.copy,\n\t    toJson = angular.toJson;\n\t\n\tfunction inherit(parent, extra) {\n\t  return extend(new (extend(function() {}, { prototype: parent }))(), extra);\n\t}\n\t\n\tfunction merge(dst) {\n\t  forEach(arguments, function(obj) {\n\t    if (obj !== dst) {\n\t      forEach(obj, function(value, key) {\n\t        if (!dst.hasOwnProperty(key)) dst[key] = value;\n\t      });\n\t    }\n\t  });\n\t  return dst;\n\t}\n\t\n\t/**\n\t * Finds the common ancestor path between two states.\n\t *\n\t * @param {Object} first The first state.\n\t * @param {Object} second The second state.\n\t * @return {Array} Returns an array of state names in descending order, not including the root.\n\t */\n\tfunction ancestors(first, second) {\n\t  var path = [];\n\t\n\t  for (var n in first.path) {\n\t    if (first.path[n] !== second.path[n]) break;\n\t    path.push(first.path[n]);\n\t  }\n\t  return path;\n\t}\n\t\n\t/**\n\t * IE8-safe wrapper for `Object.keys()`.\n\t *\n\t * @param {Object} object A JavaScript object.\n\t * @return {Array} Returns the keys of the object as an array.\n\t */\n\tfunction objectKeys(object) {\n\t  if (Object.keys) {\n\t    return Object.keys(object);\n\t  }\n\t  var result = [];\n\t\n\t  forEach(object, function(val, key) {\n\t    result.push(key);\n\t  });\n\t  return result;\n\t}\n\t\n\t/**\n\t * IE8-safe wrapper for `Array.prototype.indexOf()`.\n\t *\n\t * @param {Array} array A JavaScript array.\n\t * @param {*} value A value to search the array for.\n\t * @return {Number} Returns the array index value of `value`, or `-1` if not present.\n\t */\n\tfunction indexOf(array, value) {\n\t  if (Array.prototype.indexOf) {\n\t    return array.indexOf(value, Number(arguments[2]) || 0);\n\t  }\n\t  var len = array.length >>> 0, from = Number(arguments[2]) || 0;\n\t  from = (from < 0) ? Math.ceil(from) : Math.floor(from);\n\t\n\t  if (from < 0) from += len;\n\t\n\t  for (; from < len; from++) {\n\t    if (from in array && array[from] === value) return from;\n\t  }\n\t  return -1;\n\t}\n\t\n\t/**\n\t * Merges a set of parameters with all parameters inherited between the common parents of the\n\t * current state and a given destination state.\n\t *\n\t * @param {Object} currentParams The value of the current state parameters ($stateParams).\n\t * @param {Object} newParams The set of parameters which will be composited with inherited params.\n\t * @param {Object} $current Internal definition of object representing the current state.\n\t * @param {Object} $to Internal definition of object representing state to transition to.\n\t */\n\tfunction inheritParams(currentParams, newParams, $current, $to) {\n\t  var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n\t\n\t  for (var i in parents) {\n\t    if (!parents[i] || !parents[i].params) continue;\n\t    parentParams = objectKeys(parents[i].params);\n\t    if (!parentParams.length) continue;\n\t\n\t    for (var j in parentParams) {\n\t      if (indexOf(inheritList, parentParams[j]) >= 0) continue;\n\t      inheritList.push(parentParams[j]);\n\t      inherited[parentParams[j]] = currentParams[parentParams[j]];\n\t    }\n\t  }\n\t  return extend({}, inherited, newParams);\n\t}\n\t\n\t/**\n\t * Performs a non-strict comparison of the subset of two objects, defined by a list of keys.\n\t *\n\t * @param {Object} a The first object.\n\t * @param {Object} b The second object.\n\t * @param {Array} keys The list of keys within each object to compare. If the list is empty or not specified,\n\t *                     it defaults to the list of keys in `a`.\n\t * @return {Boolean} Returns `true` if the keys match, otherwise `false`.\n\t */\n\tfunction equalForKeys(a, b, keys) {\n\t  if (!keys) {\n\t    keys = [];\n\t    for (var n in a) keys.push(n); // Used instead of Object.keys() for IE8 compatibility\n\t  }\n\t\n\t  for (var i=0; i<keys.length; i++) {\n\t    var k = keys[i];\n\t    if (a[k] != b[k]) return false; // Not '===', values aren't necessarily normalized\n\t  }\n\t  return true;\n\t}\n\t\n\t/**\n\t * Returns the subset of an object, based on a list of keys.\n\t *\n\t * @param {Array} keys\n\t * @param {Object} values\n\t * @return {Boolean} Returns a subset of `values`.\n\t */\n\tfunction filterByKeys(keys, values) {\n\t  var filtered = {};\n\t\n\t  forEach(keys, function (name) {\n\t    filtered[name] = values[name];\n\t  });\n\t  return filtered;\n\t}\n\t\n\t// like _.indexBy\n\t// when you know that your index values will be unique, or you want last-one-in to win\n\tfunction indexBy(array, propName) {\n\t  var result = {};\n\t  forEach(array, function(item) {\n\t    result[item[propName]] = item;\n\t  });\n\t  return result;\n\t}\n\t\n\t// extracted from underscore.js\n\t// Return a copy of the object only containing the whitelisted properties.\n\tfunction pick(obj) {\n\t  var copy = {};\n\t  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n\t  forEach(keys, function(key) {\n\t    if (key in obj) copy[key] = obj[key];\n\t  });\n\t  return copy;\n\t}\n\t\n\t// extracted from underscore.js\n\t// Return a copy of the object omitting the blacklisted properties.\n\tfunction omit(obj) {\n\t  var copy = {};\n\t  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n\t  for (var key in obj) {\n\t    if (indexOf(keys, key) == -1) copy[key] = obj[key];\n\t  }\n\t  return copy;\n\t}\n\t\n\tfunction pluck(collection, key) {\n\t  var result = isArray(collection) ? [] : {};\n\t\n\t  forEach(collection, function(val, i) {\n\t    result[i] = isFunction(key) ? key(val) : val[key];\n\t  });\n\t  return result;\n\t}\n\t\n\tfunction filter(collection, callback) {\n\t  var array = isArray(collection);\n\t  var result = array ? [] : {};\n\t  forEach(collection, function(val, i) {\n\t    if (callback(val, i)) {\n\t      result[array ? result.length : i] = val;\n\t    }\n\t  });\n\t  return result;\n\t}\n\t\n\tfunction map(collection, callback) {\n\t  var result = isArray(collection) ? [] : {};\n\t\n\t  forEach(collection, function(val, i) {\n\t    result[i] = callback(val, i);\n\t  });\n\t  return result;\n\t}\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name ui.router.util\n\t *\n\t * @description\n\t * # ui.router.util sub-module\n\t *\n\t * This module is a dependency of other sub-modules. Do not include this module as a dependency\n\t * in your angular app (use {@link ui.router} module instead).\n\t *\n\t */\n\tangular.module('ui.router.util', ['ng']);\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name ui.router.router\n\t * \n\t * @requires ui.router.util\n\t *\n\t * @description\n\t * # ui.router.router sub-module\n\t *\n\t * This module is a dependency of other sub-modules. Do not include this module as a dependency\n\t * in your angular app (use {@link ui.router} module instead).\n\t */\n\tangular.module('ui.router.router', ['ui.router.util']);\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name ui.router.state\n\t * \n\t * @requires ui.router.router\n\t * @requires ui.router.util\n\t *\n\t * @description\n\t * # ui.router.state sub-module\n\t *\n\t * This module is a dependency of the main ui.router module. Do not include this module as a dependency\n\t * in your angular app (use {@link ui.router} module instead).\n\t * \n\t */\n\tangular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name ui.router\n\t *\n\t * @requires ui.router.state\n\t *\n\t * @description\n\t * # ui.router\n\t * \n\t * ## The main module for ui.router \n\t * There are several sub-modules included with the ui.router module, however only this module is needed\n\t * as a dependency within your angular app. The other modules are for organization purposes. \n\t *\n\t * The modules are:\n\t * * ui.router - the main \"umbrella\" module\n\t * * ui.router.router - \n\t * \n\t * *You'll need to include **only** this module as the dependency within your angular app.*\n\t * \n\t * <pre>\n\t * <!doctype html>\n\t * <html ng-app=\"myApp\">\n\t * <head>\n\t *   <script src=\"js/angular.js\"></script>\n\t *   <!-- Include the ui-router script -->\n\t *   <script src=\"js/angular-ui-router.min.js\"></script>\n\t *   <script>\n\t *     // ...and add 'ui.router' as a dependency\n\t *     var myApp = angular.module('myApp', ['ui.router']);\n\t *   </script>\n\t * </head>\n\t * <body>\n\t * </body>\n\t * </html>\n\t * </pre>\n\t */\n\tangular.module('ui.router', ['ui.router.state']);\n\t\n\tangular.module('ui.router.compat', ['ui.router']);\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.$resolve\n\t *\n\t * @requires $q\n\t * @requires $injector\n\t *\n\t * @description\n\t * Manages resolution of (acyclic) graphs of promises.\n\t */\n\t$Resolve.$inject = ['$q', '$injector'];\n\tfunction $Resolve(  $q,    $injector) {\n\t  \n\t  var VISIT_IN_PROGRESS = 1,\n\t      VISIT_DONE = 2,\n\t      NOTHING = {},\n\t      NO_DEPENDENCIES = [],\n\t      NO_LOCALS = NOTHING,\n\t      NO_PARENT = extend($q.when(NOTHING), { $$promises: NOTHING, $$values: NOTHING });\n\t  \n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$resolve#study\n\t   * @methodOf ui.router.util.$resolve\n\t   *\n\t   * @description\n\t   * Studies a set of invocables that are likely to be used multiple times.\n\t   * <pre>\n\t   * $resolve.study(invocables)(locals, parent, self)\n\t   * </pre>\n\t   * is equivalent to\n\t   * <pre>\n\t   * $resolve.resolve(invocables, locals, parent, self)\n\t   * </pre>\n\t   * but the former is more efficient (in fact `resolve` just calls `study` \n\t   * internally).\n\t   *\n\t   * @param {object} invocables Invocable objects\n\t   * @return {function} a function to pass in locals, parent and self\n\t   */\n\t  this.study = function (invocables) {\n\t    if (!isObject(invocables)) throw new Error(\"'invocables' must be an object\");\n\t    var invocableKeys = objectKeys(invocables || {});\n\t    \n\t    // Perform a topological sort of invocables to build an ordered plan\n\t    var plan = [], cycle = [], visited = {};\n\t    function visit(value, key) {\n\t      if (visited[key] === VISIT_DONE) return;\n\t      \n\t      cycle.push(key);\n\t      if (visited[key] === VISIT_IN_PROGRESS) {\n\t        cycle.splice(0, indexOf(cycle, key));\n\t        throw new Error(\"Cyclic dependency: \" + cycle.join(\" -> \"));\n\t      }\n\t      visited[key] = VISIT_IN_PROGRESS;\n\t      \n\t      if (isString(value)) {\n\t        plan.push(key, [ function() { return $injector.get(value); }], NO_DEPENDENCIES);\n\t      } else {\n\t        var params = $injector.annotate(value);\n\t        forEach(params, function (param) {\n\t          if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);\n\t        });\n\t        plan.push(key, value, params);\n\t      }\n\t      \n\t      cycle.pop();\n\t      visited[key] = VISIT_DONE;\n\t    }\n\t    forEach(invocables, visit);\n\t    invocables = cycle = visited = null; // plan is all that's required\n\t    \n\t    function isResolve(value) {\n\t      return isObject(value) && value.then && value.$$promises;\n\t    }\n\t    \n\t    return function (locals, parent, self) {\n\t      if (isResolve(locals) && self === undefined) {\n\t        self = parent; parent = locals; locals = null;\n\t      }\n\t      if (!locals) locals = NO_LOCALS;\n\t      else if (!isObject(locals)) {\n\t        throw new Error(\"'locals' must be an object\");\n\t      }       \n\t      if (!parent) parent = NO_PARENT;\n\t      else if (!isResolve(parent)) {\n\t        throw new Error(\"'parent' must be a promise returned by $resolve.resolve()\");\n\t      }\n\t      \n\t      // To complete the overall resolution, we have to wait for the parent\n\t      // promise and for the promise for each invokable in our plan.\n\t      var resolution = $q.defer(),\n\t          result = resolution.promise,\n\t          promises = result.$$promises = {},\n\t          values = extend({}, locals),\n\t          wait = 1 + plan.length/3,\n\t          merged = false;\n\t          \n\t      function done() {\n\t        // Merge parent values we haven't got yet and publish our own $$values\n\t        if (!--wait) {\n\t          if (!merged) merge(values, parent.$$values); \n\t          result.$$values = values;\n\t          result.$$promises = result.$$promises || true; // keep for isResolve()\n\t          delete result.$$inheritedValues;\n\t          resolution.resolve(values);\n\t        }\n\t      }\n\t      \n\t      function fail(reason) {\n\t        result.$$failure = reason;\n\t        resolution.reject(reason);\n\t      }\n\t\n\t      // Short-circuit if parent has already failed\n\t      if (isDefined(parent.$$failure)) {\n\t        fail(parent.$$failure);\n\t        return result;\n\t      }\n\t      \n\t      if (parent.$$inheritedValues) {\n\t        merge(values, omit(parent.$$inheritedValues, invocableKeys));\n\t      }\n\t\n\t      // Merge parent values if the parent has already resolved, or merge\n\t      // parent promises and wait if the parent resolve is still in progress.\n\t      extend(promises, parent.$$promises);\n\t      if (parent.$$values) {\n\t        merged = merge(values, omit(parent.$$values, invocableKeys));\n\t        result.$$inheritedValues = omit(parent.$$values, invocableKeys);\n\t        done();\n\t      } else {\n\t        if (parent.$$inheritedValues) {\n\t          result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);\n\t        }        \n\t        parent.then(done, fail);\n\t      }\n\t      \n\t      // Process each invocable in the plan, but ignore any where a local of the same name exists.\n\t      for (var i=0, ii=plan.length; i<ii; i+=3) {\n\t        if (locals.hasOwnProperty(plan[i])) done();\n\t        else invoke(plan[i], plan[i+1], plan[i+2]);\n\t      }\n\t      \n\t      function invoke(key, invocable, params) {\n\t        // Create a deferred for this invocation. Failures will propagate to the resolution as well.\n\t        var invocation = $q.defer(), waitParams = 0;\n\t        function onfailure(reason) {\n\t          invocation.reject(reason);\n\t          fail(reason);\n\t        }\n\t        // Wait for any parameter that we have a promise for (either from parent or from this\n\t        // resolve; in that case study() will have made sure it's ordered before us in the plan).\n\t        forEach(params, function (dep) {\n\t          if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {\n\t            waitParams++;\n\t            promises[dep].then(function (result) {\n\t              values[dep] = result;\n\t              if (!(--waitParams)) proceed();\n\t            }, onfailure);\n\t          }\n\t        });\n\t        if (!waitParams) proceed();\n\t        function proceed() {\n\t          if (isDefined(result.$$failure)) return;\n\t          try {\n\t            invocation.resolve($injector.invoke(invocable, self, values));\n\t            invocation.promise.then(function (result) {\n\t              values[key] = result;\n\t              done();\n\t            }, onfailure);\n\t          } catch (e) {\n\t            onfailure(e);\n\t          }\n\t        }\n\t        // Publish promise synchronously; invocations further down in the plan may depend on it.\n\t        promises[key] = invocation.promise;\n\t      }\n\t      \n\t      return result;\n\t    };\n\t  };\n\t  \n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$resolve#resolve\n\t   * @methodOf ui.router.util.$resolve\n\t   *\n\t   * @description\n\t   * Resolves a set of invocables. An invocable is a function to be invoked via \n\t   * `$injector.invoke()`, and can have an arbitrary number of dependencies. \n\t   * An invocable can either return a value directly,\n\t   * or a `$q` promise. If a promise is returned it will be resolved and the \n\t   * resulting value will be used instead. Dependencies of invocables are resolved \n\t   * (in this order of precedence)\n\t   *\n\t   * - from the specified `locals`\n\t   * - from another invocable that is part of this `$resolve` call\n\t   * - from an invocable that is inherited from a `parent` call to `$resolve` \n\t   *   (or recursively\n\t   * - from any ancestor `$resolve` of that parent).\n\t   *\n\t   * The return value of `$resolve` is a promise for an object that contains \n\t   * (in this order of precedence)\n\t   *\n\t   * - any `locals` (if specified)\n\t   * - the resolved return values of all injectables\n\t   * - any values inherited from a `parent` call to `$resolve` (if specified)\n\t   *\n\t   * The promise will resolve after the `parent` promise (if any) and all promises \n\t   * returned by injectables have been resolved. If any invocable \n\t   * (or `$injector.invoke`) throws an exception, or if a promise returned by an \n\t   * invocable is rejected, the `$resolve` promise is immediately rejected with the \n\t   * same error. A rejection of a `parent` promise (if specified) will likewise be \n\t   * propagated immediately. Once the `$resolve` promise has been rejected, no \n\t   * further invocables will be called.\n\t   * \n\t   * Cyclic dependencies between invocables are not permitted and will cause `$resolve`\n\t   * to throw an error. As a special case, an injectable can depend on a parameter \n\t   * with the same name as the injectable, which will be fulfilled from the `parent` \n\t   * injectable of the same name. This allows inherited values to be decorated. \n\t   * Note that in this case any other injectable in the same `$resolve` with the same\n\t   * dependency would see the decorated value, not the inherited value.\n\t   *\n\t   * Note that missing dependencies -- unlike cyclic dependencies -- will cause an \n\t   * (asynchronous) rejection of the `$resolve` promise rather than a (synchronous) \n\t   * exception.\n\t   *\n\t   * Invocables are invoked eagerly as soon as all dependencies are available. \n\t   * This is true even for dependencies inherited from a `parent` call to `$resolve`.\n\t   *\n\t   * As a special case, an invocable can be a string, in which case it is taken to \n\t   * be a service name to be passed to `$injector.get()`. This is supported primarily \n\t   * for backwards-compatibility with the `resolve` property of `$routeProvider` \n\t   * routes.\n\t   *\n\t   * @param {object} invocables functions to invoke or \n\t   * `$injector` services to fetch.\n\t   * @param {object} locals  values to make available to the injectables\n\t   * @param {object} parent  a promise returned by another call to `$resolve`.\n\t   * @param {object} self  the `this` for the invoked methods\n\t   * @return {object} Promise for an object that contains the resolved return value\n\t   * of all invocables, as well as any inherited and local values.\n\t   */\n\t  this.resolve = function (invocables, locals, parent, self) {\n\t    return this.study(invocables)(locals, parent, self);\n\t  };\n\t}\n\t\n\tangular.module('ui.router.util').service('$resolve', $Resolve);\n\t\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.$templateFactory\n\t *\n\t * @requires $http\n\t * @requires $templateCache\n\t * @requires $injector\n\t *\n\t * @description\n\t * Service. Manages loading of templates.\n\t */\n\t$TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];\n\tfunction $TemplateFactory(  $http,   $templateCache,   $injector) {\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$templateFactory#fromConfig\n\t   * @methodOf ui.router.util.$templateFactory\n\t   *\n\t   * @description\n\t   * Creates a template from a configuration object. \n\t   *\n\t   * @param {object} config Configuration object for which to load a template. \n\t   * The following properties are search in the specified order, and the first one \n\t   * that is defined is used to create the template:\n\t   *\n\t   * @param {string|object} config.template html string template or function to \n\t   * load via {@link ui.router.util.$templateFactory#fromString fromString}.\n\t   * @param {string|object} config.templateUrl url to load or a function returning \n\t   * the url to load via {@link ui.router.util.$templateFactory#fromUrl fromUrl}.\n\t   * @param {Function} config.templateProvider function to invoke via \n\t   * {@link ui.router.util.$templateFactory#fromProvider fromProvider}.\n\t   * @param {object} params  Parameters to pass to the template function.\n\t   * @param {object} locals Locals to pass to `invoke` if the template is loaded \n\t   * via a `templateProvider`. Defaults to `{ params: params }`.\n\t   *\n\t   * @return {string|object}  The template html as a string, or a promise for \n\t   * that string,or `null` if no template is configured.\n\t   */\n\t  this.fromConfig = function (config, params, locals) {\n\t    return (\n\t      isDefined(config.template) ? this.fromString(config.template, params) :\n\t      isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) :\n\t      isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) :\n\t      null\n\t    );\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$templateFactory#fromString\n\t   * @methodOf ui.router.util.$templateFactory\n\t   *\n\t   * @description\n\t   * Creates a template from a string or a function returning a string.\n\t   *\n\t   * @param {string|object} template html template as a string or function that \n\t   * returns an html template as a string.\n\t   * @param {object} params Parameters to pass to the template function.\n\t   *\n\t   * @return {string|object} The template html as a string, or a promise for that \n\t   * string.\n\t   */\n\t  this.fromString = function (template, params) {\n\t    return isFunction(template) ? template(params) : template;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$templateFactory#fromUrl\n\t   * @methodOf ui.router.util.$templateFactory\n\t   * \n\t   * @description\n\t   * Loads a template from the a URL via `$http` and `$templateCache`.\n\t   *\n\t   * @param {string|Function} url url of the template to load, or a function \n\t   * that returns a url.\n\t   * @param {Object} params Parameters to pass to the url function.\n\t   * @return {string|Promise.<string>} The template html as a string, or a promise \n\t   * for that string.\n\t   */\n\t  this.fromUrl = function (url, params) {\n\t    if (isFunction(url)) url = url(params);\n\t    if (url == null) return null;\n\t    else return $http\n\t        .get(url, { cache: $templateCache, headers: { Accept: 'text/html' }})\n\t        .then(function(response) { return response.data; });\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$templateFactory#fromProvider\n\t   * @methodOf ui.router.util.$templateFactory\n\t   *\n\t   * @description\n\t   * Creates a template by invoking an injectable provider function.\n\t   *\n\t   * @param {Function} provider Function to invoke via `$injector.invoke`\n\t   * @param {Object} params Parameters for the template.\n\t   * @param {Object} locals Locals to pass to `invoke`. Defaults to \n\t   * `{ params: params }`.\n\t   * @return {string|Promise.<string>} The template html as a string, or a promise \n\t   * for that string.\n\t   */\n\t  this.fromProvider = function (provider, params, locals) {\n\t    return $injector.invoke(provider, null, locals || { params: params });\n\t  };\n\t}\n\t\n\tangular.module('ui.router.util').service('$templateFactory', $TemplateFactory);\n\t\n\tvar $$UMFP; // reference to $UrlMatcherFactoryProvider\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Matches URLs against patterns and extracts named parameters from the path or the search\n\t * part of the URL. A URL pattern consists of a path pattern, optionally followed by '?' and a list\n\t * of search parameters. Multiple search parameter names are separated by '&'. Search parameters\n\t * do not influence whether or not a URL is matched, but their values are passed through into\n\t * the matched parameters returned by {@link ui.router.util.type:UrlMatcher#methods_exec exec}.\n\t *\n\t * Path parameter placeholders can be specified using simple colon/catch-all syntax or curly brace\n\t * syntax, which optionally allows a regular expression for the parameter to be specified:\n\t *\n\t * * `':'` name - colon placeholder\n\t * * `'*'` name - catch-all placeholder\n\t * * `'{' name '}'` - curly placeholder\n\t * * `'{' name ':' regexp|type '}'` - curly placeholder with regexp or type name. Should the\n\t *   regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n\t *\n\t * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n\t * must be unique within the pattern (across both path and search parameters). For colon\n\t * placeholders or curly placeholders without an explicit regexp, a path parameter matches any\n\t * number of characters other than '/'. For catch-all placeholders the path parameter matches\n\t * any number of characters.\n\t *\n\t * Examples:\n\t *\n\t * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n\t *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n\t * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n\t *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n\t * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n\t * * `'/user/{id:[^/]*}'` - Same as the previous example.\n\t * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n\t *   parameter consists of 1 to 8 hex digits.\n\t * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n\t *   path into the parameter 'path'.\n\t * * `'/files/*path'` - ditto.\n\t * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n\t *   in the built-in  `date` Type matches `2014-11-12`) and provides a Date object in $stateParams.start\n\t *\n\t * @param {string} pattern  The pattern to compile into a matcher.\n\t * @param {Object} config  A configuration object hash:\n\t * @param {Object=} parentMatcher Used to concatenate the pattern/config onto\n\t *   an existing UrlMatcher\n\t *\n\t * * `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n\t * * `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n\t *\n\t * @property {string} prefix  A static prefix of this pattern. The matcher guarantees that any\n\t *   URL matching this matcher (i.e. any string for which {@link ui.router.util.type:UrlMatcher#methods_exec exec()} returns\n\t *   non-null) will start with this prefix.\n\t *\n\t * @property {string} source  The pattern that was passed into the constructor\n\t *\n\t * @property {string} sourcePath  The path portion of the source property\n\t *\n\t * @property {string} sourceSearch  The search portion of the source property\n\t *\n\t * @property {string} regex  The constructed regex that will be used to match against the url when\n\t *   it is time to determine which url will match.\n\t *\n\t * @returns {Object}  New `UrlMatcher` object\n\t */\n\tfunction UrlMatcher(pattern, config, parentMatcher) {\n\t  config = extend({ params: {} }, isObject(config) ? config : {});\n\t\n\t  // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n\t  //   '*' name\n\t  //   ':' name\n\t  //   '{' name '}'\n\t  //   '{' name ':' regexp '}'\n\t  // The regular expression is somewhat complicated due to the need to allow curly braces\n\t  // inside the regular expression. The placeholder regexp breaks down as follows:\n\t  //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n\t  //    \\{([\\w\\[\\]]+)(?:\\:\\s*( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n\t  //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n\t  //    [^{}\\\\]+                       - anything other than curly braces or backslash\n\t  //    \\\\.                            - a backslash escape\n\t  //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n\t  var placeholder       = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n\t      searchPlaceholder = /([:]?)([\\w\\[\\].-]+)|\\{([\\w\\[\\].-]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n\t      compiled = '^', last = 0, m,\n\t      segments = this.segments = [],\n\t      parentParams = parentMatcher ? parentMatcher.params : {},\n\t      params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),\n\t      paramNames = [];\n\t\n\t  function addParameter(id, type, config, location) {\n\t    paramNames.push(id);\n\t    if (parentParams[id]) return parentParams[id];\n\t    if (!/^\\w+([-.]+\\w+)*(?:\\[\\])?$/.test(id)) throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n\t    if (params[id]) throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n\t    params[id] = new $$UMFP.Param(id, type, config, location);\n\t    return params[id];\n\t  }\n\t\n\t  function quoteRegExp(string, pattern, squash, optional) {\n\t    var surroundPattern = ['',''], result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n\t    if (!pattern) return result;\n\t    switch(squash) {\n\t      case false: surroundPattern = ['(', ')' + (optional ? \"?\" : \"\")]; break;\n\t      case true:\n\t        result = result.replace(/\\/$/, '');\n\t        surroundPattern = ['(?:\\/(', ')|\\/)?'];\n\t      break;\n\t      default:    surroundPattern = ['(' + squash + \"|\", ')?']; break;\n\t    }\n\t    return result + surroundPattern[0] + pattern + surroundPattern[1];\n\t  }\n\t\n\t  this.source = pattern;\n\t\n\t  // Split into static segments separated by path parameter placeholders.\n\t  // The number of segments is always 1 more than the number of parameters.\n\t  function matchDetails(m, isSearch) {\n\t    var id, regexp, segment, type, cfg, arrayMode;\n\t    id          = m[2] || m[3]; // IE[78] returns '' for unmatched groups instead of null\n\t    cfg         = config.params[id];\n\t    segment     = pattern.substring(last, m.index);\n\t    regexp      = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);\n\t\n\t    if (regexp) {\n\t      type      = $$UMFP.type(regexp) || inherit($$UMFP.type(\"string\"), { pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined) });\n\t    }\n\t\n\t    return {\n\t      id: id, regexp: regexp, segment: segment, type: type, cfg: cfg\n\t    };\n\t  }\n\t\n\t  var p, param, segment;\n\t  while ((m = placeholder.exec(pattern))) {\n\t    p = matchDetails(m, false);\n\t    if (p.segment.indexOf('?') >= 0) break; // we're into the search part\n\t\n\t    param = addParameter(p.id, p.type, p.cfg, \"path\");\n\t    compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);\n\t    segments.push(p.segment);\n\t    last = placeholder.lastIndex;\n\t  }\n\t  segment = pattern.substring(last);\n\t\n\t  // Find any search parameter names and remove them from the last segment\n\t  var i = segment.indexOf('?');\n\t\n\t  if (i >= 0) {\n\t    var search = this.sourceSearch = segment.substring(i);\n\t    segment = segment.substring(0, i);\n\t    this.sourcePath = pattern.substring(0, last + i);\n\t\n\t    if (search.length > 0) {\n\t      last = 0;\n\t      while ((m = searchPlaceholder.exec(search))) {\n\t        p = matchDetails(m, true);\n\t        param = addParameter(p.id, p.type, p.cfg, \"search\");\n\t        last = placeholder.lastIndex;\n\t        // check if ?&\n\t      }\n\t    }\n\t  } else {\n\t    this.sourcePath = pattern;\n\t    this.sourceSearch = '';\n\t  }\n\t\n\t  compiled += quoteRegExp(segment) + (config.strict === false ? '\\/?' : '') + '$';\n\t  segments.push(segment);\n\t\n\t  this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);\n\t  this.prefix = segments[0];\n\t  this.$$paramNames = paramNames;\n\t}\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#concat\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Returns a new matcher for a pattern constructed by appending the path part and adding the\n\t * search parameters of the specified pattern to this pattern. The current pattern is not\n\t * modified. This can be understood as creating a pattern for URLs that are relative to (or\n\t * suffixes of) the current pattern.\n\t *\n\t * @example\n\t * The following two matchers are equivalent:\n\t * <pre>\n\t * new UrlMatcher('/user/{id}?q').concat('/details?date');\n\t * new UrlMatcher('/user/{id}/details?q&date');\n\t * </pre>\n\t *\n\t * @param {string} pattern  The pattern to append.\n\t * @param {Object} config  An object hash of the configuration for the matcher.\n\t * @returns {UrlMatcher}  A matcher for the concatenated pattern.\n\t */\n\tUrlMatcher.prototype.concat = function (pattern, config) {\n\t  // Because order of search parameters is irrelevant, we can add our own search\n\t  // parameters to the end of the new pattern. Parse the new pattern by itself\n\t  // and then join the bits together, but it's much easier to do this on a string level.\n\t  var defaultConfig = {\n\t    caseInsensitive: $$UMFP.caseInsensitive(),\n\t    strict: $$UMFP.strictMode(),\n\t    squash: $$UMFP.defaultSquashPolicy()\n\t  };\n\t  return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);\n\t};\n\t\n\tUrlMatcher.prototype.toString = function () {\n\t  return this.source;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#exec\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Tests the specified path against this matcher, and returns an object containing the captured\n\t * parameter values, or null if the path does not match. The returned object contains the values\n\t * of any search parameters that are mentioned in the pattern, but their value may be null if\n\t * they are not present in `searchParams`. This means that search parameters are always treated\n\t * as optional.\n\t *\n\t * @example\n\t * <pre>\n\t * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n\t *   x: '1', q: 'hello'\n\t * });\n\t * // returns { id: 'bob', q: 'hello', r: null }\n\t * </pre>\n\t *\n\t * @param {string} path  The URL path to match, e.g. `$location.path()`.\n\t * @param {Object} searchParams  URL search parameters, e.g. `$location.search()`.\n\t * @returns {Object}  The captured parameter values.\n\t */\n\tUrlMatcher.prototype.exec = function (path, searchParams) {\n\t  var m = this.regexp.exec(path);\n\t  if (!m) return null;\n\t  searchParams = searchParams || {};\n\t\n\t  var paramNames = this.parameters(), nTotal = paramNames.length,\n\t    nPath = this.segments.length - 1,\n\t    values = {}, i, j, cfg, paramName;\n\t\n\t  if (nPath !== m.length - 1) throw new Error(\"Unbalanced capture group in route '\" + this.source + \"'\");\n\t\n\t  function decodePathArray(string) {\n\t    function reverseString(str) { return str.split(\"\").reverse().join(\"\"); }\n\t    function unquoteDashes(str) { return str.replace(/\\\\-/g, \"-\"); }\n\t\n\t    var split = reverseString(string).split(/-(?!\\\\)/);\n\t    var allReversed = map(split, reverseString);\n\t    return map(allReversed, unquoteDashes).reverse();\n\t  }\n\t\n\t  var param, paramVal;\n\t  for (i = 0; i < nPath; i++) {\n\t    paramName = paramNames[i];\n\t    param = this.params[paramName];\n\t    paramVal = m[i+1];\n\t    // if the param value matches a pre-replace pair, replace the value before decoding.\n\t    for (j = 0; j < param.replace.length; j++) {\n\t      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\n\t    }\n\t    if (paramVal && param.array === true) paramVal = decodePathArray(paramVal);\n\t    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);\n\t    values[paramName] = param.value(paramVal);\n\t  }\n\t  for (/**/; i < nTotal; i++) {\n\t    paramName = paramNames[i];\n\t    values[paramName] = this.params[paramName].value(searchParams[paramName]);\n\t    param = this.params[paramName];\n\t    paramVal = searchParams[paramName];\n\t    for (j = 0; j < param.replace.length; j++) {\n\t      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\n\t    }\n\t    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);\n\t    values[paramName] = param.value(paramVal);\n\t  }\n\t\n\t  return values;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#parameters\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Returns the names of all path and search parameters of this pattern in an unspecified order.\n\t *\n\t * @returns {Array.<string>}  An array of parameter names. Must be treated as read-only. If the\n\t *    pattern has no parameters, an empty array is returned.\n\t */\n\tUrlMatcher.prototype.parameters = function (param) {\n\t  if (!isDefined(param)) return this.$$paramNames;\n\t  return this.params[param] || null;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#validates\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Checks an object hash of parameters to validate their correctness according to the parameter\n\t * types of this `UrlMatcher`.\n\t *\n\t * @param {Object} params The object hash of parameters to validate.\n\t * @returns {boolean} Returns `true` if `params` validates, otherwise `false`.\n\t */\n\tUrlMatcher.prototype.validates = function (params) {\n\t  return this.params.$$validates(params);\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#format\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Creates a URL that matches this pattern by substituting the specified values\n\t * for the path and search parameters. Null values for path parameters are\n\t * treated as empty strings.\n\t *\n\t * @example\n\t * <pre>\n\t * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n\t * // returns '/user/bob?q=yes'\n\t * </pre>\n\t *\n\t * @param {Object} values  the values to substitute for the parameters in this pattern.\n\t * @returns {string}  the formatted URL (path and optionally search part).\n\t */\n\tUrlMatcher.prototype.format = function (values) {\n\t  values = values || {};\n\t  var segments = this.segments, params = this.parameters(), paramset = this.params;\n\t  if (!this.validates(values)) return null;\n\t\n\t  var i, search = false, nPath = segments.length - 1, nTotal = params.length, result = segments[0];\n\t\n\t  function encodeDashes(str) { // Replace dashes with encoded \"\\-\"\n\t    return encodeURIComponent(str).replace(/-/g, function(c) { return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase(); });\n\t  }\n\t\n\t  for (i = 0; i < nTotal; i++) {\n\t    var isPathParam = i < nPath;\n\t    var name = params[i], param = paramset[name], value = param.value(values[name]);\n\t    var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);\n\t    var squash = isDefaultValue ? param.squash : false;\n\t    var encoded = param.type.encode(value);\n\t\n\t    if (isPathParam) {\n\t      var nextSegment = segments[i + 1];\n\t      var isFinalPathParam = i + 1 === nPath;\n\t\n\t      if (squash === false) {\n\t        if (encoded != null) {\n\t          if (isArray(encoded)) {\n\t            result += map(encoded, encodeDashes).join(\"-\");\n\t          } else {\n\t            result += encodeURIComponent(encoded);\n\t          }\n\t        }\n\t        result += nextSegment;\n\t      } else if (squash === true) {\n\t        var capture = result.match(/\\/$/) ? /\\/?(.*)/ : /(.*)/;\n\t        result += nextSegment.match(capture)[1];\n\t      } else if (isString(squash)) {\n\t        result += squash + nextSegment;\n\t      }\n\t\n\t      if (isFinalPathParam && param.squash === true && result.slice(-1) === '/') result = result.slice(0, -1);\n\t    } else {\n\t      if (encoded == null || (isDefaultValue && squash !== false)) continue;\n\t      if (!isArray(encoded)) encoded = [ encoded ];\n\t      if (encoded.length === 0) continue;\n\t      encoded = map(encoded, encodeURIComponent).join('&' + name + '=');\n\t      result += (search ? '&' : '?') + (name + '=' + encoded);\n\t      search = true;\n\t    }\n\t  }\n\t\n\t  return result;\n\t};\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.type:Type\n\t *\n\t * @description\n\t * Implements an interface to define custom parameter types that can be decoded from and encoded to\n\t * string parameters matched in a URL. Used by {@link ui.router.util.type:UrlMatcher `UrlMatcher`}\n\t * objects when matching or formatting URLs, or comparing or validating parameter values.\n\t *\n\t * See {@link ui.router.util.$urlMatcherFactory#methods_type `$urlMatcherFactory#type()`} for more\n\t * information on registering custom types.\n\t *\n\t * @param {Object} config  A configuration object which contains the custom type definition.  The object's\n\t *        properties will override the default methods and/or pattern in `Type`'s public interface.\n\t * @example\n\t * <pre>\n\t * {\n\t *   decode: function(val) { return parseInt(val, 10); },\n\t *   encode: function(val) { return val && val.toString(); },\n\t *   equals: function(a, b) { return this.is(a) && a === b; },\n\t *   is: function(val) { return angular.isNumber(val) isFinite(val) && val % 1 === 0; },\n\t *   pattern: /\\d+/\n\t * }\n\t * </pre>\n\t *\n\t * @property {RegExp} pattern The regular expression pattern used to match values of this type when\n\t *           coming from a substring of a URL.\n\t *\n\t * @returns {Object}  Returns a new `Type` object.\n\t */\n\tfunction Type(config) {\n\t  extend(this, config);\n\t}\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:Type#is\n\t * @methodOf ui.router.util.type:Type\n\t *\n\t * @description\n\t * Detects whether a value is of a particular type. Accepts a native (decoded) value\n\t * and determines whether it matches the current `Type` object.\n\t *\n\t * @param {*} val  The value to check.\n\t * @param {string} key  Optional. If the type check is happening in the context of a specific\n\t *        {@link ui.router.util.type:UrlMatcher `UrlMatcher`} object, this is the name of the\n\t *        parameter in which `val` is stored. Can be used for meta-programming of `Type` objects.\n\t * @returns {Boolean}  Returns `true` if the value matches the type, otherwise `false`.\n\t */\n\tType.prototype.is = function(val, key) {\n\t  return true;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:Type#encode\n\t * @methodOf ui.router.util.type:Type\n\t *\n\t * @description\n\t * Encodes a custom/native type value to a string that can be embedded in a URL. Note that the\n\t * return value does *not* need to be URL-safe (i.e. passed through `encodeURIComponent()`), it\n\t * only needs to be a representation of `val` that has been coerced to a string.\n\t *\n\t * @param {*} val  The value to encode.\n\t * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n\t *        meta-programming of `Type` objects.\n\t * @returns {string}  Returns a string representation of `val` that can be encoded in a URL.\n\t */\n\tType.prototype.encode = function(val, key) {\n\t  return val;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:Type#decode\n\t * @methodOf ui.router.util.type:Type\n\t *\n\t * @description\n\t * Converts a parameter value (from URL string or transition param) to a custom/native value.\n\t *\n\t * @param {string} val  The URL parameter value to decode.\n\t * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n\t *        meta-programming of `Type` objects.\n\t * @returns {*}  Returns a custom representation of the URL parameter value.\n\t */\n\tType.prototype.decode = function(val, key) {\n\t  return val;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:Type#equals\n\t * @methodOf ui.router.util.type:Type\n\t *\n\t * @description\n\t * Determines whether two decoded values are equivalent.\n\t *\n\t * @param {*} a  A value to compare against.\n\t * @param {*} b  A value to compare against.\n\t * @returns {Boolean}  Returns `true` if the values are equivalent/equal, otherwise `false`.\n\t */\n\tType.prototype.equals = function(a, b) {\n\t  return a == b;\n\t};\n\t\n\tType.prototype.$subPattern = function() {\n\t  var sub = this.pattern.toString();\n\t  return sub.substr(1, sub.length - 2);\n\t};\n\t\n\tType.prototype.pattern = /.*/;\n\t\n\tType.prototype.toString = function() { return \"{Type:\" + this.name + \"}\"; };\n\t\n\t/** Given an encoded string, or a decoded object, returns a decoded object */\n\tType.prototype.$normalize = function(val) {\n\t  return this.is(val) ? val : this.decode(val);\n\t};\n\t\n\t/*\n\t * Wraps an existing custom Type as an array of Type, depending on 'mode'.\n\t * e.g.:\n\t * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n\t * - url: \"/path?queryParam=1&queryParam=2\n\t * - $stateParams.queryParam will be [1, 2]\n\t * if `mode` is \"auto\", then\n\t * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n\t * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n\t */\n\tType.prototype.$asArray = function(mode, isSearch) {\n\t  if (!mode) return this;\n\t  if (mode === \"auto\" && !isSearch) throw new Error(\"'auto' array mode is for query parameters only\");\n\t\n\t  function ArrayType(type, mode) {\n\t    function bindTo(type, callbackName) {\n\t      return function() {\n\t        return type[callbackName].apply(type, arguments);\n\t      };\n\t    }\n\t\n\t    // Wrap non-array value as array\n\t    function arrayWrap(val) { return isArray(val) ? val : (isDefined(val) ? [ val ] : []); }\n\t    // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n\t    function arrayUnwrap(val) {\n\t      switch(val.length) {\n\t        case 0: return undefined;\n\t        case 1: return mode === \"auto\" ? val[0] : val;\n\t        default: return val;\n\t      }\n\t    }\n\t    function falsey(val) { return !val; }\n\t\n\t    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n\t    function arrayHandler(callback, allTruthyMode) {\n\t      return function handleArray(val) {\n\t        if (isArray(val) && val.length === 0) return val;\n\t        val = arrayWrap(val);\n\t        var result = map(val, callback);\n\t        if (allTruthyMode === true)\n\t          return filter(result, falsey).length === 0;\n\t        return arrayUnwrap(result);\n\t      };\n\t    }\n\t\n\t    // Wraps type (.equals) functions to operate on each value of an array\n\t    function arrayEqualsHandler(callback) {\n\t      return function handleArray(val1, val2) {\n\t        var left = arrayWrap(val1), right = arrayWrap(val2);\n\t        if (left.length !== right.length) return false;\n\t        for (var i = 0; i < left.length; i++) {\n\t          if (!callback(left[i], right[i])) return false;\n\t        }\n\t        return true;\n\t      };\n\t    }\n\t\n\t    this.encode = arrayHandler(bindTo(type, 'encode'));\n\t    this.decode = arrayHandler(bindTo(type, 'decode'));\n\t    this.is     = arrayHandler(bindTo(type, 'is'), true);\n\t    this.equals = arrayEqualsHandler(bindTo(type, 'equals'));\n\t    this.pattern = type.pattern;\n\t    this.$normalize = arrayHandler(bindTo(type, '$normalize'));\n\t    this.name = type.name;\n\t    this.$arrayMode = mode;\n\t  }\n\t\n\t  return new ArrayType(this, mode);\n\t};\n\t\n\t\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.$urlMatcherFactory\n\t *\n\t * @description\n\t * Factory for {@link ui.router.util.type:UrlMatcher `UrlMatcher`} instances. The factory\n\t * is also available to providers under the name `$urlMatcherFactoryProvider`.\n\t */\n\tfunction $UrlMatcherFactory() {\n\t  $$UMFP = this;\n\t\n\t  var isCaseInsensitive = false, isStrictMode = true, defaultSquashPolicy = false;\n\t\n\t  // Use tildes to pre-encode slashes.\n\t  // If the slashes are simply URLEncoded, the browser can choose to pre-decode them,\n\t  // and bidirectional encoding/decoding fails.\n\t  // Tilde was chosen because it's not a RFC 3986 section 2.2 Reserved Character\n\t  function valToString(val) { return val != null ? val.toString().replace(/~/g, \"~~\").replace(/\\//g, \"~2F\") : val; }\n\t  function valFromString(val) { return val != null ? val.toString().replace(/~2F/g, \"/\").replace(/~~/g, \"~\") : val; }\n\t\n\t  var $types = {}, enqueue = true, typeQueue = [], injector, defaultTypes = {\n\t    \"string\": {\n\t      encode: valToString,\n\t      decode: valFromString,\n\t      // TODO: in 1.0, make string .is() return false if value is undefined/null by default.\n\t      // In 0.2.x, string params are optional by default for backwards compat\n\t      is: function(val) { return val == null || !isDefined(val) || typeof val === \"string\"; },\n\t      pattern: /[^/]*/\n\t    },\n\t    \"int\": {\n\t      encode: valToString,\n\t      decode: function(val) { return parseInt(val, 10); },\n\t      is: function(val) { return isDefined(val) && this.decode(val.toString()) === val; },\n\t      pattern: /\\d+/\n\t    },\n\t    \"bool\": {\n\t      encode: function(val) { return val ? 1 : 0; },\n\t      decode: function(val) { return parseInt(val, 10) !== 0; },\n\t      is: function(val) { return val === true || val === false; },\n\t      pattern: /0|1/\n\t    },\n\t    \"date\": {\n\t      encode: function (val) {\n\t        if (!this.is(val))\n\t          return undefined;\n\t        return [ val.getFullYear(),\n\t          ('0' + (val.getMonth() + 1)).slice(-2),\n\t          ('0' + val.getDate()).slice(-2)\n\t        ].join(\"-\");\n\t      },\n\t      decode: function (val) {\n\t        if (this.is(val)) return val;\n\t        var match = this.capture.exec(val);\n\t        return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\n\t      },\n\t      is: function(val) { return val instanceof Date && !isNaN(val.valueOf()); },\n\t      equals: function (a, b) { return this.is(a) && this.is(b) && a.toISOString() === b.toISOString(); },\n\t      pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\n\t      capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/\n\t    },\n\t    \"json\": {\n\t      encode: angular.toJson,\n\t      decode: angular.fromJson,\n\t      is: angular.isObject,\n\t      equals: angular.equals,\n\t      pattern: /[^/]*/\n\t    },\n\t    \"any\": { // does not encode/decode\n\t      encode: angular.identity,\n\t      decode: angular.identity,\n\t      equals: angular.equals,\n\t      pattern: /.*/\n\t    }\n\t  };\n\t\n\t  function getDefaultConfig() {\n\t    return {\n\t      strict: isStrictMode,\n\t      caseInsensitive: isCaseInsensitive\n\t    };\n\t  }\n\t\n\t  function isInjectable(value) {\n\t    return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));\n\t  }\n\t\n\t  /**\n\t   * [Internal] Get the default value of a parameter, which may be an injectable function.\n\t   */\n\t  $UrlMatcherFactory.$$getDefaultValue = function(config) {\n\t    if (!isInjectable(config.value)) return config.value;\n\t    if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n\t    return injector.invoke(config.value);\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#caseInsensitive\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Defines whether URL matching should be case sensitive (the default behavior), or not.\n\t   *\n\t   * @param {boolean} value `false` to match URL in a case sensitive manner; otherwise `true`;\n\t   * @returns {boolean} the current value of caseInsensitive\n\t   */\n\t  this.caseInsensitive = function(value) {\n\t    if (isDefined(value))\n\t      isCaseInsensitive = value;\n\t    return isCaseInsensitive;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#strictMode\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Defines whether URLs should match trailing slashes, or not (the default behavior).\n\t   *\n\t   * @param {boolean=} value `false` to match trailing slashes in URLs, otherwise `true`.\n\t   * @returns {boolean} the current value of strictMode\n\t   */\n\t  this.strictMode = function(value) {\n\t    if (isDefined(value))\n\t      isStrictMode = value;\n\t    return isStrictMode;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#defaultSquashPolicy\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Sets the default behavior when generating or matching URLs with default parameter values.\n\t   *\n\t   * @param {string} value A string that defines the default parameter URL squashing behavior.\n\t   *    `nosquash`: When generating an href with a default parameter value, do not squash the parameter value from the URL\n\t   *    `slash`: When generating an href with a default parameter value, squash (remove) the parameter value, and, if the\n\t   *             parameter is surrounded by slashes, squash (remove) one slash from the URL\n\t   *    any other string, e.g. \"~\": When generating an href with a default parameter value, squash (remove)\n\t   *             the parameter value from the URL and replace it with this string.\n\t   */\n\t  this.defaultSquashPolicy = function(value) {\n\t    if (!isDefined(value)) return defaultSquashPolicy;\n\t    if (value !== true && value !== false && !isString(value))\n\t      throw new Error(\"Invalid squash policy: \" + value + \". Valid policies: false, true, arbitrary-string\");\n\t    defaultSquashPolicy = value;\n\t    return value;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#compile\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Creates a {@link ui.router.util.type:UrlMatcher `UrlMatcher`} for the specified pattern.\n\t   *\n\t   * @param {string} pattern  The URL pattern.\n\t   * @param {Object} config  The config object hash.\n\t   * @returns {UrlMatcher}  The UrlMatcher.\n\t   */\n\t  this.compile = function (pattern, config) {\n\t    return new UrlMatcher(pattern, extend(getDefaultConfig(), config));\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#isMatcher\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Returns true if the specified object is a `UrlMatcher`, or false otherwise.\n\t   *\n\t   * @param {Object} object  The object to perform the type check against.\n\t   * @returns {Boolean}  Returns `true` if the object matches the `UrlMatcher` interface, by\n\t   *          implementing all the same methods.\n\t   */\n\t  this.isMatcher = function (o) {\n\t    if (!isObject(o)) return false;\n\t    var result = true;\n\t\n\t    forEach(UrlMatcher.prototype, function(val, name) {\n\t      if (isFunction(val)) {\n\t        result = result && (isDefined(o[name]) && isFunction(o[name]));\n\t      }\n\t    });\n\t    return result;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#type\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Registers a custom {@link ui.router.util.type:Type `Type`} object that can be used to\n\t   * generate URLs with typed parameters.\n\t   *\n\t   * @param {string} name  The type name.\n\t   * @param {Object|Function} definition   The type definition. See\n\t   *        {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n\t   * @param {Object|Function} definitionFn (optional) A function that is injected before the app\n\t   *        runtime starts.  The result of this function is merged into the existing `definition`.\n\t   *        See {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n\t   *\n\t   * @returns {Object}  Returns `$urlMatcherFactoryProvider`.\n\t   *\n\t   * @example\n\t   * This is a simple example of a custom type that encodes and decodes items from an\n\t   * array, using the array index as the URL-encoded value:\n\t   *\n\t   * <pre>\n\t   * var list = ['John', 'Paul', 'George', 'Ringo'];\n\t   *\n\t   * $urlMatcherFactoryProvider.type('listItem', {\n\t   *   encode: function(item) {\n\t   *     // Represent the list item in the URL using its corresponding index\n\t   *     return list.indexOf(item);\n\t   *   },\n\t   *   decode: function(item) {\n\t   *     // Look up the list item by index\n\t   *     return list[parseInt(item, 10)];\n\t   *   },\n\t   *   is: function(item) {\n\t   *     // Ensure the item is valid by checking to see that it appears\n\t   *     // in the list\n\t   *     return list.indexOf(item) > -1;\n\t   *   }\n\t   * });\n\t   *\n\t   * $stateProvider.state('list', {\n\t   *   url: \"/list/{item:listItem}\",\n\t   *   controller: function($scope, $stateParams) {\n\t   *     console.log($stateParams.item);\n\t   *   }\n\t   * });\n\t   *\n\t   * // ...\n\t   *\n\t   * // Changes URL to '/list/3', logs \"Ringo\" to the console\n\t   * $state.go('list', { item: \"Ringo\" });\n\t   * </pre>\n\t   *\n\t   * This is a more complex example of a type that relies on dependency injection to\n\t   * interact with services, and uses the parameter name from the URL to infer how to\n\t   * handle encoding and decoding parameter values:\n\t   *\n\t   * <pre>\n\t   * // Defines a custom type that gets a value from a service,\n\t   * // where each service gets different types of values from\n\t   * // a backend API:\n\t   * $urlMatcherFactoryProvider.type('dbObject', {}, function(Users, Posts) {\n\t   *\n\t   *   // Matches up services to URL parameter names\n\t   *   var services = {\n\t   *     user: Users,\n\t   *     post: Posts\n\t   *   };\n\t   *\n\t   *   return {\n\t   *     encode: function(object) {\n\t   *       // Represent the object in the URL using its unique ID\n\t   *       return object.id;\n\t   *     },\n\t   *     decode: function(value, key) {\n\t   *       // Look up the object by ID, using the parameter\n\t   *       // name (key) to call the correct service\n\t   *       return services[key].findById(value);\n\t   *     },\n\t   *     is: function(object, key) {\n\t   *       // Check that object is a valid dbObject\n\t   *       return angular.isObject(object) && object.id && services[key];\n\t   *     }\n\t   *     equals: function(a, b) {\n\t   *       // Check the equality of decoded objects by comparing\n\t   *       // their unique IDs\n\t   *       return a.id === b.id;\n\t   *     }\n\t   *   };\n\t   * });\n\t   *\n\t   * // In a config() block, you can then attach URLs with\n\t   * // type-annotated parameters:\n\t   * $stateProvider.state('users', {\n\t   *   url: \"/users\",\n\t   *   // ...\n\t   * }).state('users.item', {\n\t   *   url: \"/{user:dbObject}\",\n\t   *   controller: function($scope, $stateParams) {\n\t   *     // $stateParams.user will now be an object returned from\n\t   *     // the Users service\n\t   *   },\n\t   *   // ...\n\t   * });\n\t   * </pre>\n\t   */\n\t  this.type = function (name, definition, definitionFn) {\n\t    if (!isDefined(definition)) return $types[name];\n\t    if ($types.hasOwnProperty(name)) throw new Error(\"A type named '\" + name + \"' has already been defined.\");\n\t\n\t    $types[name] = new Type(extend({ name: name }, definition));\n\t    if (definitionFn) {\n\t      typeQueue.push({ name: name, def: definitionFn });\n\t      if (!enqueue) flushTypeQueue();\n\t    }\n\t    return this;\n\t  };\n\t\n\t  // `flushTypeQueue()` waits until `$urlMatcherFactory` is injected before invoking the queued `definitionFn`s\n\t  function flushTypeQueue() {\n\t    while(typeQueue.length) {\n\t      var type = typeQueue.shift();\n\t      if (type.pattern) throw new Error(\"You cannot override a type's .pattern at runtime.\");\n\t      angular.extend($types[type.name], injector.invoke(type.def));\n\t    }\n\t  }\n\t\n\t  // Register default types. Store them in the prototype of $types.\n\t  forEach(defaultTypes, function(type, name) { $types[name] = new Type(extend({name: name}, type)); });\n\t  $types = inherit($types, {});\n\t\n\t  /* No need to document $get, since it returns this */\n\t  this.$get = ['$injector', function ($injector) {\n\t    injector = $injector;\n\t    enqueue = false;\n\t    flushTypeQueue();\n\t\n\t    forEach(defaultTypes, function(type, name) {\n\t      if (!$types[name]) $types[name] = new Type(type);\n\t    });\n\t    return this;\n\t  }];\n\t\n\t  this.Param = function Param(id, type, config, location) {\n\t    var self = this;\n\t    config = unwrapShorthand(config);\n\t    type = getType(config, type, location);\n\t    var arrayMode = getArrayMode();\n\t    type = arrayMode ? type.$asArray(arrayMode, location === \"search\") : type;\n\t    if (type.name === \"string\" && !arrayMode && location === \"path\" && config.value === undefined)\n\t      config.value = \"\"; // for 0.2.x; in 0.3.0+ do not automatically default to \"\"\n\t    var isOptional = config.value !== undefined;\n\t    var squash = getSquashPolicy(config, isOptional);\n\t    var replace = getReplace(config, arrayMode, isOptional, squash);\n\t\n\t    function unwrapShorthand(config) {\n\t      var keys = isObject(config) ? objectKeys(config) : [];\n\t      var isShorthand = indexOf(keys, \"value\") === -1 && indexOf(keys, \"type\") === -1 &&\n\t                        indexOf(keys, \"squash\") === -1 && indexOf(keys, \"array\") === -1;\n\t      if (isShorthand) config = { value: config };\n\t      config.$$fn = isInjectable(config.value) ? config.value : function () { return config.value; };\n\t      return config;\n\t    }\n\t\n\t    function getType(config, urlType, location) {\n\t      if (config.type && urlType) throw new Error(\"Param '\"+id+\"' has two type configurations.\");\n\t      if (urlType) return urlType;\n\t      if (!config.type) return (location === \"config\" ? $types.any : $types.string);\n\t\n\t      if (angular.isString(config.type))\n\t        return $types[config.type];\n\t      if (config.type instanceof Type)\n\t        return config.type;\n\t      return new Type(config.type);\n\t    }\n\t\n\t    // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n\t    function getArrayMode() {\n\t      var arrayDefaults = { array: (location === \"search\" ? \"auto\" : false) };\n\t      var arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n\t      return extend(arrayDefaults, arrayParamNomenclature, config).array;\n\t    }\n\t\n\t    /**\n\t     * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n\t     */\n\t    function getSquashPolicy(config, isOptional) {\n\t      var squash = config.squash;\n\t      if (!isOptional || squash === false) return false;\n\t      if (!isDefined(squash) || squash == null) return defaultSquashPolicy;\n\t      if (squash === true || isString(squash)) return squash;\n\t      throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n\t    }\n\t\n\t    function getReplace(config, arrayMode, isOptional, squash) {\n\t      var replace, configuredKeys, defaultPolicy = [\n\t        { from: \"\",   to: (isOptional || arrayMode ? undefined : \"\") },\n\t        { from: null, to: (isOptional || arrayMode ? undefined : \"\") }\n\t      ];\n\t      replace = isArray(config.replace) ? config.replace : [];\n\t      if (isString(squash))\n\t        replace.push({ from: squash, to: undefined });\n\t      configuredKeys = map(replace, function(item) { return item.from; } );\n\t      return filter(defaultPolicy, function(item) { return indexOf(configuredKeys, item.from) === -1; }).concat(replace);\n\t    }\n\t\n\t    /**\n\t     * [Internal] Get the default value of a parameter, which may be an injectable function.\n\t     */\n\t    function $$getDefaultValue() {\n\t      if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n\t      var defaultValue = injector.invoke(config.$$fn);\n\t      if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue))\n\t        throw new Error(\"Default value (\" + defaultValue + \") for parameter '\" + self.id + \"' is not an instance of Type (\" + self.type.name + \")\");\n\t      return defaultValue;\n\t    }\n\t\n\t    /**\n\t     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n\t     * default value, which may be the result of an injectable function.\n\t     */\n\t    function $value(value) {\n\t      function hasReplaceVal(val) { return function(obj) { return obj.from === val; }; }\n\t      function $replace(value) {\n\t        var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) { return obj.to; });\n\t        return replacement.length ? replacement[0] : value;\n\t      }\n\t      value = $replace(value);\n\t      return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);\n\t    }\n\t\n\t    function toString() { return \"{Param:\" + id + \" \" + type + \" squash: '\" + squash + \"' optional: \" + isOptional + \"}\"; }\n\t\n\t    extend(this, {\n\t      id: id,\n\t      type: type,\n\t      location: location,\n\t      array: arrayMode,\n\t      squash: squash,\n\t      replace: replace,\n\t      isOptional: isOptional,\n\t      value: $value,\n\t      dynamic: undefined,\n\t      config: config,\n\t      toString: toString\n\t    });\n\t  };\n\t\n\t  function ParamSet(params) {\n\t    extend(this, params || {});\n\t  }\n\t\n\t  ParamSet.prototype = {\n\t    $$new: function() {\n\t      return inherit(this, extend(new ParamSet(), { $$parent: this}));\n\t    },\n\t    $$keys: function () {\n\t      var keys = [], chain = [], parent = this,\n\t        ignore = objectKeys(ParamSet.prototype);\n\t      while (parent) { chain.push(parent); parent = parent.$$parent; }\n\t      chain.reverse();\n\t      forEach(chain, function(paramset) {\n\t        forEach(objectKeys(paramset), function(key) {\n\t            if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1) keys.push(key);\n\t        });\n\t      });\n\t      return keys;\n\t    },\n\t    $$values: function(paramValues) {\n\t      var values = {}, self = this;\n\t      forEach(self.$$keys(), function(key) {\n\t        values[key] = self[key].value(paramValues && paramValues[key]);\n\t      });\n\t      return values;\n\t    },\n\t    $$equals: function(paramValues1, paramValues2) {\n\t      var equal = true, self = this;\n\t      forEach(self.$$keys(), function(key) {\n\t        var left = paramValues1 && paramValues1[key], right = paramValues2 && paramValues2[key];\n\t        if (!self[key].type.equals(left, right)) equal = false;\n\t      });\n\t      return equal;\n\t    },\n\t    $$validates: function $$validate(paramValues) {\n\t      var keys = this.$$keys(), i, param, rawVal, normalized, encoded;\n\t      for (i = 0; i < keys.length; i++) {\n\t        param = this[keys[i]];\n\t        rawVal = paramValues[keys[i]];\n\t        if ((rawVal === undefined || rawVal === null) && param.isOptional)\n\t          break; // There was no parameter value, but the param is optional\n\t        normalized = param.type.$normalize(rawVal);\n\t        if (!param.type.is(normalized))\n\t          return false; // The value was not of the correct Type, and could not be decoded to the correct Type\n\t        encoded = param.type.encode(normalized);\n\t        if (angular.isString(encoded) && !param.type.pattern.exec(encoded))\n\t          return false; // The value was of the correct type, but when encoded, did not match the Type's regexp\n\t      }\n\t      return true;\n\t    },\n\t    $$parent: undefined\n\t  };\n\t\n\t  this.ParamSet = ParamSet;\n\t}\n\t\n\t// Register as a provider so it's available to other providers\n\tangular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);\n\tangular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) { }]);\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.router.$urlRouterProvider\n\t *\n\t * @requires ui.router.util.$urlMatcherFactoryProvider\n\t * @requires $locationProvider\n\t *\n\t * @description\n\t * `$urlRouterProvider` has the responsibility of watching `$location`. \n\t * When `$location` changes it runs through a list of rules one by one until a \n\t * match is found. `$urlRouterProvider` is used behind the scenes anytime you specify \n\t * a url in a state configuration. All urls are compiled into a UrlMatcher object.\n\t *\n\t * There are several methods on `$urlRouterProvider` that make it useful to use directly\n\t * in your module config.\n\t */\n\t$UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];\n\tfunction $UrlRouterProvider(   $locationProvider,   $urlMatcherFactory) {\n\t  var rules = [], otherwise = null, interceptDeferred = false, listener;\n\t\n\t  // Returns a string that is a prefix of all strings matching the RegExp\n\t  function regExpPrefix(re) {\n\t    var prefix = /^\\^((?:\\\\[^a-zA-Z0-9]|[^\\\\\\[\\]\\^$*+?.()|{}]+)*)/.exec(re.source);\n\t    return (prefix != null) ? prefix[1].replace(/\\\\(.)/g, \"$1\") : '';\n\t  }\n\t\n\t  // Interpolates matched values into a String.replace()-style pattern\n\t  function interpolate(pattern, match) {\n\t    return pattern.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n\t      return match[what === '$' ? 0 : Number(what)];\n\t    });\n\t  }\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.router.$urlRouterProvider#rule\n\t   * @methodOf ui.router.router.$urlRouterProvider\n\t   *\n\t   * @description\n\t   * Defines rules that are used by `$urlRouterProvider` to find matches for\n\t   * specific URLs.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * var app = angular.module('app', ['ui.router.router']);\n\t   *\n\t   * app.config(function ($urlRouterProvider) {\n\t   *   // Here's an example of how you might allow case insensitive urls\n\t   *   $urlRouterProvider.rule(function ($injector, $location) {\n\t   *     var path = $location.path(),\n\t   *         normalized = path.toLowerCase();\n\t   *\n\t   *     if (path !== normalized) {\n\t   *       return normalized;\n\t   *     }\n\t   *   });\n\t   * });\n\t   * </pre>\n\t   *\n\t   * @param {function} rule Handler function that takes `$injector` and `$location`\n\t   * services as arguments. You can use them to return a valid path as a string.\n\t   *\n\t   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n\t   */\n\t  this.rule = function (rule) {\n\t    if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n\t    rules.push(rule);\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.router.$urlRouterProvider#otherwise\n\t   * @methodOf ui.router.router.$urlRouterProvider\n\t   *\n\t   * @description\n\t   * Defines a path that is used when an invalid route is requested.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * var app = angular.module('app', ['ui.router.router']);\n\t   *\n\t   * app.config(function ($urlRouterProvider) {\n\t   *   // if the path doesn't match any of the urls you configured\n\t   *   // otherwise will take care of routing the user to the\n\t   *   // specified url\n\t   *   $urlRouterProvider.otherwise('/index');\n\t   *\n\t   *   // Example of using function rule as param\n\t   *   $urlRouterProvider.otherwise(function ($injector, $location) {\n\t   *     return '/a/valid/url';\n\t   *   });\n\t   * });\n\t   * </pre>\n\t   *\n\t   * @param {string|function} rule The url path you want to redirect to or a function \n\t   * rule that returns the url path. The function version is passed two params: \n\t   * `$injector` and `$location` services, and must return a url string.\n\t   *\n\t   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n\t   */\n\t  this.otherwise = function (rule) {\n\t    if (isString(rule)) {\n\t      var redirect = rule;\n\t      rule = function () { return redirect; };\n\t    }\n\t    else if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n\t    otherwise = rule;\n\t    return this;\n\t  };\n\t\n\t\n\t  function handleIfMatch($injector, handler, match) {\n\t    if (!match) return false;\n\t    var result = $injector.invoke(handler, handler, { $match: match });\n\t    return isDefined(result) ? result : true;\n\t  }\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.router.$urlRouterProvider#when\n\t   * @methodOf ui.router.router.$urlRouterProvider\n\t   *\n\t   * @description\n\t   * Registers a handler for a given url matching. \n\t   * \n\t   * If the handler is a string, it is\n\t   * treated as a redirect, and is interpolated according to the syntax of match\n\t   * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).\n\t   *\n\t   * If the handler is a function, it is injectable. It gets invoked if `$location`\n\t   * matches. You have the option of inject the match object as `$match`.\n\t   *\n\t   * The handler can return\n\t   *\n\t   * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`\n\t   *   will continue trying to find another one that matches.\n\t   * - **string** which is treated as a redirect and passed to `$location.url()`\n\t   * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * var app = angular.module('app', ['ui.router.router']);\n\t   *\n\t   * app.config(function ($urlRouterProvider) {\n\t   *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {\n\t   *     if ($state.$current.navigable !== state ||\n\t   *         !equalForKeys($match, $stateParams) {\n\t   *      $state.transitionTo(state, $match, false);\n\t   *     }\n\t   *   });\n\t   * });\n\t   * </pre>\n\t   *\n\t   * @param {string|object} what The incoming path that you want to redirect.\n\t   * @param {string|function} handler The path you want to redirect your user to.\n\t   */\n\t  this.when = function (what, handler) {\n\t    var redirect, handlerIsString = isString(handler);\n\t    if (isString(what)) what = $urlMatcherFactory.compile(what);\n\t\n\t    if (!handlerIsString && !isFunction(handler) && !isArray(handler))\n\t      throw new Error(\"invalid 'handler' in when()\");\n\t\n\t    var strategies = {\n\t      matcher: function (what, handler) {\n\t        if (handlerIsString) {\n\t          redirect = $urlMatcherFactory.compile(handler);\n\t          handler = ['$match', function ($match) { return redirect.format($match); }];\n\t        }\n\t        return extend(function ($injector, $location) {\n\t          return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));\n\t        }, {\n\t          prefix: isString(what.prefix) ? what.prefix : ''\n\t        });\n\t      },\n\t      regex: function (what, handler) {\n\t        if (what.global || what.sticky) throw new Error(\"when() RegExp must not be global or sticky\");\n\t\n\t        if (handlerIsString) {\n\t          redirect = handler;\n\t          handler = ['$match', function ($match) { return interpolate(redirect, $match); }];\n\t        }\n\t        return extend(function ($injector, $location) {\n\t          return handleIfMatch($injector, handler, what.exec($location.path()));\n\t        }, {\n\t          prefix: regExpPrefix(what)\n\t        });\n\t      }\n\t    };\n\t\n\t    var check = { matcher: $urlMatcherFactory.isMatcher(what), regex: what instanceof RegExp };\n\t\n\t    for (var n in check) {\n\t      if (check[n]) return this.rule(strategies[n](what, handler));\n\t    }\n\t\n\t    throw new Error(\"invalid 'what' in when()\");\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.router.$urlRouterProvider#deferIntercept\n\t   * @methodOf ui.router.router.$urlRouterProvider\n\t   *\n\t   * @description\n\t   * Disables (or enables) deferring location change interception.\n\t   *\n\t   * If you wish to customize the behavior of syncing the URL (for example, if you wish to\n\t   * defer a transition but maintain the current URL), call this method at configuration time.\n\t   * Then, at run time, call `$urlRouter.listen()` after you have configured your own\n\t   * `$locationChangeSuccess` event handler.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * var app = angular.module('app', ['ui.router.router']);\n\t   *\n\t   * app.config(function ($urlRouterProvider) {\n\t   *\n\t   *   // Prevent $urlRouter from automatically intercepting URL changes;\n\t   *   // this allows you to configure custom behavior in between\n\t   *   // location changes and route synchronization:\n\t   *   $urlRouterProvider.deferIntercept();\n\t   *\n\t   * }).run(function ($rootScope, $urlRouter, UserService) {\n\t   *\n\t   *   $rootScope.$on('$locationChangeSuccess', function(e) {\n\t   *     // UserService is an example service for managing user state\n\t   *     if (UserService.isLoggedIn()) return;\n\t   *\n\t   *     // Prevent $urlRouter's default handler from firing\n\t   *     e.preventDefault();\n\t   *\n\t   *     UserService.handleLogin().then(function() {\n\t   *       // Once the user has logged in, sync the current URL\n\t   *       // to the router:\n\t   *       $urlRouter.sync();\n\t   *     });\n\t   *   });\n\t   *\n\t   *   // Configures $urlRouter's listener *after* your custom listener\n\t   *   $urlRouter.listen();\n\t   * });\n\t   * </pre>\n\t   *\n\t   * @param {boolean} defer Indicates whether to defer location change interception. Passing\n\t            no parameter is equivalent to `true`.\n\t   */\n\t  this.deferIntercept = function (defer) {\n\t    if (defer === undefined) defer = true;\n\t    interceptDeferred = defer;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.router.$urlRouter\n\t   *\n\t   * @requires $location\n\t   * @requires $rootScope\n\t   * @requires $injector\n\t   * @requires $browser\n\t   *\n\t   * @description\n\t   *\n\t   */\n\t  this.$get = $get;\n\t  $get.$inject = ['$location', '$rootScope', '$injector', '$browser', '$sniffer'];\n\t  function $get(   $location,   $rootScope,   $injector,   $browser,   $sniffer) {\n\t\n\t    var baseHref = $browser.baseHref(), location = $location.url(), lastPushedUrl;\n\t\n\t    function appendBasePath(url, isHtml5, absolute) {\n\t      if (baseHref === '/') return url;\n\t      if (isHtml5) return baseHref.slice(0, -1) + url;\n\t      if (absolute) return baseHref.slice(1) + url;\n\t      return url;\n\t    }\n\t\n\t    // TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree\n\t    function update(evt) {\n\t      if (evt && evt.defaultPrevented) return;\n\t      var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;\n\t      lastPushedUrl = undefined;\n\t      // TODO: Re-implement this in 1.0 for https://github.com/angular-ui/ui-router/issues/1573\n\t      //if (ignoreUpdate) return true;\n\t\n\t      function check(rule) {\n\t        var handled = rule($injector, $location);\n\t\n\t        if (!handled) return false;\n\t        if (isString(handled)) $location.replace().url(handled);\n\t        return true;\n\t      }\n\t      var n = rules.length, i;\n\t\n\t      for (i = 0; i < n; i++) {\n\t        if (check(rules[i])) return;\n\t      }\n\t      // always check otherwise last to allow dynamic updates to the set of rules\n\t      if (otherwise) check(otherwise);\n\t    }\n\t\n\t    function listen() {\n\t      listener = listener || $rootScope.$on('$locationChangeSuccess', update);\n\t      return listener;\n\t    }\n\t\n\t    if (!interceptDeferred) listen();\n\t\n\t    return {\n\t      /**\n\t       * @ngdoc function\n\t       * @name ui.router.router.$urlRouter#sync\n\t       * @methodOf ui.router.router.$urlRouter\n\t       *\n\t       * @description\n\t       * Triggers an update; the same update that happens when the address bar url changes, aka `$locationChangeSuccess`.\n\t       * This method is useful when you need to use `preventDefault()` on the `$locationChangeSuccess` event,\n\t       * perform some custom logic (route protection, auth, config, redirection, etc) and then finally proceed\n\t       * with the transition by calling `$urlRouter.sync()`.\n\t       *\n\t       * @example\n\t       * <pre>\n\t       * angular.module('app', ['ui.router'])\n\t       *   .run(function($rootScope, $urlRouter) {\n\t       *     $rootScope.$on('$locationChangeSuccess', function(evt) {\n\t       *       // Halt state change from even starting\n\t       *       evt.preventDefault();\n\t       *       // Perform custom logic\n\t       *       var meetsRequirement = ...\n\t       *       // Continue with the update and state transition if logic allows\n\t       *       if (meetsRequirement) $urlRouter.sync();\n\t       *     });\n\t       * });\n\t       * </pre>\n\t       */\n\t      sync: function() {\n\t        update();\n\t      },\n\t\n\t      listen: function() {\n\t        return listen();\n\t      },\n\t\n\t      update: function(read) {\n\t        if (read) {\n\t          location = $location.url();\n\t          return;\n\t        }\n\t        if ($location.url() === location) return;\n\t\n\t        $location.url(location);\n\t        $location.replace();\n\t      },\n\t\n\t      push: function(urlMatcher, params, options) {\n\t         var url = urlMatcher.format(params || {});\n\t\n\t        // Handle the special hash param, if needed\n\t        if (url !== null && params && params['#']) {\n\t            url += '#' + params['#'];\n\t        }\n\t\n\t        $location.url(url);\n\t        lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;\n\t        if (options && options.replace) $location.replace();\n\t      },\n\t\n\t      /**\n\t       * @ngdoc function\n\t       * @name ui.router.router.$urlRouter#href\n\t       * @methodOf ui.router.router.$urlRouter\n\t       *\n\t       * @description\n\t       * A URL generation method that returns the compiled URL for a given\n\t       * {@link ui.router.util.type:UrlMatcher `UrlMatcher`}, populated with the provided parameters.\n\t       *\n\t       * @example\n\t       * <pre>\n\t       * $bob = $urlRouter.href(new UrlMatcher(\"/about/:person\"), {\n\t       *   person: \"bob\"\n\t       * });\n\t       * // $bob == \"/about/bob\";\n\t       * </pre>\n\t       *\n\t       * @param {UrlMatcher} urlMatcher The `UrlMatcher` object which is used as the template of the URL to generate.\n\t       * @param {object=} params An object of parameter values to fill the matcher's required parameters.\n\t       * @param {object=} options Options object. The options are:\n\t       *\n\t       * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n\t       *\n\t       * @returns {string} Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n\t       */\n\t      href: function(urlMatcher, params, options) {\n\t        if (!urlMatcher.validates(params)) return null;\n\t\n\t        var isHtml5 = $locationProvider.html5Mode();\n\t        if (angular.isObject(isHtml5)) {\n\t          isHtml5 = isHtml5.enabled;\n\t        }\n\t\n\t        isHtml5 = isHtml5 && $sniffer.history;\n\t        \n\t        var url = urlMatcher.format(params);\n\t        options = options || {};\n\t\n\t        if (!isHtml5 && url !== null) {\n\t          url = \"#\" + $locationProvider.hashPrefix() + url;\n\t        }\n\t\n\t        // Handle special hash param, if needed\n\t        if (url !== null && params && params['#']) {\n\t          url += '#' + params['#'];\n\t        }\n\t\n\t        url = appendBasePath(url, isHtml5, options.absolute);\n\t\n\t        if (!options.absolute || !url) {\n\t          return url;\n\t        }\n\t\n\t        var slash = (!isHtml5 && url ? '/' : ''), port = $location.port();\n\t        port = (port === 80 || port === 443 ? '' : ':' + port);\n\t\n\t        return [$location.protocol(), '://', $location.host(), port, slash, url].join('');\n\t      }\n\t    };\n\t  }\n\t}\n\t\n\tangular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.state.$stateProvider\n\t *\n\t * @requires ui.router.router.$urlRouterProvider\n\t * @requires ui.router.util.$urlMatcherFactoryProvider\n\t *\n\t * @description\n\t * The new `$stateProvider` works similar to Angular's v1 router, but it focuses purely\n\t * on state.\n\t *\n\t * A state corresponds to a \"place\" in the application in terms of the overall UI and\n\t * navigation. A state describes (via the controller / template / view properties) what\n\t * the UI looks like and does at that place.\n\t *\n\t * States often have things in common, and the primary way of factoring out these\n\t * commonalities in this model is via the state hierarchy, i.e. parent/child states aka\n\t * nested states.\n\t *\n\t * The `$stateProvider` provides interfaces to declare these states for your app.\n\t */\n\t$StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];\n\tfunction $StateProvider(   $urlRouterProvider,   $urlMatcherFactory) {\n\t\n\t  var root, states = {}, $state, queue = {}, abstractKey = 'abstract';\n\t\n\t  // Builds state properties from definition passed to registerState()\n\t  var stateBuilder = {\n\t\n\t    // Derive parent state from a hierarchical name only if 'parent' is not explicitly defined.\n\t    // state.children = [];\n\t    // if (parent) parent.children.push(state);\n\t    parent: function(state) {\n\t      if (isDefined(state.parent) && state.parent) return findState(state.parent);\n\t      // regex matches any valid composite state name\n\t      // would match \"contact.list\" but not \"contacts\"\n\t      var compositeName = /^(.+)\\.[^.]+$/.exec(state.name);\n\t      return compositeName ? findState(compositeName[1]) : root;\n\t    },\n\t\n\t    // inherit 'data' from parent and override by own values (if any)\n\t    data: function(state) {\n\t      if (state.parent && state.parent.data) {\n\t        state.data = state.self.data = inherit(state.parent.data, state.data);\n\t      }\n\t      return state.data;\n\t    },\n\t\n\t    // Build a URLMatcher if necessary, either via a relative or absolute URL\n\t    url: function(state) {\n\t      var url = state.url, config = { params: state.params || {} };\n\t\n\t      if (isString(url)) {\n\t        if (url.charAt(0) == '^') return $urlMatcherFactory.compile(url.substring(1), config);\n\t        return (state.parent.navigable || root).url.concat(url, config);\n\t      }\n\t\n\t      if (!url || $urlMatcherFactory.isMatcher(url)) return url;\n\t      throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n\t    },\n\t\n\t    // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n\t    navigable: function(state) {\n\t      return state.url ? state : (state.parent ? state.parent.navigable : null);\n\t    },\n\t\n\t    // Own parameters for this state. state.url.params is already built at this point. Create and add non-url params\n\t    ownParams: function(state) {\n\t      var params = state.url && state.url.params || new $$UMFP.ParamSet();\n\t      forEach(state.params || {}, function(config, id) {\n\t        if (!params[id]) params[id] = new $$UMFP.Param(id, null, config, \"config\");\n\t      });\n\t      return params;\n\t    },\n\t\n\t    // Derive parameters for this state and ensure they're a super-set of parent's parameters\n\t    params: function(state) {\n\t      var ownParams = pick(state.ownParams, state.ownParams.$$keys());\n\t      return state.parent && state.parent.params ? extend(state.parent.params.$$new(), ownParams) : new $$UMFP.ParamSet();\n\t    },\n\t\n\t    // If there is no explicit multi-view configuration, make one up so we don't have\n\t    // to handle both cases in the view directive later. Note that having an explicit\n\t    // 'views' property will mean the default unnamed view properties are ignored. This\n\t    // is also a good time to resolve view names to absolute names, so everything is a\n\t    // straight lookup at link time.\n\t    views: function(state) {\n\t      var views = {};\n\t\n\t      forEach(isDefined(state.views) ? state.views : { '': state }, function (view, name) {\n\t        if (name.indexOf('@') < 0) name += '@' + state.parent.name;\n\t        view.resolveAs = view.resolveAs || state.resolveAs || '$resolve';\n\t        views[name] = view;\n\t      });\n\t      return views;\n\t    },\n\t\n\t    // Keep a full path from the root down to this state as this is needed for state activation.\n\t    path: function(state) {\n\t      return state.parent ? state.parent.path.concat(state) : []; // exclude root from path\n\t    },\n\t\n\t    // Speed up $state.contains() as it's used a lot\n\t    includes: function(state) {\n\t      var includes = state.parent ? extend({}, state.parent.includes) : {};\n\t      includes[state.name] = true;\n\t      return includes;\n\t    },\n\t\n\t    $delegates: {}\n\t  };\n\t\n\t  function isRelative(stateName) {\n\t    return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n\t  }\n\t\n\t  function findState(stateOrName, base) {\n\t    if (!stateOrName) return undefined;\n\t\n\t    var isStr = isString(stateOrName),\n\t        name  = isStr ? stateOrName : stateOrName.name,\n\t        path  = isRelative(name);\n\t\n\t    if (path) {\n\t      if (!base) throw new Error(\"No reference point given for path '\"  + name + \"'\");\n\t      base = findState(base);\n\t      \n\t      var rel = name.split(\".\"), i = 0, pathLength = rel.length, current = base;\n\t\n\t      for (; i < pathLength; i++) {\n\t        if (rel[i] === \"\" && i === 0) {\n\t          current = base;\n\t          continue;\n\t        }\n\t        if (rel[i] === \"^\") {\n\t          if (!current.parent) throw new Error(\"Path '\" + name + \"' not valid for state '\" + base.name + \"'\");\n\t          current = current.parent;\n\t          continue;\n\t        }\n\t        break;\n\t      }\n\t      rel = rel.slice(i).join(\".\");\n\t      name = current.name + (current.name && rel ? \".\" : \"\") + rel;\n\t    }\n\t    var state = states[name];\n\t\n\t    if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n\t      return state;\n\t    }\n\t    return undefined;\n\t  }\n\t\n\t  function queueState(parentName, state) {\n\t    if (!queue[parentName]) {\n\t      queue[parentName] = [];\n\t    }\n\t    queue[parentName].push(state);\n\t  }\n\t\n\t  function flushQueuedChildren(parentName) {\n\t    var queued = queue[parentName] || [];\n\t    while(queued.length) {\n\t      registerState(queued.shift());\n\t    }\n\t  }\n\t\n\t  function registerState(state) {\n\t    // Wrap a new object around the state so we can store our private details easily.\n\t    state = inherit(state, {\n\t      self: state,\n\t      resolve: state.resolve || {},\n\t      toString: function() { return this.name; }\n\t    });\n\t\n\t    var name = state.name;\n\t    if (!isString(name) || name.indexOf('@') >= 0) throw new Error(\"State must have a valid name\");\n\t    if (states.hasOwnProperty(name)) throw new Error(\"State '\" + name + \"' is already defined\");\n\t\n\t    // Get parent name\n\t    var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.'))\n\t        : (isString(state.parent)) ? state.parent\n\t        : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name\n\t        : '';\n\t\n\t    // If parent is not registered yet, add state to queue and register later\n\t    if (parentName && !states[parentName]) {\n\t      return queueState(parentName, state.self);\n\t    }\n\t\n\t    for (var key in stateBuilder) {\n\t      if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);\n\t    }\n\t    states[name] = state;\n\t\n\t    // Register the state in the global state list and with $urlRouter if necessary.\n\t    if (!state[abstractKey] && state.url) {\n\t      $urlRouterProvider.when(state.url, ['$match', '$stateParams', function ($match, $stateParams) {\n\t        if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {\n\t          $state.transitionTo(state, $match, { inherit: true, location: false });\n\t        }\n\t      }]);\n\t    }\n\t\n\t    // Register any queued children\n\t    flushQueuedChildren(name);\n\t\n\t    return state;\n\t  }\n\t\n\t  // Checks text to see if it looks like a glob.\n\t  function isGlob (text) {\n\t    return text.indexOf('*') > -1;\n\t  }\n\t\n\t  // Returns true if glob matches current $state name.\n\t  function doesStateMatchGlob (glob) {\n\t    var globSegments = glob.split('.'),\n\t        segments = $state.$current.name.split('.');\n\t\n\t    //match single stars\n\t    for (var i = 0, l = globSegments.length; i < l; i++) {\n\t      if (globSegments[i] === '*') {\n\t        segments[i] = '*';\n\t      }\n\t    }\n\t\n\t    //match greedy starts\n\t    if (globSegments[0] === '**') {\n\t       segments = segments.slice(indexOf(segments, globSegments[1]));\n\t       segments.unshift('**');\n\t    }\n\t    //match greedy ends\n\t    if (globSegments[globSegments.length - 1] === '**') {\n\t       segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);\n\t       segments.push('**');\n\t    }\n\t\n\t    if (globSegments.length != segments.length) {\n\t      return false;\n\t    }\n\t\n\t    return segments.join('') === globSegments.join('');\n\t  }\n\t\n\t\n\t  // Implicit root state that is always active\n\t  root = registerState({\n\t    name: '',\n\t    url: '^',\n\t    views: null,\n\t    'abstract': true\n\t  });\n\t  root.navigable = null;\n\t\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.state.$stateProvider#decorator\n\t   * @methodOf ui.router.state.$stateProvider\n\t   *\n\t   * @description\n\t   * Allows you to extend (carefully) or override (at your own peril) the \n\t   * `stateBuilder` object used internally by `$stateProvider`. This can be used \n\t   * to add custom functionality to ui-router, for example inferring templateUrl \n\t   * based on the state name.\n\t   *\n\t   * When passing only a name, it returns the current (original or decorated) builder\n\t   * function that matches `name`.\n\t   *\n\t   * The builder functions that can be decorated are listed below. Though not all\n\t   * necessarily have a good use case for decoration, that is up to you to decide.\n\t   *\n\t   * In addition, users can attach custom decorators, which will generate new \n\t   * properties within the state's internal definition. There is currently no clear \n\t   * use-case for this beyond accessing internal states (i.e. $state.$current), \n\t   * however, expect this to become increasingly relevant as we introduce additional \n\t   * meta-programming features.\n\t   *\n\t   * **Warning**: Decorators should not be interdependent because the order of \n\t   * execution of the builder functions in non-deterministic. Builder functions \n\t   * should only be dependent on the state definition object and super function.\n\t   *\n\t   *\n\t   * Existing builder functions and current return values:\n\t   *\n\t   * - **parent** `{object}` - returns the parent state object.\n\t   * - **data** `{object}` - returns state data, including any inherited data that is not\n\t   *   overridden by own values (if any).\n\t   * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}\n\t   *   or `null`.\n\t   * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is \n\t   *   navigable).\n\t   * - **params** `{object}` - returns an array of state params that are ensured to \n\t   *   be a super-set of parent's params.\n\t   * - **views** `{object}` - returns a views object where each key is an absolute view \n\t   *   name (i.e. \"viewName@stateName\") and each value is the config object \n\t   *   (template, controller) for the view. Even when you don't use the views object \n\t   *   explicitly on a state config, one is still created for you internally.\n\t   *   So by decorating this builder function you have access to decorating template \n\t   *   and controller properties.\n\t   * - **ownParams** `{object}` - returns an array of params that belong to the state, \n\t   *   not including any params defined by ancestor states.\n\t   * - **path** `{string}` - returns the full path from the root down to this state. \n\t   *   Needed for state activation.\n\t   * - **includes** `{object}` - returns an object that includes every state that \n\t   *   would pass a `$state.includes()` test.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * // Override the internal 'views' builder with a function that takes the state\n\t   * // definition, and a reference to the internal function being overridden:\n\t   * $stateProvider.decorator('views', function (state, parent) {\n\t   *   var result = {},\n\t   *       views = parent(state);\n\t   *\n\t   *   angular.forEach(views, function (config, name) {\n\t   *     var autoName = (state.name + '.' + name).replace('.', '/');\n\t   *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';\n\t   *     result[name] = config;\n\t   *   });\n\t   *   return result;\n\t   * });\n\t   *\n\t   * $stateProvider.state('home', {\n\t   *   views: {\n\t   *     'contact.list': { controller: 'ListController' },\n\t   *     'contact.item': { controller: 'ItemController' }\n\t   *   }\n\t   * });\n\t   *\n\t   * // ...\n\t   *\n\t   * $state.go('home');\n\t   * // Auto-populates list and item views with /partials/home/contact/list.html,\n\t   * // and /partials/home/contact/item.html, respectively.\n\t   * </pre>\n\t   *\n\t   * @param {string} name The name of the builder function to decorate. \n\t   * @param {object} func A function that is responsible for decorating the original \n\t   * builder function. The function receives two parameters:\n\t   *\n\t   *   - `{object}` - state - The state config object.\n\t   *   - `{object}` - super - The original builder function.\n\t   *\n\t   * @return {object} $stateProvider - $stateProvider instance\n\t   */\n\t  this.decorator = decorator;\n\t  function decorator(name, func) {\n\t    /*jshint validthis: true */\n\t    if (isString(name) && !isDefined(func)) {\n\t      return stateBuilder[name];\n\t    }\n\t    if (!isFunction(func) || !isString(name)) {\n\t      return this;\n\t    }\n\t    if (stateBuilder[name] && !stateBuilder.$delegates[name]) {\n\t      stateBuilder.$delegates[name] = stateBuilder[name];\n\t    }\n\t    stateBuilder[name] = func;\n\t    return this;\n\t  }\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.state.$stateProvider#state\n\t   * @methodOf ui.router.state.$stateProvider\n\t   *\n\t   * @description\n\t   * Registers a state configuration under a given state name. The stateConfig object\n\t   * has the following acceptable properties.\n\t   *\n\t   * @param {string} name A unique state name, e.g. \"home\", \"about\", \"contacts\".\n\t   * To create a parent/child state use a dot, e.g. \"about.sales\", \"home.newest\".\n\t   * @param {object} stateConfig State configuration object.\n\t   * @param {string|function=} stateConfig.template\n\t   * <a id='template'></a>\n\t   *   html template as a string or a function that returns\n\t   *   an html template as a string which should be used by the uiView directives. This property \n\t   *   takes precedence over templateUrl.\n\t   *   \n\t   *   If `template` is a function, it will be called with the following parameters:\n\t   *\n\t   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by\n\t   *     applying the current state\n\t   *\n\t   * <pre>template:\n\t   *   \"<h1>inline template definition</h1>\" +\n\t   *   \"<div ui-view></div>\"</pre>\n\t   * <pre>template: function(params) {\n\t   *       return \"<h1>generated template</h1>\"; }</pre>\n\t   * </div>\n\t   *\n\t   * @param {string|function=} stateConfig.templateUrl\n\t   * <a id='templateUrl'></a>\n\t   *\n\t   *   path or function that returns a path to an html\n\t   *   template that should be used by uiView.\n\t   *   \n\t   *   If `templateUrl` is a function, it will be called with the following parameters:\n\t   *\n\t   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by \n\t   *     applying the current state\n\t   *\n\t   * <pre>templateUrl: \"home.html\"</pre>\n\t   * <pre>templateUrl: function(params) {\n\t   *     return myTemplates[params.pageId]; }</pre>\n\t   *\n\t   * @param {function=} stateConfig.templateProvider\n\t   * <a id='templateProvider'></a>\n\t   *    Provider function that returns HTML content string.\n\t   * <pre> templateProvider:\n\t   *       function(MyTemplateService, params) {\n\t   *         return MyTemplateService.getTemplate(params.pageId);\n\t   *       }</pre>\n\t   *\n\t   * @param {string|function=} stateConfig.controller\n\t   * <a id='controller'></a>\n\t   *\n\t   *  Controller fn that should be associated with newly\n\t   *   related scope or the name of a registered controller if passed as a string.\n\t   *   Optionally, the ControllerAs may be declared here.\n\t   * <pre>controller: \"MyRegisteredController\"</pre>\n\t   * <pre>controller:\n\t   *     \"MyRegisteredController as fooCtrl\"}</pre>\n\t   * <pre>controller: function($scope, MyService) {\n\t   *     $scope.data = MyService.getData(); }</pre>\n\t   *\n\t   * @param {function=} stateConfig.controllerProvider\n\t   * <a id='controllerProvider'></a>\n\t   *\n\t   * Injectable provider function that returns the actual controller or string.\n\t   * <pre>controllerProvider:\n\t   *   function(MyResolveData) {\n\t   *     if (MyResolveData.foo)\n\t   *       return \"FooCtrl\"\n\t   *     else if (MyResolveData.bar)\n\t   *       return \"BarCtrl\";\n\t   *     else return function($scope) {\n\t   *       $scope.baz = \"Qux\";\n\t   *     }\n\t   *   }</pre>\n\t   *\n\t   * @param {string=} stateConfig.controllerAs\n\t   * <a id='controllerAs'></a>\n\t   * \n\t   * A controller alias name. If present the controller will be\n\t   *   published to scope under the controllerAs name.\n\t   * <pre>controllerAs: \"myCtrl\"</pre>\n\t   *\n\t   * @param {string|object=} stateConfig.parent\n\t   * <a id='parent'></a>\n\t   * Optionally specifies the parent state of this state.\n\t   *\n\t   * <pre>parent: 'parentState'</pre>\n\t   * <pre>parent: parentState // JS variable</pre>\n\t   *\n\t   * @param {object=} stateConfig.resolve\n\t   * <a id='resolve'></a>\n\t   *\n\t   * An optional map&lt;string, function&gt; of dependencies which\n\t   *   should be injected into the controller. If any of these dependencies are promises, \n\t   *   the router will wait for them all to be resolved before the controller is instantiated.\n\t   *   If all the promises are resolved successfully, the $stateChangeSuccess event is fired\n\t   *   and the values of the resolved promises are injected into any controllers that reference them.\n\t   *   If any  of the promises are rejected the $stateChangeError event is fired.\n\t   *\n\t   *   The map object is:\n\t   *   \n\t   *   - key - {string}: name of dependency to be injected into controller\n\t   *   - factory - {string|function}: If string then it is alias for service. Otherwise if function, \n\t   *     it is injected and return value it treated as dependency. If result is a promise, it is \n\t   *     resolved before its value is injected into controller.\n\t   *\n\t   * <pre>resolve: {\n\t   *     myResolve1:\n\t   *       function($http, $stateParams) {\n\t   *         return $http.get(\"/api/foos/\"+stateParams.fooID);\n\t   *       }\n\t   *     }</pre>\n\t   *\n\t   * @param {string=} stateConfig.url\n\t   * <a id='url'></a>\n\t   *\n\t   *   A url fragment with optional parameters. When a state is navigated or\n\t   *   transitioned to, the `$stateParams` service will be populated with any \n\t   *   parameters that were passed.\n\t   *\n\t   *   (See {@link ui.router.util.type:UrlMatcher UrlMatcher} `UrlMatcher`} for\n\t   *   more details on acceptable patterns )\n\t   *\n\t   * examples:\n\t   * <pre>url: \"/home\"\n\t   * url: \"/users/:userid\"\n\t   * url: \"/books/{bookid:[a-zA-Z_-]}\"\n\t   * url: \"/books/{categoryid:int}\"\n\t   * url: \"/books/{publishername:string}/{categoryid:int}\"\n\t   * url: \"/messages?before&after\"\n\t   * url: \"/messages?{before:date}&{after:date}\"\n\t   * url: \"/messages/:mailboxid?{before:date}&{after:date}\"\n\t   * </pre>\n\t   *\n\t   * @param {object=} stateConfig.views\n\t   * <a id='views'></a>\n\t   * an optional map&lt;string, object&gt; which defined multiple views, or targets views\n\t   * manually/explicitly.\n\t   *\n\t   * Examples:\n\t   *\n\t   * Targets three named `ui-view`s in the parent state's template\n\t   * <pre>views: {\n\t   *     header: {\n\t   *       controller: \"headerCtrl\",\n\t   *       templateUrl: \"header.html\"\n\t   *     }, body: {\n\t   *       controller: \"bodyCtrl\",\n\t   *       templateUrl: \"body.html\"\n\t   *     }, footer: {\n\t   *       controller: \"footCtrl\",\n\t   *       templateUrl: \"footer.html\"\n\t   *     }\n\t   *   }</pre>\n\t   *\n\t   * Targets named `ui-view=\"header\"` from grandparent state 'top''s template, and named `ui-view=\"body\" from parent state's template.\n\t   * <pre>views: {\n\t   *     'header@top': {\n\t   *       controller: \"msgHeaderCtrl\",\n\t   *       templateUrl: \"msgHeader.html\"\n\t   *     }, 'body': {\n\t   *       controller: \"messagesCtrl\",\n\t   *       templateUrl: \"messages.html\"\n\t   *     }\n\t   *   }</pre>\n\t   *\n\t   * @param {boolean=} [stateConfig.abstract=false]\n\t   * <a id='abstract'></a>\n\t   * An abstract state will never be directly activated,\n\t   *   but can provide inherited properties to its common children states.\n\t   * <pre>abstract: true</pre>\n\t   *\n\t   * @param {function=} stateConfig.onEnter\n\t   * <a id='onEnter'></a>\n\t   *\n\t   * Callback function for when a state is entered. Good way\n\t   *   to trigger an action or dispatch an event, such as opening a dialog.\n\t   * If minifying your scripts, make sure to explicitly annotate this function,\n\t   * because it won't be automatically annotated by your build tools.\n\t   *\n\t   * <pre>onEnter: function(MyService, $stateParams) {\n\t   *     MyService.foo($stateParams.myParam);\n\t   * }</pre>\n\t   *\n\t   * @param {function=} stateConfig.onExit\n\t   * <a id='onExit'></a>\n\t   *\n\t   * Callback function for when a state is exited. Good way to\n\t   *   trigger an action or dispatch an event, such as opening a dialog.\n\t   * If minifying your scripts, make sure to explicitly annotate this function,\n\t   * because it won't be automatically annotated by your build tools.\n\t   *\n\t   * <pre>onExit: function(MyService, $stateParams) {\n\t   *     MyService.cleanup($stateParams.myParam);\n\t   * }</pre>\n\t   *\n\t   * @param {boolean=} [stateConfig.reloadOnSearch=true]\n\t   * <a id='reloadOnSearch'></a>\n\t   *\n\t   * If `false`, will not retrigger the same state\n\t   *   just because a search/query parameter has changed (via $location.search() or $location.hash()). \n\t   *   Useful for when you'd like to modify $location.search() without triggering a reload.\n\t   * <pre>reloadOnSearch: false</pre>\n\t   *\n\t   * @param {object=} stateConfig.data\n\t   * <a id='data'></a>\n\t   *\n\t   * Arbitrary data object, useful for custom configuration.  The parent state's `data` is\n\t   *   prototypally inherited.  In other words, adding a data property to a state adds it to\n\t   *   the entire subtree via prototypal inheritance.\n\t   *\n\t   * <pre>data: {\n\t   *     requiredRole: 'foo'\n\t   * } </pre>\n\t   *\n\t   * @param {object=} stateConfig.params\n\t   * <a id='params'></a>\n\t   *\n\t   * A map which optionally configures parameters declared in the `url`, or\n\t   *   defines additional non-url parameters.  For each parameter being\n\t   *   configured, add a configuration object keyed to the name of the parameter.\n\t   *\n\t   *   Each parameter configuration object may contain the following properties:\n\t   *\n\t   *   - ** value ** - {object|function=}: specifies the default value for this\n\t   *     parameter.  This implicitly sets this parameter as optional.\n\t   *\n\t   *     When UI-Router routes to a state and no value is\n\t   *     specified for this parameter in the URL or transition, the\n\t   *     default value will be used instead.  If `value` is a function,\n\t   *     it will be injected and invoked, and the return value used.\n\t   *\n\t   *     *Note*: `undefined` is treated as \"no default value\" while `null`\n\t   *     is treated as \"the default value is `null`\".\n\t   *\n\t   *     *Shorthand*: If you only need to configure the default value of the\n\t   *     parameter, you may use a shorthand syntax.   In the **`params`**\n\t   *     map, instead mapping the param name to a full parameter configuration\n\t   *     object, simply set map it to the default parameter value, e.g.:\n\t   *\n\t   * <pre>// define a parameter's default value\n\t   * params: {\n\t   *     param1: { value: \"defaultValue\" }\n\t   * }\n\t   * // shorthand default values\n\t   * params: {\n\t   *     param1: \"defaultValue\",\n\t   *     param2: \"param2Default\"\n\t   * }</pre>\n\t   *\n\t   *   - ** array ** - {boolean=}: *(default: false)* If true, the param value will be\n\t   *     treated as an array of values.  If you specified a Type, the value will be\n\t   *     treated as an array of the specified Type.  Note: query parameter values\n\t   *     default to a special `\"auto\"` mode.\n\t   *\n\t   *     For query parameters in `\"auto\"` mode, if multiple  values for a single parameter\n\t   *     are present in the URL (e.g.: `/foo?bar=1&bar=2&bar=3`) then the values\n\t   *     are mapped to an array (e.g.: `{ foo: [ '1', '2', '3' ] }`).  However, if\n\t   *     only one value is present (e.g.: `/foo?bar=1`) then the value is treated as single\n\t   *     value (e.g.: `{ foo: '1' }`).\n\t   *\n\t   * <pre>params: {\n\t   *     param1: { array: true }\n\t   * }</pre>\n\t   *\n\t   *   - ** squash ** - {bool|string=}: `squash` configures how a default parameter value is represented in the URL when\n\t   *     the current parameter value is the same as the default value. If `squash` is not set, it uses the\n\t   *     configured default squash policy.\n\t   *     (See {@link ui.router.util.$urlMatcherFactory#methods_defaultSquashPolicy `defaultSquashPolicy()`})\n\t   *\n\t   *   There are three squash settings:\n\t   *\n\t   *     - false: The parameter's default value is not squashed.  It is encoded and included in the URL\n\t   *     - true: The parameter's default value is omitted from the URL.  If the parameter is preceeded and followed\n\t   *       by slashes in the state's `url` declaration, then one of those slashes are omitted.\n\t   *       This can allow for cleaner looking URLs.\n\t   *     - `\"<arbitrary string>\"`: The parameter's default value is replaced with an arbitrary placeholder of  your choice.\n\t   *\n\t   * <pre>params: {\n\t   *     param1: {\n\t   *       value: \"defaultId\",\n\t   *       squash: true\n\t   * } }\n\t   * // squash \"defaultValue\" to \"~\"\n\t   * params: {\n\t   *     param1: {\n\t   *       value: \"defaultValue\",\n\t   *       squash: \"~\"\n\t   * } }\n\t   * </pre>\n\t   *\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * // Some state name examples\n\t   *\n\t   * // stateName can be a single top-level name (must be unique).\n\t   * $stateProvider.state(\"home\", {});\n\t   *\n\t   * // Or it can be a nested state name. This state is a child of the\n\t   * // above \"home\" state.\n\t   * $stateProvider.state(\"home.newest\", {});\n\t   *\n\t   * // Nest states as deeply as needed.\n\t   * $stateProvider.state(\"home.newest.abc.xyz.inception\", {});\n\t   *\n\t   * // state() returns $stateProvider, so you can chain state declarations.\n\t   * $stateProvider\n\t   *   .state(\"home\", {})\n\t   *   .state(\"about\", {})\n\t   *   .state(\"contacts\", {});\n\t   * </pre>\n\t   *\n\t   */\n\t  this.state = state;\n\t  function state(name, definition) {\n\t    /*jshint validthis: true */\n\t    if (isObject(name)) definition = name;\n\t    else definition.name = name;\n\t    registerState(definition);\n\t    return this;\n\t  }\n\t\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.state.$state\n\t   *\n\t   * @requires $rootScope\n\t   * @requires $q\n\t   * @requires ui.router.state.$view\n\t   * @requires $injector\n\t   * @requires ui.router.util.$resolve\n\t   * @requires ui.router.state.$stateParams\n\t   * @requires ui.router.router.$urlRouter\n\t   *\n\t   * @property {object} params A param object, e.g. {sectionId: section.id)}, that \n\t   * you'd like to test against the current active state.\n\t   * @property {object} current A reference to the state's config object. However \n\t   * you passed it in. Useful for accessing custom data.\n\t   * @property {object} transition Currently pending transition. A promise that'll \n\t   * resolve or reject.\n\t   *\n\t   * @description\n\t   * `$state` service is responsible for representing states as well as transitioning\n\t   * between them. It also provides interfaces to ask for current state or even states\n\t   * you're coming from.\n\t   */\n\t  this.$get = $get;\n\t  $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];\n\t  function $get(   $rootScope,   $q,   $view,   $injector,   $resolve,   $stateParams,   $urlRouter,   $location,   $urlMatcherFactory) {\n\t\n\t    var TransitionSuperseded = $q.reject(new Error('transition superseded'));\n\t    var TransitionPrevented = $q.reject(new Error('transition prevented'));\n\t    var TransitionAborted = $q.reject(new Error('transition aborted'));\n\t    var TransitionFailed = $q.reject(new Error('transition failed'));\n\t\n\t    // Handles the case where a state which is the target of a transition is not found, and the user\n\t    // can optionally retry or defer the transition\n\t    function handleRedirect(redirect, state, params, options) {\n\t      /**\n\t       * @ngdoc event\n\t       * @name ui.router.state.$state#$stateNotFound\n\t       * @eventOf ui.router.state.$state\n\t       * @eventType broadcast on root scope\n\t       * @description\n\t       * Fired when a requested state **cannot be found** using the provided state name during transition.\n\t       * The event is broadcast allowing any handlers a single chance to deal with the error (usually by\n\t       * lazy-loading the unfound state). A special `unfoundState` object is passed to the listener handler,\n\t       * you can see its three properties in the example. You can use `event.preventDefault()` to abort the\n\t       * transition and the promise returned from `go` will be rejected with a `'transition aborted'` value.\n\t       *\n\t       * @param {Object} event Event object.\n\t       * @param {Object} unfoundState Unfound State information. Contains: `to, toParams, options` properties.\n\t       * @param {State} fromState Current state object.\n\t       * @param {Object} fromParams Current state params.\n\t       *\n\t       * @example\n\t       *\n\t       * <pre>\n\t       * // somewhere, assume lazy.state has not been defined\n\t       * $state.go(\"lazy.state\", {a:1, b:2}, {inherit:false});\n\t       *\n\t       * // somewhere else\n\t       * $scope.$on('$stateNotFound',\n\t       * function(event, unfoundState, fromState, fromParams){\n\t       *     console.log(unfoundState.to); // \"lazy.state\"\n\t       *     console.log(unfoundState.toParams); // {a:1, b:2}\n\t       *     console.log(unfoundState.options); // {inherit:false} + default options\n\t       * })\n\t       * </pre>\n\t       */\n\t      var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);\n\t\n\t      if (evt.defaultPrevented) {\n\t        $urlRouter.update();\n\t        return TransitionAborted;\n\t      }\n\t\n\t      if (!evt.retry) {\n\t        return null;\n\t      }\n\t\n\t      // Allow the handler to return a promise to defer state lookup retry\n\t      if (options.$retry) {\n\t        $urlRouter.update();\n\t        return TransitionFailed;\n\t      }\n\t      var retryTransition = $state.transition = $q.when(evt.retry);\n\t\n\t      retryTransition.then(function() {\n\t        if (retryTransition !== $state.transition) return TransitionSuperseded;\n\t        redirect.options.$retry = true;\n\t        return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);\n\t      }, function() {\n\t        return TransitionAborted;\n\t      });\n\t      $urlRouter.update();\n\t\n\t      return retryTransition;\n\t    }\n\t\n\t    root.locals = { resolve: null, globals: { $stateParams: {} } };\n\t\n\t    $state = {\n\t      params: {},\n\t      current: root.self,\n\t      $current: root,\n\t      transition: null\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#reload\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * A method that force reloads the current state. All resolves are re-resolved,\n\t     * controllers reinstantiated, and events re-fired.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * var app angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.reload = function(){\n\t     *     $state.reload();\n\t     *   }\n\t     * });\n\t     * </pre>\n\t     *\n\t     * `reload()` is just an alias for:\n\t     * <pre>\n\t     * $state.transitionTo($state.current, $stateParams, { \n\t     *   reload: true, inherit: false, notify: true\n\t     * });\n\t     * </pre>\n\t     *\n\t     * @param {string=|object=} state - A state name or a state object, which is the root of the resolves to be re-resolved.\n\t     * @example\n\t     * <pre>\n\t     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item' \n\t     * //and current state is 'contacts.detail.item'\n\t     * var app angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.reload = function(){\n\t     *     //will reload 'contact.detail' and 'contact.detail.item' states\n\t     *     $state.reload('contact.detail');\n\t     *   }\n\t     * });\n\t     * </pre>\n\t     *\n\t     * `reload()` is just an alias for:\n\t     * <pre>\n\t     * $state.transitionTo($state.current, $stateParams, { \n\t     *   reload: true, inherit: false, notify: true\n\t     * });\n\t     * </pre>\n\t\n\t     * @returns {promise} A promise representing the state of the new transition. See\n\t     * {@link ui.router.state.$state#methods_go $state.go}.\n\t     */\n\t    $state.reload = function reload(state) {\n\t      return $state.transitionTo($state.current, $stateParams, { reload: state || true, inherit: false, notify: true});\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#go\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * Convenience method for transitioning to a new state. `$state.go` calls \n\t     * `$state.transitionTo` internally but automatically sets options to \n\t     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`. \n\t     * This allows you to easily use an absolute or relative to path and specify \n\t     * only the parameters you'd like to update (while letting unspecified parameters \n\t     * inherit from the currently active ancestor states).\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * var app = angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.changeState = function () {\n\t     *     $state.go('contact.detail');\n\t     *   };\n\t     * });\n\t     * </pre>\n\t     * <img src='../ngdoc_assets/StateGoExamples.png'/>\n\t     *\n\t     * @param {string} to Absolute state name or relative state path. Some examples:\n\t     *\n\t     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n\t     * - `$state.go('^')` - will go to a parent state\n\t     * - `$state.go('^.sibling')` - will go to a sibling state\n\t     * - `$state.go('.child.grandchild')` - will go to grandchild state\n\t     *\n\t     * @param {object=} params A map of the parameters that will be sent to the state, \n\t     * will populate $stateParams. Any parameters that are not specified will be inherited from currently \n\t     * defined parameters. Only parameters specified in the state definition can be overridden, new \n\t     * parameters will be ignored. This allows, for example, going to a sibling state that shares parameters\n\t     * specified in a parent state. Parameter inheritance only works between common ancestor states, I.e.\n\t     * transitioning to a sibling will get you the parameters for all parents, transitioning to a child\n\t     * will get you all current parameters, etc.\n\t     * @param {object=} options Options object. The options are:\n\t     *\n\t     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n\t     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n\t     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n\t     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n\t     *    defines which state to be relative from.\n\t     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n\t     * - **`reload`** (v0.2.5) - {boolean=false|string|object}, If `true` will force transition even if no state or params\n\t     *    have changed.  It will reload the resolves and views of the current state and parent states.\n\t     *    If `reload` is a string (or state object), the state object is fetched (by name, or object reference); and \\\n\t     *    the transition reloads the resolves and views for that matched state, and all its children states.\n\t     *\n\t     * @returns {promise} A promise representing the state of the new transition.\n\t     *\n\t     * Possible success values:\n\t     *\n\t     * - $state.current\n\t     *\n\t     * <br/>Possible rejection values:\n\t     *\n\t     * - 'transition superseded' - when a newer transition has been started after this one\n\t     * - 'transition prevented' - when `event.preventDefault()` has been called in a `$stateChangeStart` listener\n\t     * - 'transition aborted' - when `event.preventDefault()` has been called in a `$stateNotFound` listener or\n\t     *   when a `$stateNotFound` `event.retry` promise errors.\n\t     * - 'transition failed' - when a state has been unsuccessfully found after 2 tries.\n\t     * - *resolve error* - when an error has occurred with a `resolve`\n\t     *\n\t     */\n\t    $state.go = function go(to, params, options) {\n\t      return $state.transitionTo(to, params, extend({ inherit: true, relative: $state.$current }, options));\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#transitionTo\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * Low-level method for transitioning to a new state. {@link ui.router.state.$state#methods_go $state.go}\n\t     * uses `transitionTo` internally. `$state.go` is recommended in most situations.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * var app = angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.changeState = function () {\n\t     *     $state.transitionTo('contact.detail');\n\t     *   };\n\t     * });\n\t     * </pre>\n\t     *\n\t     * @param {string} to State name.\n\t     * @param {object=} toParams A map of the parameters that will be sent to the state,\n\t     * will populate $stateParams.\n\t     * @param {object=} options Options object. The options are:\n\t     *\n\t     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n\t     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n\t     * - **`inherit`** - {boolean=false}, If `true` will inherit url parameters from current url.\n\t     * - **`relative`** - {object=}, When transitioning with relative path (e.g '^'), \n\t     *    defines which state to be relative from.\n\t     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n\t     * - **`reload`** (v0.2.5) - {boolean=false|string=|object=}, If `true` will force transition even if the state or params \n\t     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n\t     *    use this when you want to force a reload when *everything* is the same, including search params.\n\t     *    if String, then will reload the state with the name given in reload, and any children.\n\t     *    if Object, then a stateObj is expected, will reload the state found in stateObj, and any children.\n\t     *\n\t     * @returns {promise} A promise representing the state of the new transition. See\n\t     * {@link ui.router.state.$state#methods_go $state.go}.\n\t     */\n\t    $state.transitionTo = function transitionTo(to, toParams, options) {\n\t      toParams = toParams || {};\n\t      options = extend({\n\t        location: true, inherit: false, relative: null, notify: true, reload: false, $retry: false\n\t      }, options || {});\n\t\n\t      var from = $state.$current, fromParams = $state.params, fromPath = from.path;\n\t      var evt, toState = findState(to, options.relative);\n\t\n\t      // Store the hash param for later (since it will be stripped out by various methods)\n\t      var hash = toParams['#'];\n\t\n\t      if (!isDefined(toState)) {\n\t        var redirect = { to: to, toParams: toParams, options: options };\n\t        var redirectResult = handleRedirect(redirect, from.self, fromParams, options);\n\t\n\t        if (redirectResult) {\n\t          return redirectResult;\n\t        }\n\t\n\t        // Always retry once if the $stateNotFound was not prevented\n\t        // (handles either redirect changed or state lazy-definition)\n\t        to = redirect.to;\n\t        toParams = redirect.toParams;\n\t        options = redirect.options;\n\t        toState = findState(to, options.relative);\n\t\n\t        if (!isDefined(toState)) {\n\t          if (!options.relative) throw new Error(\"No such state '\" + to + \"'\");\n\t          throw new Error(\"Could not resolve '\" + to + \"' from state '\" + options.relative + \"'\");\n\t        }\n\t      }\n\t      if (toState[abstractKey]) throw new Error(\"Cannot transition to abstract state '\" + to + \"'\");\n\t      if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);\n\t      if (!toState.params.$$validates(toParams)) return TransitionFailed;\n\t\n\t      toParams = toState.params.$$values(toParams);\n\t      to = toState;\n\t\n\t      var toPath = to.path;\n\t\n\t      // Starting from the root of the path, keep all levels that haven't changed\n\t      var keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];\n\t\n\t      if (!options.reload) {\n\t        while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {\n\t          locals = toLocals[keep] = state.locals;\n\t          keep++;\n\t          state = toPath[keep];\n\t        }\n\t      } else if (isString(options.reload) || isObject(options.reload)) {\n\t        if (isObject(options.reload) && !options.reload.name) {\n\t          throw new Error('Invalid reload state object');\n\t        }\n\t        \n\t        var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);\n\t        if (options.reload && !reloadState) {\n\t          throw new Error(\"No such reload state '\" + (isString(options.reload) ? options.reload : options.reload.name) + \"'\");\n\t        }\n\t\n\t        while (state && state === fromPath[keep] && state !== reloadState) {\n\t          locals = toLocals[keep] = state.locals;\n\t          keep++;\n\t          state = toPath[keep];\n\t        }\n\t      }\n\t\n\t      // If we're going to the same state and all locals are kept, we've got nothing to do.\n\t      // But clear 'transition', as we still want to cancel any other pending transitions.\n\t      // TODO: We may not want to bump 'transition' if we're called from a location change\n\t      // that we've initiated ourselves, because we might accidentally abort a legitimate\n\t      // transition initiated from code?\n\t      if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {\n\t        if (hash) toParams['#'] = hash;\n\t        $state.params = toParams;\n\t        copy($state.params, $stateParams);\n\t        copy(filterByKeys(to.params.$$keys(), $stateParams), to.locals.globals.$stateParams);\n\t        if (options.location && to.navigable && to.navigable.url) {\n\t          $urlRouter.push(to.navigable.url, toParams, {\n\t            $$avoidResync: true, replace: options.location === 'replace'\n\t          });\n\t          $urlRouter.update(true);\n\t        }\n\t        $state.transition = null;\n\t        return $q.when($state.current);\n\t      }\n\t\n\t      // Filter parameters before we pass them to event handlers etc.\n\t      toParams = filterByKeys(to.params.$$keys(), toParams || {});\n\t      \n\t      // Re-add the saved hash before we start returning things or broadcasting $stateChangeStart\n\t      if (hash) toParams['#'] = hash;\n\t      \n\t      // Broadcast start event and cancel the transition if requested\n\t      if (options.notify) {\n\t        /**\n\t         * @ngdoc event\n\t         * @name ui.router.state.$state#$stateChangeStart\n\t         * @eventOf ui.router.state.$state\n\t         * @eventType broadcast on root scope\n\t         * @description\n\t         * Fired when the state transition **begins**. You can use `event.preventDefault()`\n\t         * to prevent the transition from happening and then the transition promise will be\n\t         * rejected with a `'transition prevented'` value.\n\t         *\n\t         * @param {Object} event Event object.\n\t         * @param {State} toState The state being transitioned to.\n\t         * @param {Object} toParams The params supplied to the `toState`.\n\t         * @param {State} fromState The current state, pre-transition.\n\t         * @param {Object} fromParams The params supplied to the `fromState`.\n\t         *\n\t         * @example\n\t         *\n\t         * <pre>\n\t         * $rootScope.$on('$stateChangeStart',\n\t         * function(event, toState, toParams, fromState, fromParams){\n\t         *     event.preventDefault();\n\t         *     // transitionTo() promise will be rejected with\n\t         *     // a 'transition prevented' error\n\t         * })\n\t         * </pre>\n\t         */\n\t        if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams, options).defaultPrevented) {\n\t          $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);\n\t          //Don't update and resync url if there's been a new transition started. see issue #2238, #600\n\t          if ($state.transition == null) $urlRouter.update();\n\t          return TransitionPrevented;\n\t        }\n\t      }\n\t\n\t      // Resolve locals for the remaining states, but don't update any global state just\n\t      // yet -- if anything fails to resolve the current state needs to remain untouched.\n\t      // We also set up an inheritance chain for the locals here. This allows the view directive\n\t      // to quickly look up the correct definition for each view in the current state. Even\n\t      // though we create the locals object itself outside resolveState(), it is initially\n\t      // empty and gets filled asynchronously. We need to keep track of the promise for the\n\t      // (fully resolved) current locals, and pass this down the chain.\n\t      var resolved = $q.when(locals);\n\t\n\t      for (var l = keep; l < toPath.length; l++, state = toPath[l]) {\n\t        locals = toLocals[l] = inherit(locals);\n\t        resolved = resolveState(state, toParams, state === to, resolved, locals, options);\n\t      }\n\t\n\t      // Once everything is resolved, we are ready to perform the actual transition\n\t      // and return a promise for the new state. We also keep track of what the\n\t      // current promise is, so that we can detect overlapping transitions and\n\t      // keep only the outcome of the last transition.\n\t      var transition = $state.transition = resolved.then(function () {\n\t        var l, entering, exiting;\n\t\n\t        if ($state.transition !== transition) return TransitionSuperseded;\n\t\n\t        // Exit 'from' states not kept\n\t        for (l = fromPath.length - 1; l >= keep; l--) {\n\t          exiting = fromPath[l];\n\t          if (exiting.self.onExit) {\n\t            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);\n\t          }\n\t          exiting.locals = null;\n\t        }\n\t\n\t        // Enter 'to' states not kept\n\t        for (l = keep; l < toPath.length; l++) {\n\t          entering = toPath[l];\n\t          entering.locals = toLocals[l];\n\t          if (entering.self.onEnter) {\n\t            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);\n\t          }\n\t        }\n\t\n\t        // Run it again, to catch any transitions in callbacks\n\t        if ($state.transition !== transition) return TransitionSuperseded;\n\t\n\t        // Update globals in $state\n\t        $state.$current = to;\n\t        $state.current = to.self;\n\t        $state.params = toParams;\n\t        copy($state.params, $stateParams);\n\t        $state.transition = null;\n\t\n\t        if (options.location && to.navigable) {\n\t          $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {\n\t            $$avoidResync: true, replace: options.location === 'replace'\n\t          });\n\t        }\n\t\n\t        if (options.notify) {\n\t        /**\n\t         * @ngdoc event\n\t         * @name ui.router.state.$state#$stateChangeSuccess\n\t         * @eventOf ui.router.state.$state\n\t         * @eventType broadcast on root scope\n\t         * @description\n\t         * Fired once the state transition is **complete**.\n\t         *\n\t         * @param {Object} event Event object.\n\t         * @param {State} toState The state being transitioned to.\n\t         * @param {Object} toParams The params supplied to the `toState`.\n\t         * @param {State} fromState The current state, pre-transition.\n\t         * @param {Object} fromParams The params supplied to the `fromState`.\n\t         */\n\t          $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);\n\t        }\n\t        $urlRouter.update(true);\n\t\n\t        return $state.current;\n\t      }).then(null, function (error) {\n\t        if ($state.transition !== transition) return TransitionSuperseded;\n\t\n\t        $state.transition = null;\n\t        /**\n\t         * @ngdoc event\n\t         * @name ui.router.state.$state#$stateChangeError\n\t         * @eventOf ui.router.state.$state\n\t         * @eventType broadcast on root scope\n\t         * @description\n\t         * Fired when an **error occurs** during transition. It's important to note that if you\n\t         * have any errors in your resolve functions (javascript errors, non-existent services, etc)\n\t         * they will not throw traditionally. You must listen for this $stateChangeError event to\n\t         * catch **ALL** errors.\n\t         *\n\t         * @param {Object} event Event object.\n\t         * @param {State} toState The state being transitioned to.\n\t         * @param {Object} toParams The params supplied to the `toState`.\n\t         * @param {State} fromState The current state, pre-transition.\n\t         * @param {Object} fromParams The params supplied to the `fromState`.\n\t         * @param {Error} error The resolve error object.\n\t         */\n\t        evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);\n\t\n\t        if (!evt.defaultPrevented) {\n\t            $urlRouter.update();\n\t        }\n\t\n\t        return $q.reject(error);\n\t      });\n\t\n\t      return transition;\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#is\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * Similar to {@link ui.router.state.$state#methods_includes $state.includes},\n\t     * but only checks for the full state name. If params is supplied then it will be\n\t     * tested for strict equality against the current active params object, so all params\n\t     * must match with none missing and no extras.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * $state.$current.name = 'contacts.details.item';\n\t     *\n\t     * // absolute name\n\t     * $state.is('contact.details.item'); // returns true\n\t     * $state.is(contactDetailItemStateObject); // returns true\n\t     *\n\t     * // relative name (. and ^), typically from a template\n\t     * // E.g. from the 'contacts.details' template\n\t     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n\t     * </pre>\n\t     *\n\t     * @param {string|object} stateOrName The state name (absolute or relative) or state object you'd like to check.\n\t     * @param {object=} params A param object, e.g. `{sectionId: section.id}`, that you'd like\n\t     * to test against the current active state.\n\t     * @param {object=} options An options object.  The options are:\n\t     *\n\t     * - **`relative`** - {string|object} -  If `stateOrName` is a relative state name and `options.relative` is set, .is will\n\t     * test relative to `options.relative` state (or name).\n\t     *\n\t     * @returns {boolean} Returns true if it is the state.\n\t     */\n\t    $state.is = function is(stateOrName, params, options) {\n\t      options = extend({ relative: $state.$current }, options || {});\n\t      var state = findState(stateOrName, options.relative);\n\t\n\t      if (!isDefined(state)) { return undefined; }\n\t      if ($state.$current !== state) { return false; }\n\t      return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#includes\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * A method to determine if the current active state is equal to or is the child of the\n\t     * state stateName. If any params are passed then they will be tested for a match as well.\n\t     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n\t     *\n\t     * @example\n\t     * Partial and relative names\n\t     * <pre>\n\t     * $state.$current.name = 'contacts.details.item';\n\t     *\n\t     * // Using partial names\n\t     * $state.includes(\"contacts\"); // returns true\n\t     * $state.includes(\"contacts.details\"); // returns true\n\t     * $state.includes(\"contacts.details.item\"); // returns true\n\t     * $state.includes(\"contacts.list\"); // returns false\n\t     * $state.includes(\"about\"); // returns false\n\t     *\n\t     * // Using relative names (. and ^), typically from a template\n\t     * // E.g. from the 'contacts.details' template\n\t     * <div ng-class=\"{highlighted: $state.includes('.item')}\">Item</div>\n\t     * </pre>\n\t     *\n\t     * Basic globbing patterns\n\t     * <pre>\n\t     * $state.$current.name = 'contacts.details.item.url';\n\t     *\n\t     * $state.includes(\"*.details.*.*\"); // returns true\n\t     * $state.includes(\"*.details.**\"); // returns true\n\t     * $state.includes(\"**.item.**\"); // returns true\n\t     * $state.includes(\"*.details.item.url\"); // returns true\n\t     * $state.includes(\"*.details.*.url\"); // returns true\n\t     * $state.includes(\"*.details.*\"); // returns false\n\t     * $state.includes(\"item.**\"); // returns false\n\t     * </pre>\n\t     *\n\t     * @param {string} stateOrName A partial name, relative name, or glob pattern\n\t     * to be searched for within the current state name.\n\t     * @param {object=} params A param object, e.g. `{sectionId: section.id}`,\n\t     * that you'd like to test against the current active state.\n\t     * @param {object=} options An options object.  The options are:\n\t     *\n\t     * - **`relative`** - {string|object=} -  If `stateOrName` is a relative state reference and `options.relative` is set,\n\t     * .includes will test relative to `options.relative` state (or name).\n\t     *\n\t     * @returns {boolean} Returns true if it does include the state\n\t     */\n\t    $state.includes = function includes(stateOrName, params, options) {\n\t      options = extend({ relative: $state.$current }, options || {});\n\t      if (isString(stateOrName) && isGlob(stateOrName)) {\n\t        if (!doesStateMatchGlob(stateOrName)) {\n\t          return false;\n\t        }\n\t        stateOrName = $state.$current.name;\n\t      }\n\t\n\t      var state = findState(stateOrName, options.relative);\n\t      if (!isDefined(state)) { return undefined; }\n\t      if (!isDefined($state.$current.includes[state.name])) { return false; }\n\t      return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;\n\t    };\n\t\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#href\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * A url generation method that returns the compiled url for the given state populated with the given params.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n\t     * </pre>\n\t     *\n\t     * @param {string|object} stateOrName The state name or state object you'd like to generate a url from.\n\t     * @param {object=} params An object of parameter values to fill the state's required parameters.\n\t     * @param {object=} options Options object. The options are:\n\t     *\n\t     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the\n\t     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka\n\t     *    ancestor with a valid url).\n\t     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n\t     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n\t     *    defines which state to be relative from.\n\t     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n\t     * \n\t     * @returns {string} compiled state url\n\t     */\n\t    $state.href = function href(stateOrName, params, options) {\n\t      options = extend({\n\t        lossy:    true,\n\t        inherit:  true,\n\t        absolute: false,\n\t        relative: $state.$current\n\t      }, options || {});\n\t\n\t      var state = findState(stateOrName, options.relative);\n\t\n\t      if (!isDefined(state)) return null;\n\t      if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state);\n\t      \n\t      var nav = (state && options.lossy) ? state.navigable : state;\n\t\n\t      if (!nav || nav.url === undefined || nav.url === null) {\n\t        return null;\n\t      }\n\t      return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat('#'), params || {}), {\n\t        absolute: options.absolute\n\t      });\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#get\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * Returns the state configuration object for any specific state or all states.\n\t     *\n\t     * @param {string|object=} stateOrName (absolute or relative) If provided, will only get the config for\n\t     * the requested state. If not provided, returns an array of ALL state configs.\n\t     * @param {string|object=} context When stateOrName is a relative state reference, the state will be retrieved relative to context.\n\t     * @returns {Object|Array} State configuration object or array of all objects.\n\t     */\n\t    $state.get = function (stateOrName, context) {\n\t      if (arguments.length === 0) return map(objectKeys(states), function(name) { return states[name].self; });\n\t      var state = findState(stateOrName, context || $state.$current);\n\t      return (state && state.self) ? state.self : null;\n\t    };\n\t\n\t    function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {\n\t      // Make a restricted $stateParams with only the parameters that apply to this state if\n\t      // necessary. In addition to being available to the controller and onEnter/onExit callbacks,\n\t      // we also need $stateParams to be available for any $injector calls we make during the\n\t      // dependency resolution process.\n\t      var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);\n\t      var locals = { $stateParams: $stateParams };\n\t\n\t      // Resolve 'global' dependencies for the state, i.e. those not specific to a view.\n\t      // We're also including $stateParams in this; that way the parameters are restricted\n\t      // to the set that should be visible to the state, and are independent of when we update\n\t      // the global $state and $stateParams values.\n\t      dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);\n\t      var promises = [dst.resolve.then(function (globals) {\n\t        dst.globals = globals;\n\t      })];\n\t      if (inherited) promises.push(inherited);\n\t\n\t      function resolveViews() {\n\t        var viewsPromises = [];\n\t\n\t        // Resolve template and dependencies for all views.\n\t        forEach(state.views, function (view, name) {\n\t          var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});\n\t          injectables.$template = [ function () {\n\t            return $view.load(name, { view: view, locals: dst.globals, params: $stateParams, notify: options.notify }) || '';\n\t          }];\n\t\n\t          viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function (result) {\n\t            // References to the controller (only instantiated at link time)\n\t            if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {\n\t              var injectLocals = angular.extend({}, injectables, dst.globals);\n\t              result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);\n\t            } else {\n\t              result.$$controller = view.controller;\n\t            }\n\t            // Provide access to the state itself for internal use\n\t            result.$$state = state;\n\t            result.$$controllerAs = view.controllerAs;\n\t            result.$$resolveAs = view.resolveAs;\n\t            dst[name] = result;\n\t          }));\n\t        });\n\t\n\t        return $q.all(viewsPromises).then(function(){\n\t          return dst.globals;\n\t        });\n\t      }\n\t\n\t      // Wait for all the promises and then return the activation object\n\t      return $q.all(promises).then(resolveViews).then(function (values) {\n\t        return dst;\n\t      });\n\t    }\n\t\n\t    return $state;\n\t  }\n\t\n\t  function shouldSkipReload(to, toParams, from, fromParams, locals, options) {\n\t    // Return true if there are no differences in non-search (path/object) params, false if there are differences\n\t    function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {\n\t      // Identify whether all the parameters that differ between `fromParams` and `toParams` were search params.\n\t      function notSearchParam(key) {\n\t        return fromAndToState.params[key].location != \"search\";\n\t      }\n\t      var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);\n\t      var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));\n\t      var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);\n\t      return nonQueryParamSet.$$equals(fromParams, toParams);\n\t    }\n\t\n\t    // If reload was not explicitly requested\n\t    // and we're transitioning to the same state we're already in\n\t    // and    the locals didn't change\n\t    //     or they changed in a way that doesn't merit reloading\n\t    //        (reloadOnParams:false, or reloadOnSearch.false and only search params changed)\n\t    // Then return true.\n\t    if (!options.reload && to === from &&\n\t      (locals === from.locals || (to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams)))) {\n\t      return true;\n\t    }\n\t  }\n\t}\n\t\n\tangular.module('ui.router.state')\n\t  .factory('$stateParams', function () { return {}; })\n\t  .constant(\"$state.runtime\", { autoinject: true })\n\t  .provider('$state', $StateProvider)\n\t  // Inject $state to initialize when entering runtime. #2574\n\t  .run(['$injector', function ($injector) {\n\t    // Allow tests (stateSpec.js) to turn this off by defining this constant\n\t    if ($injector.get(\"$state.runtime\").autoinject) {\n\t      $injector.get('$state');\n\t    }\n\t  }]);\n\t\n\t\n\t$ViewProvider.$inject = [];\n\tfunction $ViewProvider() {\n\t\n\t  this.$get = $get;\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.state.$view\n\t   *\n\t   * @requires ui.router.util.$templateFactory\n\t   * @requires $rootScope\n\t   *\n\t   * @description\n\t   *\n\t   */\n\t  $get.$inject = ['$rootScope', '$templateFactory'];\n\t  function $get(   $rootScope,   $templateFactory) {\n\t    return {\n\t      // $view.load('full.viewName', { template: ..., controller: ..., resolve: ..., async: false, params: ... })\n\t      /**\n\t       * @ngdoc function\n\t       * @name ui.router.state.$view#load\n\t       * @methodOf ui.router.state.$view\n\t       *\n\t       * @description\n\t       *\n\t       * @param {string} name name\n\t       * @param {object} options option object.\n\t       */\n\t      load: function load(name, options) {\n\t        var result, defaults = {\n\t          template: null, controller: null, view: null, locals: null, notify: true, async: true, params: {}\n\t        };\n\t        options = extend(defaults, options);\n\t\n\t        if (options.view) {\n\t          result = $templateFactory.fromConfig(options.view, options.params, options.locals);\n\t        }\n\t        return result;\n\t      }\n\t    };\n\t  }\n\t}\n\t\n\tangular.module('ui.router.state').provider('$view', $ViewProvider);\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.state.$uiViewScrollProvider\n\t *\n\t * @description\n\t * Provider that returns the {@link ui.router.state.$uiViewScroll} service function.\n\t */\n\tfunction $ViewScrollProvider() {\n\t\n\t  var useAnchorScroll = false;\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.state.$uiViewScrollProvider#useAnchorScroll\n\t   * @methodOf ui.router.state.$uiViewScrollProvider\n\t   *\n\t   * @description\n\t   * Reverts back to using the core [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll) service for\n\t   * scrolling based on the url anchor.\n\t   */\n\t  this.useAnchorScroll = function () {\n\t    useAnchorScroll = true;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.state.$uiViewScroll\n\t   *\n\t   * @requires $anchorScroll\n\t   * @requires $timeout\n\t   *\n\t   * @description\n\t   * When called with a jqLite element, it scrolls the element into view (after a\n\t   * `$timeout` so the DOM has time to refresh).\n\t   *\n\t   * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,\n\t   * this can be enabled by calling {@link ui.router.state.$uiViewScrollProvider#methods_useAnchorScroll `$uiViewScrollProvider.useAnchorScroll()`}.\n\t   */\n\t  this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {\n\t    if (useAnchorScroll) {\n\t      return $anchorScroll;\n\t    }\n\t\n\t    return function ($element) {\n\t      return $timeout(function () {\n\t        $element[0].scrollIntoView();\n\t      }, 0, false);\n\t    };\n\t  }];\n\t}\n\t\n\tangular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.router.state.directive:ui-view\n\t *\n\t * @requires ui.router.state.$state\n\t * @requires $compile\n\t * @requires $controller\n\t * @requires $injector\n\t * @requires ui.router.state.$uiViewScroll\n\t * @requires $document\n\t *\n\t * @restrict ECA\n\t *\n\t * @description\n\t * The ui-view directive tells $state where to place your templates.\n\t *\n\t * @param {string=} name A view name. The name should be unique amongst the other views in the\n\t * same state. You can have views of the same name that live in different states.\n\t *\n\t * @param {string=} autoscroll It allows you to set the scroll behavior of the browser window\n\t * when a view is populated. By default, $anchorScroll is overridden by ui-router's custom scroll\n\t * service, {@link ui.router.state.$uiViewScroll}. This custom service let's you\n\t * scroll ui-view elements into view when they are populated during a state activation.\n\t *\n\t * *Note: To revert back to old [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll)\n\t * functionality, call `$uiViewScrollProvider.useAnchorScroll()`.*\n\t *\n\t * @param {string=} onload Expression to evaluate whenever the view updates.\n\t *\n\t * @example\n\t * A view can be unnamed or named.\n\t * <pre>\n\t * <!-- Unnamed -->\n\t * <div ui-view></div>\n\t *\n\t * <!-- Named -->\n\t * <div ui-view=\"viewName\"></div>\n\t * </pre>\n\t *\n\t * You can only have one unnamed view within any template (or root html). If you are only using a\n\t * single view and it is unnamed then you can populate it like so:\n\t * <pre>\n\t * <div ui-view></div>\n\t * $stateProvider.state(\"home\", {\n\t *   template: \"<h1>HELLO!</h1>\"\n\t * })\n\t * </pre>\n\t *\n\t * The above is a convenient shortcut equivalent to specifying your view explicitly with the {@link ui.router.state.$stateProvider#methods_state `views`}\n\t * config property, by name, in this case an empty name:\n\t * <pre>\n\t * $stateProvider.state(\"home\", {\n\t *   views: {\n\t *     \"\": {\n\t *       template: \"<h1>HELLO!</h1>\"\n\t *     }\n\t *   }    \n\t * })\n\t * </pre>\n\t *\n\t * But typically you'll only use the views property if you name your view or have more than one view\n\t * in the same template. There's not really a compelling reason to name a view if its the only one,\n\t * but you could if you wanted, like so:\n\t * <pre>\n\t * <div ui-view=\"main\"></div>\n\t * </pre>\n\t * <pre>\n\t * $stateProvider.state(\"home\", {\n\t *   views: {\n\t *     \"main\": {\n\t *       template: \"<h1>HELLO!</h1>\"\n\t *     }\n\t *   }    \n\t * })\n\t * </pre>\n\t *\n\t * Really though, you'll use views to set up multiple views:\n\t * <pre>\n\t * <div ui-view></div>\n\t * <div ui-view=\"chart\"></div>\n\t * <div ui-view=\"data\"></div>\n\t * </pre>\n\t *\n\t * <pre>\n\t * $stateProvider.state(\"home\", {\n\t *   views: {\n\t *     \"\": {\n\t *       template: \"<h1>HELLO!</h1>\"\n\t *     },\n\t *     \"chart\": {\n\t *       template: \"<chart_thing/>\"\n\t *     },\n\t *     \"data\": {\n\t *       template: \"<data_thing/>\"\n\t *     }\n\t *   }    \n\t * })\n\t * </pre>\n\t *\n\t * Examples for `autoscroll`:\n\t *\n\t * <pre>\n\t * <!-- If autoscroll present with no expression,\n\t *      then scroll ui-view into view -->\n\t * <ui-view autoscroll/>\n\t *\n\t * <!-- If autoscroll present with valid expression,\n\t *      then scroll ui-view into view if expression evaluates to true -->\n\t * <ui-view autoscroll='true'/>\n\t * <ui-view autoscroll='false'/>\n\t * <ui-view autoscroll='scopeVariable'/>\n\t * </pre>\n\t *\n\t * Resolve data:\n\t *\n\t * The resolved data from the state's `resolve` block is placed on the scope as `$resolve` (this\n\t * can be customized using [[ViewDeclaration.resolveAs]]).  This can be then accessed from the template.\n\t *\n\t * Note that when `controllerAs` is being used, `$resolve` is set on the controller instance *after* the\n\t * controller is instantiated.  The `$onInit()` hook can be used to perform initialization code which\n\t * depends on `$resolve` data.\n\t *\n\t * Example usage of $resolve in a view template\n\t * <pre>\n\t * $stateProvider.state('home', {\n\t *   template: '<my-component user=\"$resolve.user\"></my-component>',\n\t *   resolve: {\n\t *     user: function(UserService) { return UserService.fetchUser(); }\n\t *   }\n\t * });\n\t * </pre>\n\t */\n\t$ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate', '$q'];\n\tfunction $ViewDirective(   $state,   $injector,   $uiViewScroll,   $interpolate,   $q) {\n\t\n\t  function getService() {\n\t    return ($injector.has) ? function(service) {\n\t      return $injector.has(service) ? $injector.get(service) : null;\n\t    } : function(service) {\n\t      try {\n\t        return $injector.get(service);\n\t      } catch (e) {\n\t        return null;\n\t      }\n\t    };\n\t  }\n\t\n\t  var service = getService(),\n\t      $animator = service('$animator'),\n\t      $animate = service('$animate');\n\t\n\t  // Returns a set of DOM manipulation functions based on which Angular version\n\t  // it should use\n\t  function getRenderer(attrs, scope) {\n\t    var statics = function() {\n\t      return {\n\t        enter: function (element, target, cb) { target.after(element); cb(); },\n\t        leave: function (element, cb) { element.remove(); cb(); }\n\t      };\n\t    };\n\t\n\t    if ($animate) {\n\t      return {\n\t        enter: function(element, target, cb) {\n\t          if (angular.version.minor > 2) {\n\t            $animate.enter(element, null, target).then(cb);\n\t          } else {\n\t            $animate.enter(element, null, target, cb);\n\t          }\n\t        },\n\t        leave: function(element, cb) {\n\t          if (angular.version.minor > 2) {\n\t            $animate.leave(element).then(cb);\n\t          } else {\n\t            $animate.leave(element, cb);\n\t          }\n\t        }\n\t      };\n\t    }\n\t\n\t    if ($animator) {\n\t      var animate = $animator && $animator(scope, attrs);\n\t\n\t      return {\n\t        enter: function(element, target, cb) {animate.enter(element, null, target); cb(); },\n\t        leave: function(element, cb) { animate.leave(element); cb(); }\n\t      };\n\t    }\n\t\n\t    return statics();\n\t  }\n\t\n\t  var directive = {\n\t    restrict: 'ECA',\n\t    terminal: true,\n\t    priority: 400,\n\t    transclude: 'element',\n\t    compile: function (tElement, tAttrs, $transclude) {\n\t      return function (scope, $element, attrs) {\n\t        var previousEl, currentEl, currentScope, latestLocals,\n\t            onloadExp     = attrs.onload || '',\n\t            autoScrollExp = attrs.autoscroll,\n\t            renderer      = getRenderer(attrs, scope),\n\t            inherited     = $element.inheritedData('$uiView');\n\t\n\t        scope.$on('$stateChangeSuccess', function() {\n\t          updateView(false);\n\t        });\n\t\n\t        updateView(true);\n\t\n\t        function cleanupLastView() {\n\t          if (previousEl) {\n\t            previousEl.remove();\n\t            previousEl = null;\n\t          }\n\t\n\t          if (currentScope) {\n\t            currentScope.$destroy();\n\t            currentScope = null;\n\t          }\n\t\n\t          if (currentEl) {\n\t            var $uiViewData = currentEl.data('$uiViewAnim');\n\t            renderer.leave(currentEl, function() {\n\t              $uiViewData.$$animLeave.resolve();\n\t              previousEl = null;\n\t            });\n\t\n\t            previousEl = currentEl;\n\t            currentEl = null;\n\t          }\n\t        }\n\t\n\t        function updateView(firstTime) {\n\t          var newScope,\n\t              name            = getUiViewName(scope, attrs, $element, $interpolate),\n\t              previousLocals  = name && $state.$current && $state.$current.locals[name];\n\t\n\t          if (!firstTime && previousLocals === latestLocals) return; // nothing to do\n\t          newScope = scope.$new();\n\t          latestLocals = $state.$current.locals[name];\n\t\n\t          /**\n\t           * @ngdoc event\n\t           * @name ui.router.state.directive:ui-view#$viewContentLoading\n\t           * @eventOf ui.router.state.directive:ui-view\n\t           * @eventType emits on ui-view directive scope\n\t           * @description\n\t           *\n\t           * Fired once the view **begins loading**, *before* the DOM is rendered.\n\t           *\n\t           * @param {Object} event Event object.\n\t           * @param {string} viewName Name of the view.\n\t           */\n\t          newScope.$emit('$viewContentLoading', name);\n\t\n\t          var clone = $transclude(newScope, function(clone) {\n\t            var animEnter = $q.defer(), animLeave = $q.defer();\n\t            var viewAnimData = {\n\t              $animEnter: animEnter.promise,\n\t              $animLeave: animLeave.promise,\n\t              $$animLeave: animLeave\n\t            };\n\t\n\t            clone.data('$uiViewAnim', viewAnimData);\n\t            renderer.enter(clone, $element, function onUiViewEnter() {\n\t              animEnter.resolve();\n\t              if(currentScope) {\n\t                currentScope.$emit('$viewContentAnimationEnded');\n\t              }\n\t\n\t              if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {\n\t                $uiViewScroll(clone);\n\t              }\n\t            });\n\t            cleanupLastView();\n\t          });\n\t\n\t          currentEl = clone;\n\t          currentScope = newScope;\n\t          /**\n\t           * @ngdoc event\n\t           * @name ui.router.state.directive:ui-view#$viewContentLoaded\n\t           * @eventOf ui.router.state.directive:ui-view\n\t           * @eventType emits on ui-view directive scope\n\t           * @description\n\t           * Fired once the view is **loaded**, *after* the DOM is rendered.\n\t           *\n\t           * @param {Object} event Event object.\n\t           * @param {string} viewName Name of the view.\n\t           */\n\t          currentScope.$emit('$viewContentLoaded', name);\n\t          currentScope.$eval(onloadExp);\n\t        }\n\t      };\n\t    }\n\t  };\n\t\n\t  return directive;\n\t}\n\t\n\t$ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];\n\tfunction $ViewDirectiveFill (  $compile,   $controller,   $state,   $interpolate) {\n\t  return {\n\t    restrict: 'ECA',\n\t    priority: -400,\n\t    compile: function (tElement) {\n\t      var initial = tElement.html();\n\t      return function (scope, $element, attrs) {\n\t        var current = $state.$current,\n\t            name = getUiViewName(scope, attrs, $element, $interpolate),\n\t            locals  = current && current.locals[name];\n\t\n\t        if (! locals) {\n\t          return;\n\t        }\n\t\n\t        $element.data('$uiView', { name: name, state: locals.$$state });\n\t        $element.html(locals.$template ? locals.$template : initial);\n\t\n\t        var resolveData = angular.extend({}, locals);\n\t        scope[locals.$$resolveAs] = resolveData;\n\t\n\t        var link = $compile($element.contents());\n\t\n\t        if (locals.$$controller) {\n\t          locals.$scope = scope;\n\t          locals.$element = $element;\n\t          var controller = $controller(locals.$$controller, locals);\n\t          if (locals.$$controllerAs) {\n\t            scope[locals.$$controllerAs] = controller;\n\t            scope[locals.$$controllerAs][locals.$$resolveAs] = resolveData;\n\t          }\n\t          if (isFunction(controller.$onInit)) controller.$onInit();\n\t          $element.data('$ngControllerController', controller);\n\t          $element.children().data('$ngControllerController', controller);\n\t        }\n\t\n\t        link(scope);\n\t      };\n\t    }\n\t  };\n\t}\n\t\n\t/**\n\t * Shared ui-view code for both directives:\n\t * Given scope, element, and its attributes, return the view's name\n\t */\n\tfunction getUiViewName(scope, attrs, element, $interpolate) {\n\t  var name = $interpolate(attrs.uiView || attrs.name || '')(scope);\n\t  var uiViewCreatedBy = element.inheritedData('$uiView');\n\t  return name.indexOf('@') >= 0 ?  name :  (name + '@' + (uiViewCreatedBy ? uiViewCreatedBy.state.name : ''));\n\t}\n\t\n\tangular.module('ui.router.state').directive('uiView', $ViewDirective);\n\tangular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);\n\t\n\tfunction parseStateRef(ref, current) {\n\t  var preparsed = ref.match(/^\\s*({[^}]*})\\s*$/), parsed;\n\t  if (preparsed) ref = current + '(' + preparsed[1] + ')';\n\t  parsed = ref.replace(/\\n/g, \" \").match(/^([^(]+?)\\s*(\\((.*)\\))?$/);\n\t  if (!parsed || parsed.length !== 4) throw new Error(\"Invalid state ref '\" + ref + \"'\");\n\t  return { state: parsed[1], paramExpr: parsed[3] || null };\n\t}\n\t\n\tfunction stateContext(el) {\n\t  var stateData = el.parent().inheritedData('$uiView');\n\t\n\t  if (stateData && stateData.state && stateData.state.name) {\n\t    return stateData.state;\n\t  }\n\t}\n\t\n\tfunction getTypeInfo(el) {\n\t  // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.\n\t  var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';\n\t  var isForm = el[0].nodeName === \"FORM\";\n\t\n\t  return {\n\t    attr: isForm ? \"action\" : (isSvg ? 'xlink:href' : 'href'),\n\t    isAnchor: el.prop(\"tagName\").toUpperCase() === \"A\",\n\t    clickable: !isForm\n\t  };\n\t}\n\t\n\tfunction clickHook(el, $state, $timeout, type, current) {\n\t  return function(e) {\n\t    var button = e.which || e.button, target = current();\n\t\n\t    if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {\n\t      // HACK: This is to allow ng-clicks to be processed before the transition is initiated:\n\t      var transition = $timeout(function() {\n\t        $state.go(target.state, target.params, target.options);\n\t      });\n\t      e.preventDefault();\n\t\n\t      // if the state has no URL, ignore one preventDefault from the <a> directive.\n\t      var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1: 0;\n\t\n\t      e.preventDefault = function() {\n\t        if (ignorePreventDefaultCount-- <= 0) $timeout.cancel(transition);\n\t      };\n\t    }\n\t  };\n\t}\n\t\n\tfunction defaultOpts(el, $state) {\n\t  return { relative: stateContext(el) || $state.$current, inherit: true };\n\t}\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.router.state.directive:ui-sref\n\t *\n\t * @requires ui.router.state.$state\n\t * @requires $timeout\n\t *\n\t * @restrict A\n\t *\n\t * @description\n\t * A directive that binds a link (`<a>` tag) to a state. If the state has an associated\n\t * URL, the directive will automatically generate & update the `href` attribute via\n\t * the {@link ui.router.state.$state#methods_href $state.href()} method. Clicking\n\t * the link will trigger a state transition with optional parameters.\n\t *\n\t * Also middle-clicking, right-clicking, and ctrl-clicking on the link will be\n\t * handled natively by the browser.\n\t *\n\t * You can also use relative state paths within ui-sref, just like the relative\n\t * paths passed to `$state.go()`. You just need to be aware that the path is relative\n\t * to the state that the link lives in, in other words the state that loaded the\n\t * template containing the link.\n\t *\n\t * You can specify options to pass to {@link ui.router.state.$state#methods_go $state.go()}\n\t * using the `ui-sref-opts` attribute. Options are restricted to `location`, `inherit`,\n\t * and `reload`.\n\t *\n\t * @example\n\t * Here's an example of how you'd use ui-sref and how it would compile. If you have the\n\t * following template:\n\t * <pre>\n\t * <a ui-sref=\"home\">Home</a> | <a ui-sref=\"about\">About</a> | <a ui-sref=\"{page: 2}\">Next page</a>\n\t *\n\t * <ul>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a ui-sref=\"contacts.detail({ id: contact.id })\">{{ contact.name }}</a>\n\t *     </li>\n\t * </ul>\n\t * </pre>\n\t *\n\t * Then the compiled html would be (assuming Html5Mode is off and current state is contacts):\n\t * <pre>\n\t * <a href=\"#/home\" ui-sref=\"home\">Home</a> | <a href=\"#/about\" ui-sref=\"about\">About</a> | <a href=\"#/contacts?page=2\" ui-sref=\"{page: 2}\">Next page</a>\n\t *\n\t * <ul>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a href=\"#/contacts/1\" ui-sref=\"contacts.detail({ id: contact.id })\">Joe</a>\n\t *     </li>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a href=\"#/contacts/2\" ui-sref=\"contacts.detail({ id: contact.id })\">Alice</a>\n\t *     </li>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a href=\"#/contacts/3\" ui-sref=\"contacts.detail({ id: contact.id })\">Bob</a>\n\t *     </li>\n\t * </ul>\n\t *\n\t * <a ui-sref=\"home\" ui-sref-opts=\"{reload: true}\">Home</a>\n\t * </pre>\n\t *\n\t * @param {string} ui-sref 'stateName' can be any valid absolute or relative state\n\t * @param {Object} ui-sref-opts options to pass to {@link ui.router.state.$state#methods_go $state.go()}\n\t */\n\t$StateRefDirective.$inject = ['$state', '$timeout'];\n\tfunction $StateRefDirective($state, $timeout) {\n\t  return {\n\t    restrict: 'A',\n\t    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n\t    link: function(scope, element, attrs, uiSrefActive) {\n\t      var ref    = parseStateRef(attrs.uiSref, $state.current.name);\n\t      var def    = { state: ref.state, href: null, params: null };\n\t      var type   = getTypeInfo(element);\n\t      var active = uiSrefActive[1] || uiSrefActive[0];\n\t      var unlinkInfoFn = null;\n\t      var hookFn;\n\t\n\t      def.options = extend(defaultOpts(element, $state), attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {});\n\t\n\t      var update = function(val) {\n\t        if (val) def.params = angular.copy(val);\n\t        def.href = $state.href(ref.state, def.params, def.options);\n\t\n\t        if (unlinkInfoFn) unlinkInfoFn();\n\t        if (active) unlinkInfoFn = active.$$addStateInfo(ref.state, def.params);\n\t        if (def.href !== null) attrs.$set(type.attr, def.href);\n\t      };\n\t\n\t      if (ref.paramExpr) {\n\t        scope.$watch(ref.paramExpr, function(val) { if (val !== def.params) update(val); }, true);\n\t        def.params = angular.copy(scope.$eval(ref.paramExpr));\n\t      }\n\t      update();\n\t\n\t      if (!type.clickable) return;\n\t      hookFn = clickHook(element, $state, $timeout, type, function() { return def; });\n\t      element.bind(\"click\", hookFn);\n\t      scope.$on('$destroy', function() {\n\t        element.unbind(\"click\", hookFn);\n\t      });\n\t    }\n\t  };\n\t}\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.router.state.directive:ui-state\n\t *\n\t * @requires ui.router.state.uiSref\n\t *\n\t * @restrict A\n\t *\n\t * @description\n\t * Much like ui-sref, but will accept named $scope properties to evaluate for a state definition,\n\t * params and override options.\n\t *\n\t * @param {string} ui-state 'stateName' can be any valid absolute or relative state\n\t * @param {Object} ui-state-params params to pass to {@link ui.router.state.$state#methods_href $state.href()}\n\t * @param {Object} ui-state-opts options to pass to {@link ui.router.state.$state#methods_go $state.go()}\n\t */\n\t$StateRefDynamicDirective.$inject = ['$state', '$timeout'];\n\tfunction $StateRefDynamicDirective($state, $timeout) {\n\t  return {\n\t    restrict: 'A',\n\t    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n\t    link: function(scope, element, attrs, uiSrefActive) {\n\t      var type   = getTypeInfo(element);\n\t      var active = uiSrefActive[1] || uiSrefActive[0];\n\t      var group  = [attrs.uiState, attrs.uiStateParams || null, attrs.uiStateOpts || null];\n\t      var watch  = '[' + group.map(function(val) { return val || 'null'; }).join(', ') + ']';\n\t      var def    = { state: null, params: null, options: null, href: null };\n\t      var unlinkInfoFn = null;\n\t      var hookFn;\n\t\n\t      function runStateRefLink (group) {\n\t        def.state = group[0]; def.params = group[1]; def.options = group[2];\n\t        def.href = $state.href(def.state, def.params, def.options);\n\t\n\t        if (unlinkInfoFn) unlinkInfoFn();\n\t        if (active) unlinkInfoFn = active.$$addStateInfo(def.state, def.params);\n\t        if (def.href) attrs.$set(type.attr, def.href);\n\t      }\n\t\n\t      scope.$watch(watch, runStateRefLink, true);\n\t      runStateRefLink(scope.$eval(watch));\n\t\n\t      if (!type.clickable) return;\n\t      hookFn = clickHook(element, $state, $timeout, type, function() { return def; });\n\t      element.bind(\"click\", hookFn);\n\t      scope.$on('$destroy', function() {\n\t        element.unbind(\"click\", hookFn);\n\t      });\n\t    }\n\t  };\n\t}\n\t\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.router.state.directive:ui-sref-active\n\t *\n\t * @requires ui.router.state.$state\n\t * @requires ui.router.state.$stateParams\n\t * @requires $interpolate\n\t *\n\t * @restrict A\n\t *\n\t * @description\n\t * A directive working alongside ui-sref to add classes to an element when the\n\t * related ui-sref directive's state is active, and removing them when it is inactive.\n\t * The primary use-case is to simplify the special appearance of navigation menus\n\t * relying on `ui-sref`, by having the \"active\" state's menu button appear different,\n\t * distinguishing it from the inactive menu items.\n\t *\n\t * ui-sref-active can live on the same element as ui-sref or on a parent element. The first\n\t * ui-sref-active found at the same level or above the ui-sref will be used.\n\t *\n\t * Will activate when the ui-sref's target state or any child state is active. If you\n\t * need to activate only when the ui-sref target state is active and *not* any of\n\t * it's children, then you will use\n\t * {@link ui.router.state.directive:ui-sref-active-eq ui-sref-active-eq}\n\t *\n\t * @example\n\t * Given the following template:\n\t * <pre>\n\t * <ul>\n\t *   <li ui-sref-active=\"active\" class=\"item\">\n\t *     <a href ui-sref=\"app.user({user: 'bilbobaggins'})\">@bilbobaggins</a>\n\t *   </li>\n\t * </ul>\n\t * </pre>\n\t *\n\t *\n\t * When the app state is \"app.user\" (or any children states), and contains the state parameter \"user\" with value \"bilbobaggins\",\n\t * the resulting HTML will appear as (note the 'active' class):\n\t * <pre>\n\t * <ul>\n\t *   <li ui-sref-active=\"active\" class=\"item active\">\n\t *     <a ui-sref=\"app.user({user: 'bilbobaggins'})\" href=\"/users/bilbobaggins\">@bilbobaggins</a>\n\t *   </li>\n\t * </ul>\n\t * </pre>\n\t *\n\t * The class name is interpolated **once** during the directives link time (any further changes to the\n\t * interpolated value are ignored).\n\t *\n\t * Multiple classes may be specified in a space-separated format:\n\t * <pre>\n\t * <ul>\n\t *   <li ui-sref-active='class1 class2 class3'>\n\t *     <a ui-sref=\"app.user\">link</a>\n\t *   </li>\n\t * </ul>\n\t * </pre>\n\t *\n\t * It is also possible to pass ui-sref-active an expression that evaluates\n\t * to an object hash, whose keys represent active class names and whose\n\t * values represent the respective state names/globs.\n\t * ui-sref-active will match if the current active state **includes** any of\n\t * the specified state names/globs, even the abstract ones.\n\t *\n\t * @Example\n\t * Given the following template, with \"admin\" being an abstract state:\n\t * <pre>\n\t * <div ui-sref-active=\"{'active': 'admin.*'}\">\n\t *   <a ui-sref-active=\"active\" ui-sref=\"admin.roles\">Roles</a>\n\t * </div>\n\t * </pre>\n\t *\n\t * When the current state is \"admin.roles\" the \"active\" class will be applied\n\t * to both the <div> and <a> elements. It is important to note that the state\n\t * names/globs passed to ui-sref-active shadow the state provided by ui-sref.\n\t */\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.router.state.directive:ui-sref-active-eq\n\t *\n\t * @requires ui.router.state.$state\n\t * @requires ui.router.state.$stateParams\n\t * @requires $interpolate\n\t *\n\t * @restrict A\n\t *\n\t * @description\n\t * The same as {@link ui.router.state.directive:ui-sref-active ui-sref-active} but will only activate\n\t * when the exact target state used in the `ui-sref` is active; no child states.\n\t *\n\t */\n\t$StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];\n\tfunction $StateRefActiveDirective($state, $stateParams, $interpolate) {\n\t  return  {\n\t    restrict: \"A\",\n\t    controller: ['$scope', '$element', '$attrs', '$timeout', function ($scope, $element, $attrs, $timeout) {\n\t      var states = [], activeClasses = {}, activeEqClass, uiSrefActive;\n\t\n\t      // There probably isn't much point in $observing this\n\t      // uiSrefActive and uiSrefActiveEq share the same directive object with some\n\t      // slight difference in logic routing\n\t      activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);\n\t\n\t      try {\n\t        uiSrefActive = $scope.$eval($attrs.uiSrefActive);\n\t      } catch (e) {\n\t        // Do nothing. uiSrefActive is not a valid expression.\n\t        // Fall back to using $interpolate below\n\t      }\n\t      uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);\n\t      if (isObject(uiSrefActive)) {\n\t        forEach(uiSrefActive, function(stateOrName, activeClass) {\n\t          if (isString(stateOrName)) {\n\t            var ref = parseStateRef(stateOrName, $state.current.name);\n\t            addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);\n\t          }\n\t        });\n\t      }\n\t\n\t      // Allow uiSref to communicate with uiSrefActive[Equals]\n\t      this.$$addStateInfo = function (newState, newParams) {\n\t        // we already got an explicit state provided by ui-sref-active, so we\n\t        // shadow the one that comes from ui-sref\n\t        if (isObject(uiSrefActive) && states.length > 0) {\n\t          return;\n\t        }\n\t        var deregister = addState(newState, newParams, uiSrefActive);\n\t        update();\n\t        return deregister;\n\t      };\n\t\n\t      $scope.$on('$stateChangeSuccess', update);\n\t\n\t      function addState(stateName, stateParams, activeClass) {\n\t        var state = $state.get(stateName, stateContext($element));\n\t        var stateHash = createStateHash(stateName, stateParams);\n\t\n\t        var stateInfo = {\n\t          state: state || { name: stateName },\n\t          params: stateParams,\n\t          hash: stateHash\n\t        };\n\t\n\t        states.push(stateInfo);\n\t        activeClasses[stateHash] = activeClass;\n\t\n\t        return function removeState() {\n\t          var idx = states.indexOf(stateInfo);\n\t          if (idx !== -1) states.splice(idx, 1);\n\t        };\n\t      }\n\t\n\t      /**\n\t       * @param {string} state\n\t       * @param {Object|string} [params]\n\t       * @return {string}\n\t       */\n\t      function createStateHash(state, params) {\n\t        if (!isString(state)) {\n\t          throw new Error('state should be a string');\n\t        }\n\t        if (isObject(params)) {\n\t          return state + toJson(params);\n\t        }\n\t        params = $scope.$eval(params);\n\t        if (isObject(params)) {\n\t          return state + toJson(params);\n\t        }\n\t        return state;\n\t      }\n\t\n\t      // Update route state\n\t      function update() {\n\t        for (var i = 0; i < states.length; i++) {\n\t          if (anyMatch(states[i].state, states[i].params)) {\n\t            addClass($element, activeClasses[states[i].hash]);\n\t          } else {\n\t            removeClass($element, activeClasses[states[i].hash]);\n\t          }\n\t\n\t          if (exactMatch(states[i].state, states[i].params)) {\n\t            addClass($element, activeEqClass);\n\t          } else {\n\t            removeClass($element, activeEqClass);\n\t          }\n\t        }\n\t      }\n\t\n\t      function addClass(el, className) { $timeout(function () { el.addClass(className); }); }\n\t      function removeClass(el, className) { el.removeClass(className); }\n\t      function anyMatch(state, params) { return $state.includes(state.name, params); }\n\t      function exactMatch(state, params) { return $state.is(state.name, params); }\n\t\n\t      update();\n\t    }]\n\t  };\n\t}\n\t\n\tangular.module('ui.router.state')\n\t  .directive('uiSref', $StateRefDirective)\n\t  .directive('uiSrefActive', $StateRefActiveDirective)\n\t  .directive('uiSrefActiveEq', $StateRefActiveDirective)\n\t  .directive('uiState', $StateRefDynamicDirective);\n\t\n\t/**\n\t * @ngdoc filter\n\t * @name ui.router.state.filter:isState\n\t *\n\t * @requires ui.router.state.$state\n\t *\n\t * @description\n\t * Translates to {@link ui.router.state.$state#methods_is $state.is(\"stateName\")}.\n\t */\n\t$IsStateFilter.$inject = ['$state'];\n\tfunction $IsStateFilter($state) {\n\t  var isFilter = function (state, params) {\n\t    return $state.is(state, params);\n\t  };\n\t  isFilter.$stateful = true;\n\t  return isFilter;\n\t}\n\t\n\t/**\n\t * @ngdoc filter\n\t * @name ui.router.state.filter:includedByState\n\t *\n\t * @requires ui.router.state.$state\n\t *\n\t * @description\n\t * Translates to {@link ui.router.state.$state#methods_includes $state.includes('fullOrPartialStateName')}.\n\t */\n\t$IncludedByStateFilter.$inject = ['$state'];\n\tfunction $IncludedByStateFilter($state) {\n\t  var includesFilter = function (state, params, options) {\n\t    return $state.includes(state, params, options);\n\t  };\n\t  includesFilter.$stateful = true;\n\t  return  includesFilter;\n\t}\n\t\n\tangular.module('ui.router.state')\n\t  .filter('isState', $IsStateFilter)\n\t  .filter('includedByState', $IncludedByStateFilter);\n\t})(window, window.angular);\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _angularUiRouter = __webpack_require__(3);\n\t\n\tvar _angularUiRouter2 = _interopRequireDefault(_angularUiRouter);\n\t\n\tvar _angularAnimate = __webpack_require__(5);\n\t\n\tvar _angularAnimate2 = _interopRequireDefault(_angularAnimate);\n\t\n\tvar _angularUiBootstrap = __webpack_require__(7);\n\t\n\tvar _angularUiBootstrap2 = _interopRequireDefault(_angularUiBootstrap);\n\t\n\tvar _weather = __webpack_require__(9);\n\t\n\tvar _weather2 = _interopRequireDefault(_weather);\n\t\n\tvar _weather3 = __webpack_require__(11);\n\t\n\tvar _weather4 = _interopRequireDefault(_weather3);\n\t\n\tvar _weather5 = __webpack_require__(12);\n\t\n\tvar _weather6 = _interopRequireDefault(_weather5);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = _angular2.default.module('appNomin.weather', [_angularUiRouter2.default, _angularAnimate2.default, _angularUiBootstrap2.default, _weather6.default]).config(_weather2.default).controller('WeatherCtrl', _weather4.default).name;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(6);\n\tmodule.exports = 'ngAnimate';\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @license AngularJS v1.5.7\n\t * (c) 2010-2016 Google, Inc. http://angularjs.org\n\t * License: MIT\n\t */\n\t(function(window, angular) {'use strict';\n\t\n\t/* jshint ignore:start */\n\tvar noop        = angular.noop;\n\tvar copy        = angular.copy;\n\tvar extend      = angular.extend;\n\tvar jqLite      = angular.element;\n\tvar forEach     = angular.forEach;\n\tvar isArray     = angular.isArray;\n\tvar isString    = angular.isString;\n\tvar isObject    = angular.isObject;\n\tvar isUndefined = angular.isUndefined;\n\tvar isDefined   = angular.isDefined;\n\tvar isFunction  = angular.isFunction;\n\tvar isElement   = angular.isElement;\n\t\n\tvar ELEMENT_NODE = 1;\n\tvar COMMENT_NODE = 8;\n\t\n\tvar ADD_CLASS_SUFFIX = '-add';\n\tvar REMOVE_CLASS_SUFFIX = '-remove';\n\tvar EVENT_CLASS_PREFIX = 'ng-';\n\tvar ACTIVE_CLASS_SUFFIX = '-active';\n\tvar PREPARE_CLASS_SUFFIX = '-prepare';\n\t\n\tvar NG_ANIMATE_CLASSNAME = 'ng-animate';\n\tvar NG_ANIMATE_CHILDREN_DATA = '$$ngAnimateChildren';\n\t\n\t// Detect proper transitionend/animationend event names.\n\tvar CSS_PREFIX = '', TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;\n\t\n\t// If unprefixed events are not supported but webkit-prefixed are, use the latter.\n\t// Otherwise, just use W3C names, browsers not supporting them at all will just ignore them.\n\t// Note: Chrome implements `window.onwebkitanimationend` and doesn't implement `window.onanimationend`\n\t// but at the same time dispatches the `animationend` event and not `webkitAnimationEnd`.\n\t// Register both events in case `window.onanimationend` is not supported because of that,\n\t// do the same for `transitionend` as Safari is likely to exhibit similar behavior.\n\t// Also, the only modern browser that uses vendor prefixes for transitions/keyframes is webkit\n\t// therefore there is no reason to test anymore for other vendor prefixes:\n\t// http://caniuse.com/#search=transition\n\tif (isUndefined(window.ontransitionend) && isDefined(window.onwebkittransitionend)) {\n\t  CSS_PREFIX = '-webkit-';\n\t  TRANSITION_PROP = 'WebkitTransition';\n\t  TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';\n\t} else {\n\t  TRANSITION_PROP = 'transition';\n\t  TRANSITIONEND_EVENT = 'transitionend';\n\t}\n\t\n\tif (isUndefined(window.onanimationend) && isDefined(window.onwebkitanimationend)) {\n\t  CSS_PREFIX = '-webkit-';\n\t  ANIMATION_PROP = 'WebkitAnimation';\n\t  ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';\n\t} else {\n\t  ANIMATION_PROP = 'animation';\n\t  ANIMATIONEND_EVENT = 'animationend';\n\t}\n\t\n\tvar DURATION_KEY = 'Duration';\n\tvar PROPERTY_KEY = 'Property';\n\tvar DELAY_KEY = 'Delay';\n\tvar TIMING_KEY = 'TimingFunction';\n\tvar ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';\n\tvar ANIMATION_PLAYSTATE_KEY = 'PlayState';\n\tvar SAFE_FAST_FORWARD_DURATION_VALUE = 9999;\n\t\n\tvar ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;\n\tvar ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;\n\tvar TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;\n\tvar TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;\n\t\n\tvar isPromiseLike = function(p) {\n\t  return p && p.then ? true : false;\n\t};\n\t\n\tvar ngMinErr = angular.$$minErr('ng');\n\tfunction assertArg(arg, name, reason) {\n\t  if (!arg) {\n\t    throw ngMinErr('areq', \"Argument '{0}' is {1}\", (name || '?'), (reason || \"required\"));\n\t  }\n\t  return arg;\n\t}\n\t\n\tfunction mergeClasses(a,b) {\n\t  if (!a && !b) return '';\n\t  if (!a) return b;\n\t  if (!b) return a;\n\t  if (isArray(a)) a = a.join(' ');\n\t  if (isArray(b)) b = b.join(' ');\n\t  return a + ' ' + b;\n\t}\n\t\n\tfunction packageStyles(options) {\n\t  var styles = {};\n\t  if (options && (options.to || options.from)) {\n\t    styles.to = options.to;\n\t    styles.from = options.from;\n\t  }\n\t  return styles;\n\t}\n\t\n\tfunction pendClasses(classes, fix, isPrefix) {\n\t  var className = '';\n\t  classes = isArray(classes)\n\t      ? classes\n\t      : classes && isString(classes) && classes.length\n\t          ? classes.split(/\\s+/)\n\t          : [];\n\t  forEach(classes, function(klass, i) {\n\t    if (klass && klass.length > 0) {\n\t      className += (i > 0) ? ' ' : '';\n\t      className += isPrefix ? fix + klass\n\t                            : klass + fix;\n\t    }\n\t  });\n\t  return className;\n\t}\n\t\n\tfunction removeFromArray(arr, val) {\n\t  var index = arr.indexOf(val);\n\t  if (val >= 0) {\n\t    arr.splice(index, 1);\n\t  }\n\t}\n\t\n\tfunction stripCommentsFromElement(element) {\n\t  if (element instanceof jqLite) {\n\t    switch (element.length) {\n\t      case 0:\n\t        return element;\n\t        break;\n\t\n\t      case 1:\n\t        // there is no point of stripping anything if the element\n\t        // is the only element within the jqLite wrapper.\n\t        // (it's important that we retain the element instance.)\n\t        if (element[0].nodeType === ELEMENT_NODE) {\n\t          return element;\n\t        }\n\t        break;\n\t\n\t      default:\n\t        return jqLite(extractElementNode(element));\n\t        break;\n\t    }\n\t  }\n\t\n\t  if (element.nodeType === ELEMENT_NODE) {\n\t    return jqLite(element);\n\t  }\n\t}\n\t\n\tfunction extractElementNode(element) {\n\t  if (!element[0]) return element;\n\t  for (var i = 0; i < element.length; i++) {\n\t    var elm = element[i];\n\t    if (elm.nodeType == ELEMENT_NODE) {\n\t      return elm;\n\t    }\n\t  }\n\t}\n\t\n\tfunction $$addClass($$jqLite, element, className) {\n\t  forEach(element, function(elm) {\n\t    $$jqLite.addClass(elm, className);\n\t  });\n\t}\n\t\n\tfunction $$removeClass($$jqLite, element, className) {\n\t  forEach(element, function(elm) {\n\t    $$jqLite.removeClass(elm, className);\n\t  });\n\t}\n\t\n\tfunction applyAnimationClassesFactory($$jqLite) {\n\t  return function(element, options) {\n\t    if (options.addClass) {\n\t      $$addClass($$jqLite, element, options.addClass);\n\t      options.addClass = null;\n\t    }\n\t    if (options.removeClass) {\n\t      $$removeClass($$jqLite, element, options.removeClass);\n\t      options.removeClass = null;\n\t    }\n\t  }\n\t}\n\t\n\tfunction prepareAnimationOptions(options) {\n\t  options = options || {};\n\t  if (!options.$$prepared) {\n\t    var domOperation = options.domOperation || noop;\n\t    options.domOperation = function() {\n\t      options.$$domOperationFired = true;\n\t      domOperation();\n\t      domOperation = noop;\n\t    };\n\t    options.$$prepared = true;\n\t  }\n\t  return options;\n\t}\n\t\n\tfunction applyAnimationStyles(element, options) {\n\t  applyAnimationFromStyles(element, options);\n\t  applyAnimationToStyles(element, options);\n\t}\n\t\n\tfunction applyAnimationFromStyles(element, options) {\n\t  if (options.from) {\n\t    element.css(options.from);\n\t    options.from = null;\n\t  }\n\t}\n\t\n\tfunction applyAnimationToStyles(element, options) {\n\t  if (options.to) {\n\t    element.css(options.to);\n\t    options.to = null;\n\t  }\n\t}\n\t\n\tfunction mergeAnimationDetails(element, oldAnimation, newAnimation) {\n\t  var target = oldAnimation.options || {};\n\t  var newOptions = newAnimation.options || {};\n\t\n\t  var toAdd = (target.addClass || '') + ' ' + (newOptions.addClass || '');\n\t  var toRemove = (target.removeClass || '') + ' ' + (newOptions.removeClass || '');\n\t  var classes = resolveElementClasses(element.attr('class'), toAdd, toRemove);\n\t\n\t  if (newOptions.preparationClasses) {\n\t    target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);\n\t    delete newOptions.preparationClasses;\n\t  }\n\t\n\t  // noop is basically when there is no callback; otherwise something has been set\n\t  var realDomOperation = target.domOperation !== noop ? target.domOperation : null;\n\t\n\t  extend(target, newOptions);\n\t\n\t  // TODO(matsko or sreeramu): proper fix is to maintain all animation callback in array and call at last,but now only leave has the callback so no issue with this.\n\t  if (realDomOperation) {\n\t    target.domOperation = realDomOperation;\n\t  }\n\t\n\t  if (classes.addClass) {\n\t    target.addClass = classes.addClass;\n\t  } else {\n\t    target.addClass = null;\n\t  }\n\t\n\t  if (classes.removeClass) {\n\t    target.removeClass = classes.removeClass;\n\t  } else {\n\t    target.removeClass = null;\n\t  }\n\t\n\t  oldAnimation.addClass = target.addClass;\n\t  oldAnimation.removeClass = target.removeClass;\n\t\n\t  return target;\n\t}\n\t\n\tfunction resolveElementClasses(existing, toAdd, toRemove) {\n\t  var ADD_CLASS = 1;\n\t  var REMOVE_CLASS = -1;\n\t\n\t  var flags = {};\n\t  existing = splitClassesToLookup(existing);\n\t\n\t  toAdd = splitClassesToLookup(toAdd);\n\t  forEach(toAdd, function(value, key) {\n\t    flags[key] = ADD_CLASS;\n\t  });\n\t\n\t  toRemove = splitClassesToLookup(toRemove);\n\t  forEach(toRemove, function(value, key) {\n\t    flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;\n\t  });\n\t\n\t  var classes = {\n\t    addClass: '',\n\t    removeClass: ''\n\t  };\n\t\n\t  forEach(flags, function(val, klass) {\n\t    var prop, allow;\n\t    if (val === ADD_CLASS) {\n\t      prop = 'addClass';\n\t      allow = !existing[klass];\n\t    } else if (val === REMOVE_CLASS) {\n\t      prop = 'removeClass';\n\t      allow = existing[klass];\n\t    }\n\t    if (allow) {\n\t      if (classes[prop].length) {\n\t        classes[prop] += ' ';\n\t      }\n\t      classes[prop] += klass;\n\t    }\n\t  });\n\t\n\t  function splitClassesToLookup(classes) {\n\t    if (isString(classes)) {\n\t      classes = classes.split(' ');\n\t    }\n\t\n\t    var obj = {};\n\t    forEach(classes, function(klass) {\n\t      // sometimes the split leaves empty string values\n\t      // incase extra spaces were applied to the options\n\t      if (klass.length) {\n\t        obj[klass] = true;\n\t      }\n\t    });\n\t    return obj;\n\t  }\n\t\n\t  return classes;\n\t}\n\t\n\tfunction getDomNode(element) {\n\t  return (element instanceof angular.element) ? element[0] : element;\n\t}\n\t\n\tfunction applyGeneratedPreparationClasses(element, event, options) {\n\t  var classes = '';\n\t  if (event) {\n\t    classes = pendClasses(event, EVENT_CLASS_PREFIX, true);\n\t  }\n\t  if (options.addClass) {\n\t    classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));\n\t  }\n\t  if (options.removeClass) {\n\t    classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));\n\t  }\n\t  if (classes.length) {\n\t    options.preparationClasses = classes;\n\t    element.addClass(classes);\n\t  }\n\t}\n\t\n\tfunction clearGeneratedClasses(element, options) {\n\t  if (options.preparationClasses) {\n\t    element.removeClass(options.preparationClasses);\n\t    options.preparationClasses = null;\n\t  }\n\t  if (options.activeClasses) {\n\t    element.removeClass(options.activeClasses);\n\t    options.activeClasses = null;\n\t  }\n\t}\n\t\n\tfunction blockTransitions(node, duration) {\n\t  // we use a negative delay value since it performs blocking\n\t  // yet it doesn't kill any existing transitions running on the\n\t  // same element which makes this safe for class-based animations\n\t  var value = duration ? '-' + duration + 's' : '';\n\t  applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);\n\t  return [TRANSITION_DELAY_PROP, value];\n\t}\n\t\n\tfunction blockKeyframeAnimations(node, applyBlock) {\n\t  var value = applyBlock ? 'paused' : '';\n\t  var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;\n\t  applyInlineStyle(node, [key, value]);\n\t  return [key, value];\n\t}\n\t\n\tfunction applyInlineStyle(node, styleTuple) {\n\t  var prop = styleTuple[0];\n\t  var value = styleTuple[1];\n\t  node.style[prop] = value;\n\t}\n\t\n\tfunction concatWithSpace(a,b) {\n\t  if (!a) return b;\n\t  if (!b) return a;\n\t  return a + ' ' + b;\n\t}\n\t\n\tvar $$rAFSchedulerFactory = ['$$rAF', function($$rAF) {\n\t  var queue, cancelFn;\n\t\n\t  function scheduler(tasks) {\n\t    // we make a copy since RAFScheduler mutates the state\n\t    // of the passed in array variable and this would be difficult\n\t    // to track down on the outside code\n\t    queue = queue.concat(tasks);\n\t    nextTick();\n\t  }\n\t\n\t  queue = scheduler.queue = [];\n\t\n\t  /* waitUntilQuiet does two things:\n\t   * 1. It will run the FINAL `fn` value only when an uncanceled RAF has passed through\n\t   * 2. It will delay the next wave of tasks from running until the quiet `fn` has run.\n\t   *\n\t   * The motivation here is that animation code can request more time from the scheduler\n\t   * before the next wave runs. This allows for certain DOM properties such as classes to\n\t   * be resolved in time for the next animation to run.\n\t   */\n\t  scheduler.waitUntilQuiet = function(fn) {\n\t    if (cancelFn) cancelFn();\n\t\n\t    cancelFn = $$rAF(function() {\n\t      cancelFn = null;\n\t      fn();\n\t      nextTick();\n\t    });\n\t  };\n\t\n\t  return scheduler;\n\t\n\t  function nextTick() {\n\t    if (!queue.length) return;\n\t\n\t    var items = queue.shift();\n\t    for (var i = 0; i < items.length; i++) {\n\t      items[i]();\n\t    }\n\t\n\t    if (!cancelFn) {\n\t      $$rAF(function() {\n\t        if (!cancelFn) nextTick();\n\t      });\n\t    }\n\t  }\n\t}];\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ngAnimateChildren\n\t * @restrict AE\n\t * @element ANY\n\t *\n\t * @description\n\t *\n\t * ngAnimateChildren allows you to specify that children of this element should animate even if any\n\t * of the children's parents are currently animating. By default, when an element has an active `enter`, `leave`, or `move`\n\t * (structural) animation, child elements that also have an active structural animation are not animated.\n\t *\n\t * Note that even if `ngAnimteChildren` is set, no child animations will run when the parent element is removed from the DOM (`leave` animation).\n\t *\n\t *\n\t * @param {string} ngAnimateChildren If the value is empty, `true` or `on`,\n\t *     then child animations are allowed. If the value is `false`, child animations are not allowed.\n\t *\n\t * @example\n\t * <example module=\"ngAnimateChildren\" name=\"ngAnimateChildren\" deps=\"angular-animate.js\" animations=\"true\">\n\t     <file name=\"index.html\">\n\t       <div ng-controller=\"mainController as main\">\n\t         <label>Show container? <input type=\"checkbox\" ng-model=\"main.enterElement\" /></label>\n\t         <label>Animate children? <input type=\"checkbox\" ng-model=\"main.animateChildren\" /></label>\n\t         <hr>\n\t         <div ng-animate-children=\"{{main.animateChildren}}\">\n\t           <div ng-if=\"main.enterElement\" class=\"container\">\n\t             List of items:\n\t             <div ng-repeat=\"item in [0, 1, 2, 3]\" class=\"item\">Item {{item}}</div>\n\t           </div>\n\t         </div>\n\t       </div>\n\t     </file>\n\t     <file name=\"animations.css\">\n\t\n\t      .container.ng-enter,\n\t      .container.ng-leave {\n\t        transition: all ease 1.5s;\n\t      }\n\t\n\t      .container.ng-enter,\n\t      .container.ng-leave-active {\n\t        opacity: 0;\n\t      }\n\t\n\t      .container.ng-leave,\n\t      .container.ng-enter-active {\n\t        opacity: 1;\n\t      }\n\t\n\t      .item {\n\t        background: firebrick;\n\t        color: #FFF;\n\t        margin-bottom: 10px;\n\t      }\n\t\n\t      .item.ng-enter,\n\t      .item.ng-leave {\n\t        transition: transform 1.5s ease;\n\t      }\n\t\n\t      .item.ng-enter {\n\t        transform: translateX(50px);\n\t      }\n\t\n\t      .item.ng-enter-active {\n\t        transform: translateX(0);\n\t      }\n\t    </file>\n\t    <file name=\"script.js\">\n\t      angular.module('ngAnimateChildren', ['ngAnimate'])\n\t        .controller('mainController', function() {\n\t          this.animateChildren = false;\n\t          this.enterElement = false;\n\t        });\n\t    </file>\n\t  </example>\n\t */\n\tvar $$AnimateChildrenDirective = ['$interpolate', function($interpolate) {\n\t  return {\n\t    link: function(scope, element, attrs) {\n\t      var val = attrs.ngAnimateChildren;\n\t      if (angular.isString(val) && val.length === 0) { //empty attribute\n\t        element.data(NG_ANIMATE_CHILDREN_DATA, true);\n\t      } else {\n\t        // Interpolate and set the value, so that it is available to\n\t        // animations that run right after compilation\n\t        setData($interpolate(val)(scope));\n\t        attrs.$observe('ngAnimateChildren', setData);\n\t      }\n\t\n\t      function setData(value) {\n\t        value = value === 'on' || value === 'true';\n\t        element.data(NG_ANIMATE_CHILDREN_DATA, value);\n\t      }\n\t    }\n\t  };\n\t}];\n\t\n\tvar ANIMATE_TIMER_KEY = '$$animateCss';\n\t\n\t/**\n\t * @ngdoc service\n\t * @name $animateCss\n\t * @kind object\n\t *\n\t * @description\n\t * The `$animateCss` service is a useful utility to trigger customized CSS-based transitions/keyframes\n\t * from a JavaScript-based animation or directly from a directive. The purpose of `$animateCss` is NOT\n\t * to side-step how `$animate` and ngAnimate work, but the goal is to allow pre-existing animations or\n\t * directives to create more complex animations that can be purely driven using CSS code.\n\t *\n\t * Note that only browsers that support CSS transitions and/or keyframe animations are capable of\n\t * rendering animations triggered via `$animateCss` (bad news for IE9 and lower).\n\t *\n\t * ## Usage\n\t * Once again, `$animateCss` is designed to be used inside of a registered JavaScript animation that\n\t * is powered by ngAnimate. It is possible to use `$animateCss` directly inside of a directive, however,\n\t * any automatic control over cancelling animations and/or preventing animations from being run on\n\t * child elements will not be handled by Angular. For this to work as expected, please use `$animate` to\n\t * trigger the animation and then setup a JavaScript animation that injects `$animateCss` to trigger\n\t * the CSS animation.\n\t *\n\t * The example below shows how we can create a folding animation on an element using `ng-if`:\n\t *\n\t * ```html\n\t * <!-- notice the `fold-animation` CSS class -->\n\t * <div ng-if=\"onOff\" class=\"fold-animation\">\n\t *   This element will go BOOM\n\t * </div>\n\t * <button ng-click=\"onOff=true\">Fold In</button>\n\t * ```\n\t *\n\t * Now we create the **JavaScript animation** that will trigger the CSS transition:\n\t *\n\t * ```js\n\t * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {\n\t *   return {\n\t *     enter: function(element, doneFn) {\n\t *       var height = element[0].offsetHeight;\n\t *       return $animateCss(element, {\n\t *         from: { height:'0px' },\n\t *         to: { height:height + 'px' },\n\t *         duration: 1 // one second\n\t *       });\n\t *     }\n\t *   }\n\t * }]);\n\t * ```\n\t *\n\t * ## More Advanced Uses\n\t *\n\t * `$animateCss` is the underlying code that ngAnimate uses to power **CSS-based animations** behind the scenes. Therefore CSS hooks\n\t * like `.ng-EVENT`, `.ng-EVENT-active`, `.ng-EVENT-stagger` are all features that can be triggered using `$animateCss` via JavaScript code.\n\t *\n\t * This also means that just about any combination of adding classes, removing classes, setting styles, dynamically setting a keyframe animation,\n\t * applying a hardcoded duration or delay value, changing the animation easing or applying a stagger animation are all options that work with\n\t * `$animateCss`. The service itself is smart enough to figure out the combination of options and examine the element styling properties in order\n\t * to provide a working animation that will run in CSS.\n\t *\n\t * The example below showcases a more advanced version of the `.fold-animation` from the example above:\n\t *\n\t * ```js\n\t * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {\n\t *   return {\n\t *     enter: function(element, doneFn) {\n\t *       var height = element[0].offsetHeight;\n\t *       return $animateCss(element, {\n\t *         addClass: 'red large-text pulse-twice',\n\t *         easing: 'ease-out',\n\t *         from: { height:'0px' },\n\t *         to: { height:height + 'px' },\n\t *         duration: 1 // one second\n\t *       });\n\t *     }\n\t *   }\n\t * }]);\n\t * ```\n\t *\n\t * Since we're adding/removing CSS classes then the CSS transition will also pick those up:\n\t *\n\t * ```css\n\t * /&#42; since a hardcoded duration value of 1 was provided in the JavaScript animation code,\n\t * the CSS classes below will be transitioned despite them being defined as regular CSS classes &#42;/\n\t * .red { background:red; }\n\t * .large-text { font-size:20px; }\n\t *\n\t * /&#42; we can also use a keyframe animation and $animateCss will make it work alongside the transition &#42;/\n\t * .pulse-twice {\n\t *   animation: 0.5s pulse linear 2;\n\t *   -webkit-animation: 0.5s pulse linear 2;\n\t * }\n\t *\n\t * @keyframes pulse {\n\t *   from { transform: scale(0.5); }\n\t *   to { transform: scale(1.5); }\n\t * }\n\t *\n\t * @-webkit-keyframes pulse {\n\t *   from { -webkit-transform: scale(0.5); }\n\t *   to { -webkit-transform: scale(1.5); }\n\t * }\n\t * ```\n\t *\n\t * Given this complex combination of CSS classes, styles and options, `$animateCss` will figure everything out and make the animation happen.\n\t *\n\t * ## How the Options are handled\n\t *\n\t * `$animateCss` is very versatile and intelligent when it comes to figuring out what configurations to apply to the element to ensure the animation\n\t * works with the options provided. Say for example we were adding a class that contained a keyframe value and we wanted to also animate some inline\n\t * styles using the `from` and `to` properties.\n\t *\n\t * ```js\n\t * var animator = $animateCss(element, {\n\t *   from: { background:'red' },\n\t *   to: { background:'blue' }\n\t * });\n\t * animator.start();\n\t * ```\n\t *\n\t * ```css\n\t * .rotating-animation {\n\t *   animation:0.5s rotate linear;\n\t *   -webkit-animation:0.5s rotate linear;\n\t * }\n\t *\n\t * @keyframes rotate {\n\t *   from { transform: rotate(0deg); }\n\t *   to { transform: rotate(360deg); }\n\t * }\n\t *\n\t * @-webkit-keyframes rotate {\n\t *   from { -webkit-transform: rotate(0deg); }\n\t *   to { -webkit-transform: rotate(360deg); }\n\t * }\n\t * ```\n\t *\n\t * The missing pieces here are that we do not have a transition set (within the CSS code nor within the `$animateCss` options) and the duration of the animation is\n\t * going to be detected from what the keyframe styles on the CSS class are. In this event, `$animateCss` will automatically create an inline transition\n\t * style matching the duration detected from the keyframe style (which is present in the CSS class that is being added) and then prepare both the transition\n\t * and keyframe animations to run in parallel on the element. Then when the animation is underway the provided `from` and `to` CSS styles will be applied\n\t * and spread across the transition and keyframe animation.\n\t *\n\t * ## What is returned\n\t *\n\t * `$animateCss` works in two stages: a preparation phase and an animation phase. Therefore when `$animateCss` is first called it will NOT actually\n\t * start the animation. All that is going on here is that the element is being prepared for the animation (which means that the generated CSS classes are\n\t * added and removed on the element). Once `$animateCss` is called it will return an object with the following properties:\n\t *\n\t * ```js\n\t * var animator = $animateCss(element, { ... });\n\t * ```\n\t *\n\t * Now what do the contents of our `animator` variable look like:\n\t *\n\t * ```js\n\t * {\n\t *   // starts the animation\n\t *   start: Function,\n\t *\n\t *   // ends (aborts) the animation\n\t *   end: Function\n\t * }\n\t * ```\n\t *\n\t * To actually start the animation we need to run `animation.start()` which will then return a promise that we can hook into to detect when the animation ends.\n\t * If we choose not to run the animation then we MUST run `animation.end()` to perform a cleanup on the element (since some CSS classes and styles may have been\n\t * applied to the element during the preparation phase). Note that all other properties such as duration, delay, transitions and keyframes are just properties\n\t * and that changing them will not reconfigure the parameters of the animation.\n\t *\n\t * ### runner.done() vs runner.then()\n\t * It is documented that `animation.start()` will return a promise object and this is true, however, there is also an additional method available on the\n\t * runner called `.done(callbackFn)`. The done method works the same as `.finally(callbackFn)`, however, it does **not trigger a digest to occur**.\n\t * Therefore, for performance reasons, it's always best to use `runner.done(callback)` instead of `runner.then()`, `runner.catch()` or `runner.finally()`\n\t * unless you really need a digest to kick off afterwards.\n\t *\n\t * Keep in mind that, to make this easier, ngAnimate has tweaked the JS animations API to recognize when a runner instance is returned from $animateCss\n\t * (so there is no need to call `runner.done(doneFn)` inside of your JavaScript animation code).\n\t * Check the {@link ngAnimate.$animateCss#usage animation code above} to see how this works.\n\t *\n\t * @param {DOMElement} element the element that will be animated\n\t * @param {object} options the animation-related options that will be applied during the animation\n\t *\n\t * * `event` - The DOM event (e.g. enter, leave, move). When used, a generated CSS class of `ng-EVENT` and `ng-EVENT-active` will be applied\n\t * to the element during the animation. Multiple events can be provided when spaces are used as a separator. (Note that this will not perform any DOM operation.)\n\t * * `structural` - Indicates that the `ng-` prefix will be added to the event class. Setting to `false` or omitting will turn `ng-EVENT` and\n\t * `ng-EVENT-active` in `EVENT` and `EVENT-active`. Unused if `event` is omitted.\n\t * * `easing` - The CSS easing value that will be applied to the transition or keyframe animation (or both).\n\t * * `transitionStyle` - The raw CSS transition style that will be used (e.g. `1s linear all`).\n\t * * `keyframeStyle` - The raw CSS keyframe animation style that will be used (e.g. `1s my_animation linear`).\n\t * * `from` - The starting CSS styles (a key/value object) that will be applied at the start of the animation.\n\t * * `to` - The ending CSS styles (a key/value object) that will be applied across the animation via a CSS transition.\n\t * * `addClass` - A space separated list of CSS classes that will be added to the element and spread across the animation.\n\t * * `removeClass` - A space separated list of CSS classes that will be removed from the element and spread across the animation.\n\t * * `duration` - A number value representing the total duration of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `0`\n\t * is provided then the animation will be skipped entirely.\n\t * * `delay` - A number value representing the total delay of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `true` is\n\t * used then whatever delay value is detected from the CSS classes will be mirrored on the elements styles (e.g. by setting delay true then the style value\n\t * of the element will be `transition-delay: DETECTED_VALUE`). Using `true` is useful when you want the CSS classes and inline styles to all share the same\n\t * CSS delay value.\n\t * * `stagger` - A numeric time value representing the delay between successively animated elements\n\t * ({@link ngAnimate#css-staggering-animations Click here to learn how CSS-based staggering works in ngAnimate.})\n\t * * `staggerIndex` - The numeric index representing the stagger item (e.g. a value of 5 is equal to the sixth item in the stagger; therefore when a\n\t *   `stagger` option value of `0.1` is used then there will be a stagger delay of `600ms`)\n\t * * `applyClassesEarly` - Whether or not the classes being added or removed will be used when detecting the animation. This is set by `$animate` when enter/leave/move animations are fired to ensure that the CSS classes are resolved in time. (Note that this will prevent any transitions from occurring on the classes being added and removed.)\n\t * * `cleanupStyles` - Whether or not the provided `from` and `to` styles will be removed once\n\t *    the animation is closed. This is useful for when the styles are used purely for the sake of\n\t *    the animation and do not have a lasting visual effect on the element (e.g. a collapse and open animation).\n\t *    By default this value is set to `false`.\n\t *\n\t * @return {object} an object with start and end methods and details about the animation.\n\t *\n\t * * `start` - The method to start the animation. This will return a `Promise` when called.\n\t * * `end` - This method will cancel the animation and remove all applied CSS classes and styles.\n\t */\n\tvar ONE_SECOND = 1000;\n\tvar BASE_TEN = 10;\n\t\n\tvar ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;\n\tvar CLOSING_TIME_BUFFER = 1.5;\n\t\n\tvar DETECT_CSS_PROPERTIES = {\n\t  transitionDuration:      TRANSITION_DURATION_PROP,\n\t  transitionDelay:         TRANSITION_DELAY_PROP,\n\t  transitionProperty:      TRANSITION_PROP + PROPERTY_KEY,\n\t  animationDuration:       ANIMATION_DURATION_PROP,\n\t  animationDelay:          ANIMATION_DELAY_PROP,\n\t  animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY\n\t};\n\t\n\tvar DETECT_STAGGER_CSS_PROPERTIES = {\n\t  transitionDuration:      TRANSITION_DURATION_PROP,\n\t  transitionDelay:         TRANSITION_DELAY_PROP,\n\t  animationDuration:       ANIMATION_DURATION_PROP,\n\t  animationDelay:          ANIMATION_DELAY_PROP\n\t};\n\t\n\tfunction getCssKeyframeDurationStyle(duration) {\n\t  return [ANIMATION_DURATION_PROP, duration + 's'];\n\t}\n\t\n\tfunction getCssDelayStyle(delay, isKeyframeAnimation) {\n\t  var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;\n\t  return [prop, delay + 's'];\n\t}\n\t\n\tfunction computeCssStyles($window, element, properties) {\n\t  var styles = Object.create(null);\n\t  var detectedStyles = $window.getComputedStyle(element) || {};\n\t  forEach(properties, function(formalStyleName, actualStyleName) {\n\t    var val = detectedStyles[formalStyleName];\n\t    if (val) {\n\t      var c = val.charAt(0);\n\t\n\t      // only numerical-based values have a negative sign or digit as the first value\n\t      if (c === '-' || c === '+' || c >= 0) {\n\t        val = parseMaxTime(val);\n\t      }\n\t\n\t      // by setting this to null in the event that the delay is not set or is set directly as 0\n\t      // then we can still allow for negative values to be used later on and not mistake this\n\t      // value for being greater than any other negative value.\n\t      if (val === 0) {\n\t        val = null;\n\t      }\n\t      styles[actualStyleName] = val;\n\t    }\n\t  });\n\t\n\t  return styles;\n\t}\n\t\n\tfunction parseMaxTime(str) {\n\t  var maxValue = 0;\n\t  var values = str.split(/\\s*,\\s*/);\n\t  forEach(values, function(value) {\n\t    // it's always safe to consider only second values and omit `ms` values since\n\t    // getComputedStyle will always handle the conversion for us\n\t    if (value.charAt(value.length - 1) == 's') {\n\t      value = value.substring(0, value.length - 1);\n\t    }\n\t    value = parseFloat(value) || 0;\n\t    maxValue = maxValue ? Math.max(value, maxValue) : value;\n\t  });\n\t  return maxValue;\n\t}\n\t\n\tfunction truthyTimingValue(val) {\n\t  return val === 0 || val != null;\n\t}\n\t\n\tfunction getCssTransitionDurationStyle(duration, applyOnlyDuration) {\n\t  var style = TRANSITION_PROP;\n\t  var value = duration + 's';\n\t  if (applyOnlyDuration) {\n\t    style += DURATION_KEY;\n\t  } else {\n\t    value += ' linear all';\n\t  }\n\t  return [style, value];\n\t}\n\t\n\tfunction createLocalCacheLookup() {\n\t  var cache = Object.create(null);\n\t  return {\n\t    flush: function() {\n\t      cache = Object.create(null);\n\t    },\n\t\n\t    count: function(key) {\n\t      var entry = cache[key];\n\t      return entry ? entry.total : 0;\n\t    },\n\t\n\t    get: function(key) {\n\t      var entry = cache[key];\n\t      return entry && entry.value;\n\t    },\n\t\n\t    put: function(key, value) {\n\t      if (!cache[key]) {\n\t        cache[key] = { total: 1, value: value };\n\t      } else {\n\t        cache[key].total++;\n\t      }\n\t    }\n\t  };\n\t}\n\t\n\t// we do not reassign an already present style value since\n\t// if we detect the style property value again we may be\n\t// detecting styles that were added via the `from` styles.\n\t// We make use of `isDefined` here since an empty string\n\t// or null value (which is what getPropertyValue will return\n\t// for a non-existing style) will still be marked as a valid\n\t// value for the style (a falsy value implies that the style\n\t// is to be removed at the end of the animation). If we had a simple\n\t// \"OR\" statement then it would not be enough to catch that.\n\tfunction registerRestorableStyles(backup, node, properties) {\n\t  forEach(properties, function(prop) {\n\t    backup[prop] = isDefined(backup[prop])\n\t        ? backup[prop]\n\t        : node.style.getPropertyValue(prop);\n\t  });\n\t}\n\t\n\tvar $AnimateCssProvider = ['$animateProvider', function($animateProvider) {\n\t  var gcsLookup = createLocalCacheLookup();\n\t  var gcsStaggerLookup = createLocalCacheLookup();\n\t\n\t  this.$get = ['$window', '$$jqLite', '$$AnimateRunner', '$timeout',\n\t               '$$forceReflow', '$sniffer', '$$rAFScheduler', '$$animateQueue',\n\t       function($window,   $$jqLite,   $$AnimateRunner,   $timeout,\n\t                $$forceReflow,   $sniffer,   $$rAFScheduler, $$animateQueue) {\n\t\n\t    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\t\n\t    var parentCounter = 0;\n\t    function gcsHashFn(node, extraClasses) {\n\t      var KEY = \"$$ngAnimateParentKey\";\n\t      var parentNode = node.parentNode;\n\t      var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);\n\t      return parentID + '-' + node.getAttribute('class') + '-' + extraClasses;\n\t    }\n\t\n\t    function computeCachedCssStyles(node, className, cacheKey, properties) {\n\t      var timings = gcsLookup.get(cacheKey);\n\t\n\t      if (!timings) {\n\t        timings = computeCssStyles($window, node, properties);\n\t        if (timings.animationIterationCount === 'infinite') {\n\t          timings.animationIterationCount = 1;\n\t        }\n\t      }\n\t\n\t      // we keep putting this in multiple times even though the value and the cacheKey are the same\n\t      // because we're keeping an internal tally of how many duplicate animations are detected.\n\t      gcsLookup.put(cacheKey, timings);\n\t      return timings;\n\t    }\n\t\n\t    function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {\n\t      var stagger;\n\t\n\t      // if we have one or more existing matches of matching elements\n\t      // containing the same parent + CSS styles (which is how cacheKey works)\n\t      // then staggering is possible\n\t      if (gcsLookup.count(cacheKey) > 0) {\n\t        stagger = gcsStaggerLookup.get(cacheKey);\n\t\n\t        if (!stagger) {\n\t          var staggerClassName = pendClasses(className, '-stagger');\n\t\n\t          $$jqLite.addClass(node, staggerClassName);\n\t\n\t          stagger = computeCssStyles($window, node, properties);\n\t\n\t          // force the conversion of a null value to zero incase not set\n\t          stagger.animationDuration = Math.max(stagger.animationDuration, 0);\n\t          stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);\n\t\n\t          $$jqLite.removeClass(node, staggerClassName);\n\t\n\t          gcsStaggerLookup.put(cacheKey, stagger);\n\t        }\n\t      }\n\t\n\t      return stagger || {};\n\t    }\n\t\n\t    var cancelLastRAFRequest;\n\t    var rafWaitQueue = [];\n\t    function waitUntilQuiet(callback) {\n\t      rafWaitQueue.push(callback);\n\t      $$rAFScheduler.waitUntilQuiet(function() {\n\t        gcsLookup.flush();\n\t        gcsStaggerLookup.flush();\n\t\n\t        // DO NOT REMOVE THIS LINE OR REFACTOR OUT THE `pageWidth` variable.\n\t        // PLEASE EXAMINE THE `$$forceReflow` service to understand why.\n\t        var pageWidth = $$forceReflow();\n\t\n\t        // we use a for loop to ensure that if the queue is changed\n\t        // during this looping then it will consider new requests\n\t        for (var i = 0; i < rafWaitQueue.length; i++) {\n\t          rafWaitQueue[i](pageWidth);\n\t        }\n\t        rafWaitQueue.length = 0;\n\t      });\n\t    }\n\t\n\t    function computeTimings(node, className, cacheKey) {\n\t      var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);\n\t      var aD = timings.animationDelay;\n\t      var tD = timings.transitionDelay;\n\t      timings.maxDelay = aD && tD\n\t          ? Math.max(aD, tD)\n\t          : (aD || tD);\n\t      timings.maxDuration = Math.max(\n\t          timings.animationDuration * timings.animationIterationCount,\n\t          timings.transitionDuration);\n\t\n\t      return timings;\n\t    }\n\t\n\t    return function init(element, initialOptions) {\n\t      // all of the animation functions should create\n\t      // a copy of the options data, however, if a\n\t      // parent service has already created a copy then\n\t      // we should stick to using that\n\t      var options = initialOptions || {};\n\t      if (!options.$$prepared) {\n\t        options = prepareAnimationOptions(copy(options));\n\t      }\n\t\n\t      var restoreStyles = {};\n\t      var node = getDomNode(element);\n\t      if (!node\n\t          || !node.parentNode\n\t          || !$$animateQueue.enabled()) {\n\t        return closeAndReturnNoopAnimator();\n\t      }\n\t\n\t      var temporaryStyles = [];\n\t      var classes = element.attr('class');\n\t      var styles = packageStyles(options);\n\t      var animationClosed;\n\t      var animationPaused;\n\t      var animationCompleted;\n\t      var runner;\n\t      var runnerHost;\n\t      var maxDelay;\n\t      var maxDelayTime;\n\t      var maxDuration;\n\t      var maxDurationTime;\n\t      var startTime;\n\t      var events = [];\n\t\n\t      if (options.duration === 0 || (!$sniffer.animations && !$sniffer.transitions)) {\n\t        return closeAndReturnNoopAnimator();\n\t      }\n\t\n\t      var method = options.event && isArray(options.event)\n\t            ? options.event.join(' ')\n\t            : options.event;\n\t\n\t      var isStructural = method && options.structural;\n\t      var structuralClassName = '';\n\t      var addRemoveClassName = '';\n\t\n\t      if (isStructural) {\n\t        structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);\n\t      } else if (method) {\n\t        structuralClassName = method;\n\t      }\n\t\n\t      if (options.addClass) {\n\t        addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);\n\t      }\n\t\n\t      if (options.removeClass) {\n\t        if (addRemoveClassName.length) {\n\t          addRemoveClassName += ' ';\n\t        }\n\t        addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);\n\t      }\n\t\n\t      // there may be a situation where a structural animation is combined together\n\t      // with CSS classes that need to resolve before the animation is computed.\n\t      // However this means that there is no explicit CSS code to block the animation\n\t      // from happening (by setting 0s none in the class name). If this is the case\n\t      // we need to apply the classes before the first rAF so we know to continue if\n\t      // there actually is a detected transition or keyframe animation\n\t      if (options.applyClassesEarly && addRemoveClassName.length) {\n\t        applyAnimationClasses(element, options);\n\t      }\n\t\n\t      var preparationClasses = [structuralClassName, addRemoveClassName].join(' ').trim();\n\t      var fullClassName = classes + ' ' + preparationClasses;\n\t      var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);\n\t      var hasToStyles = styles.to && Object.keys(styles.to).length > 0;\n\t      var containsKeyframeAnimation = (options.keyframeStyle || '').length > 0;\n\t\n\t      // there is no way we can trigger an animation if no styles and\n\t      // no classes are being applied which would then trigger a transition,\n\t      // unless there a is raw keyframe value that is applied to the element.\n\t      if (!containsKeyframeAnimation\n\t           && !hasToStyles\n\t           && !preparationClasses) {\n\t        return closeAndReturnNoopAnimator();\n\t      }\n\t\n\t      var cacheKey, stagger;\n\t      if (options.stagger > 0) {\n\t        var staggerVal = parseFloat(options.stagger);\n\t        stagger = {\n\t          transitionDelay: staggerVal,\n\t          animationDelay: staggerVal,\n\t          transitionDuration: 0,\n\t          animationDuration: 0\n\t        };\n\t      } else {\n\t        cacheKey = gcsHashFn(node, fullClassName);\n\t        stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);\n\t      }\n\t\n\t      if (!options.$$skipPreparationClasses) {\n\t        $$jqLite.addClass(element, preparationClasses);\n\t      }\n\t\n\t      var applyOnlyDuration;\n\t\n\t      if (options.transitionStyle) {\n\t        var transitionStyle = [TRANSITION_PROP, options.transitionStyle];\n\t        applyInlineStyle(node, transitionStyle);\n\t        temporaryStyles.push(transitionStyle);\n\t      }\n\t\n\t      if (options.duration >= 0) {\n\t        applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;\n\t        var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);\n\t\n\t        // we set the duration so that it will be picked up by getComputedStyle later\n\t        applyInlineStyle(node, durationStyle);\n\t        temporaryStyles.push(durationStyle);\n\t      }\n\t\n\t      if (options.keyframeStyle) {\n\t        var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];\n\t        applyInlineStyle(node, keyframeStyle);\n\t        temporaryStyles.push(keyframeStyle);\n\t      }\n\t\n\t      var itemIndex = stagger\n\t          ? options.staggerIndex >= 0\n\t              ? options.staggerIndex\n\t              : gcsLookup.count(cacheKey)\n\t          : 0;\n\t\n\t      var isFirst = itemIndex === 0;\n\t\n\t      // this is a pre-emptive way of forcing the setup classes to be added and applied INSTANTLY\n\t      // without causing any combination of transitions to kick in. By adding a negative delay value\n\t      // it forces the setup class' transition to end immediately. We later then remove the negative\n\t      // transition delay to allow for the transition to naturally do it's thing. The beauty here is\n\t      // that if there is no transition defined then nothing will happen and this will also allow\n\t      // other transitions to be stacked on top of each other without any chopping them out.\n\t      if (isFirst && !options.skipBlocking) {\n\t        blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);\n\t      }\n\t\n\t      var timings = computeTimings(node, fullClassName, cacheKey);\n\t      var relativeDelay = timings.maxDelay;\n\t      maxDelay = Math.max(relativeDelay, 0);\n\t      maxDuration = timings.maxDuration;\n\t\n\t      var flags = {};\n\t      flags.hasTransitions          = timings.transitionDuration > 0;\n\t      flags.hasAnimations           = timings.animationDuration > 0;\n\t      flags.hasTransitionAll        = flags.hasTransitions && timings.transitionProperty == 'all';\n\t      flags.applyTransitionDuration = hasToStyles && (\n\t                                        (flags.hasTransitions && !flags.hasTransitionAll)\n\t                                         || (flags.hasAnimations && !flags.hasTransitions));\n\t      flags.applyAnimationDuration  = options.duration && flags.hasAnimations;\n\t      flags.applyTransitionDelay    = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);\n\t      flags.applyAnimationDelay     = truthyTimingValue(options.delay) && flags.hasAnimations;\n\t      flags.recalculateTimingStyles = addRemoveClassName.length > 0;\n\t\n\t      if (flags.applyTransitionDuration || flags.applyAnimationDuration) {\n\t        maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;\n\t\n\t        if (flags.applyTransitionDuration) {\n\t          flags.hasTransitions = true;\n\t          timings.transitionDuration = maxDuration;\n\t          applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;\n\t          temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));\n\t        }\n\t\n\t        if (flags.applyAnimationDuration) {\n\t          flags.hasAnimations = true;\n\t          timings.animationDuration = maxDuration;\n\t          temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));\n\t        }\n\t      }\n\t\n\t      if (maxDuration === 0 && !flags.recalculateTimingStyles) {\n\t        return closeAndReturnNoopAnimator();\n\t      }\n\t\n\t      if (options.delay != null) {\n\t        var delayStyle;\n\t        if (typeof options.delay !== \"boolean\") {\n\t          delayStyle = parseFloat(options.delay);\n\t          // number in options.delay means we have to recalculate the delay for the closing timeout\n\t          maxDelay = Math.max(delayStyle, 0);\n\t        }\n\t\n\t        if (flags.applyTransitionDelay) {\n\t          temporaryStyles.push(getCssDelayStyle(delayStyle));\n\t        }\n\t\n\t        if (flags.applyAnimationDelay) {\n\t          temporaryStyles.push(getCssDelayStyle(delayStyle, true));\n\t        }\n\t      }\n\t\n\t      // we need to recalculate the delay value since we used a pre-emptive negative\n\t      // delay value and the delay value is required for the final event checking. This\n\t      // property will ensure that this will happen after the RAF phase has passed.\n\t      if (options.duration == null && timings.transitionDuration > 0) {\n\t        flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;\n\t      }\n\t\n\t      maxDelayTime = maxDelay * ONE_SECOND;\n\t      maxDurationTime = maxDuration * ONE_SECOND;\n\t      if (!options.skipBlocking) {\n\t        flags.blockTransition = timings.transitionDuration > 0;\n\t        flags.blockKeyframeAnimation = timings.animationDuration > 0 &&\n\t                                       stagger.animationDelay > 0 &&\n\t                                       stagger.animationDuration === 0;\n\t      }\n\t\n\t      if (options.from) {\n\t        if (options.cleanupStyles) {\n\t          registerRestorableStyles(restoreStyles, node, Object.keys(options.from));\n\t        }\n\t        applyAnimationFromStyles(element, options);\n\t      }\n\t\n\t      if (flags.blockTransition || flags.blockKeyframeAnimation) {\n\t        applyBlocking(maxDuration);\n\t      } else if (!options.skipBlocking) {\n\t        blockTransitions(node, false);\n\t      }\n\t\n\t      // TODO(matsko): for 1.5 change this code to have an animator object for better debugging\n\t      return {\n\t        $$willAnimate: true,\n\t        end: endFn,\n\t        start: function() {\n\t          if (animationClosed) return;\n\t\n\t          runnerHost = {\n\t            end: endFn,\n\t            cancel: cancelFn,\n\t            resume: null, //this will be set during the start() phase\n\t            pause: null\n\t          };\n\t\n\t          runner = new $$AnimateRunner(runnerHost);\n\t\n\t          waitUntilQuiet(start);\n\t\n\t          // we don't have access to pause/resume the animation\n\t          // since it hasn't run yet. AnimateRunner will therefore\n\t          // set noop functions for resume and pause and they will\n\t          // later be overridden once the animation is triggered\n\t          return runner;\n\t        }\n\t      };\n\t\n\t      function endFn() {\n\t        close();\n\t      }\n\t\n\t      function cancelFn() {\n\t        close(true);\n\t      }\n\t\n\t      function close(rejected) { // jshint ignore:line\n\t        // if the promise has been called already then we shouldn't close\n\t        // the animation again\n\t        if (animationClosed || (animationCompleted && animationPaused)) return;\n\t        animationClosed = true;\n\t        animationPaused = false;\n\t\n\t        if (!options.$$skipPreparationClasses) {\n\t          $$jqLite.removeClass(element, preparationClasses);\n\t        }\n\t        $$jqLite.removeClass(element, activeClasses);\n\t\n\t        blockKeyframeAnimations(node, false);\n\t        blockTransitions(node, false);\n\t\n\t        forEach(temporaryStyles, function(entry) {\n\t          // There is only one way to remove inline style properties entirely from elements.\n\t          // By using `removeProperty` this works, but we need to convert camel-cased CSS\n\t          // styles down to hyphenated values.\n\t          node.style[entry[0]] = '';\n\t        });\n\t\n\t        applyAnimationClasses(element, options);\n\t        applyAnimationStyles(element, options);\n\t\n\t        if (Object.keys(restoreStyles).length) {\n\t          forEach(restoreStyles, function(value, prop) {\n\t            value ? node.style.setProperty(prop, value)\n\t                  : node.style.removeProperty(prop);\n\t          });\n\t        }\n\t\n\t        // the reason why we have this option is to allow a synchronous closing callback\n\t        // that is fired as SOON as the animation ends (when the CSS is removed) or if\n\t        // the animation never takes off at all. A good example is a leave animation since\n\t        // the element must be removed just after the animation is over or else the element\n\t        // will appear on screen for one animation frame causing an overbearing flicker.\n\t        if (options.onDone) {\n\t          options.onDone();\n\t        }\n\t\n\t        if (events && events.length) {\n\t          // Remove the transitionend / animationend listener(s)\n\t          element.off(events.join(' '), onAnimationProgress);\n\t        }\n\t\n\t        //Cancel the fallback closing timeout and remove the timer data\n\t        var animationTimerData = element.data(ANIMATE_TIMER_KEY);\n\t        if (animationTimerData) {\n\t          $timeout.cancel(animationTimerData[0].timer);\n\t          element.removeData(ANIMATE_TIMER_KEY);\n\t        }\n\t\n\t        // if the preparation function fails then the promise is not setup\n\t        if (runner) {\n\t          runner.complete(!rejected);\n\t        }\n\t      }\n\t\n\t      function applyBlocking(duration) {\n\t        if (flags.blockTransition) {\n\t          blockTransitions(node, duration);\n\t        }\n\t\n\t        if (flags.blockKeyframeAnimation) {\n\t          blockKeyframeAnimations(node, !!duration);\n\t        }\n\t      }\n\t\n\t      function closeAndReturnNoopAnimator() {\n\t        runner = new $$AnimateRunner({\n\t          end: endFn,\n\t          cancel: cancelFn\n\t        });\n\t\n\t        // should flush the cache animation\n\t        waitUntilQuiet(noop);\n\t        close();\n\t\n\t        return {\n\t          $$willAnimate: false,\n\t          start: function() {\n\t            return runner;\n\t          },\n\t          end: endFn\n\t        };\n\t      }\n\t\n\t      function onAnimationProgress(event) {\n\t        event.stopPropagation();\n\t        var ev = event.originalEvent || event;\n\t\n\t        // we now always use `Date.now()` due to the recent changes with\n\t        // event.timeStamp in Firefox, Webkit and Chrome (see #13494 for more info)\n\t        var timeStamp = ev.$manualTimeStamp || Date.now();\n\t\n\t        /* Firefox (or possibly just Gecko) likes to not round values up\n\t         * when a ms measurement is used for the animation */\n\t        var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));\n\t\n\t        /* $manualTimeStamp is a mocked timeStamp value which is set\n\t         * within browserTrigger(). This is only here so that tests can\n\t         * mock animations properly. Real events fallback to event.timeStamp,\n\t         * or, if they don't, then a timeStamp is automatically created for them.\n\t         * We're checking to see if the timeStamp surpasses the expected delay,\n\t         * but we're using elapsedTime instead of the timeStamp on the 2nd\n\t         * pre-condition since animationPauseds sometimes close off early */\n\t        if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {\n\t          // we set this flag to ensure that if the transition is paused then, when resumed,\n\t          // the animation will automatically close itself since transitions cannot be paused.\n\t          animationCompleted = true;\n\t          close();\n\t        }\n\t      }\n\t\n\t      function start() {\n\t        if (animationClosed) return;\n\t        if (!node.parentNode) {\n\t          close();\n\t          return;\n\t        }\n\t\n\t        // even though we only pause keyframe animations here the pause flag\n\t        // will still happen when transitions are used. Only the transition will\n\t        // not be paused since that is not possible. If the animation ends when\n\t        // paused then it will not complete until unpaused or cancelled.\n\t        var playPause = function(playAnimation) {\n\t          if (!animationCompleted) {\n\t            animationPaused = !playAnimation;\n\t            if (timings.animationDuration) {\n\t              var value = blockKeyframeAnimations(node, animationPaused);\n\t              animationPaused\n\t                  ? temporaryStyles.push(value)\n\t                  : removeFromArray(temporaryStyles, value);\n\t            }\n\t          } else if (animationPaused && playAnimation) {\n\t            animationPaused = false;\n\t            close();\n\t          }\n\t        };\n\t\n\t        // checking the stagger duration prevents an accidentally cascade of the CSS delay style\n\t        // being inherited from the parent. If the transition duration is zero then we can safely\n\t        // rely that the delay value is an intentional stagger delay style.\n\t        var maxStagger = itemIndex > 0\n\t                         && ((timings.transitionDuration && stagger.transitionDuration === 0) ||\n\t                            (timings.animationDuration && stagger.animationDuration === 0))\n\t                         && Math.max(stagger.animationDelay, stagger.transitionDelay);\n\t        if (maxStagger) {\n\t          $timeout(triggerAnimationStart,\n\t                   Math.floor(maxStagger * itemIndex * ONE_SECOND),\n\t                   false);\n\t        } else {\n\t          triggerAnimationStart();\n\t        }\n\t\n\t        // this will decorate the existing promise runner with pause/resume methods\n\t        runnerHost.resume = function() {\n\t          playPause(true);\n\t        };\n\t\n\t        runnerHost.pause = function() {\n\t          playPause(false);\n\t        };\n\t\n\t        function triggerAnimationStart() {\n\t          // just incase a stagger animation kicks in when the animation\n\t          // itself was cancelled entirely\n\t          if (animationClosed) return;\n\t\n\t          applyBlocking(false);\n\t\n\t          forEach(temporaryStyles, function(entry) {\n\t            var key = entry[0];\n\t            var value = entry[1];\n\t            node.style[key] = value;\n\t          });\n\t\n\t          applyAnimationClasses(element, options);\n\t          $$jqLite.addClass(element, activeClasses);\n\t\n\t          if (flags.recalculateTimingStyles) {\n\t            fullClassName = node.className + ' ' + preparationClasses;\n\t            cacheKey = gcsHashFn(node, fullClassName);\n\t\n\t            timings = computeTimings(node, fullClassName, cacheKey);\n\t            relativeDelay = timings.maxDelay;\n\t            maxDelay = Math.max(relativeDelay, 0);\n\t            maxDuration = timings.maxDuration;\n\t\n\t            if (maxDuration === 0) {\n\t              close();\n\t              return;\n\t            }\n\t\n\t            flags.hasTransitions = timings.transitionDuration > 0;\n\t            flags.hasAnimations = timings.animationDuration > 0;\n\t          }\n\t\n\t          if (flags.applyAnimationDelay) {\n\t            relativeDelay = typeof options.delay !== \"boolean\" && truthyTimingValue(options.delay)\n\t                  ? parseFloat(options.delay)\n\t                  : relativeDelay;\n\t\n\t            maxDelay = Math.max(relativeDelay, 0);\n\t            timings.animationDelay = relativeDelay;\n\t            delayStyle = getCssDelayStyle(relativeDelay, true);\n\t            temporaryStyles.push(delayStyle);\n\t            node.style[delayStyle[0]] = delayStyle[1];\n\t          }\n\t\n\t          maxDelayTime = maxDelay * ONE_SECOND;\n\t          maxDurationTime = maxDuration * ONE_SECOND;\n\t\n\t          if (options.easing) {\n\t            var easeProp, easeVal = options.easing;\n\t            if (flags.hasTransitions) {\n\t              easeProp = TRANSITION_PROP + TIMING_KEY;\n\t              temporaryStyles.push([easeProp, easeVal]);\n\t              node.style[easeProp] = easeVal;\n\t            }\n\t            if (flags.hasAnimations) {\n\t              easeProp = ANIMATION_PROP + TIMING_KEY;\n\t              temporaryStyles.push([easeProp, easeVal]);\n\t              node.style[easeProp] = easeVal;\n\t            }\n\t          }\n\t\n\t          if (timings.transitionDuration) {\n\t            events.push(TRANSITIONEND_EVENT);\n\t          }\n\t\n\t          if (timings.animationDuration) {\n\t            events.push(ANIMATIONEND_EVENT);\n\t          }\n\t\n\t          startTime = Date.now();\n\t          var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;\n\t          var endTime = startTime + timerTime;\n\t\n\t          var animationsData = element.data(ANIMATE_TIMER_KEY) || [];\n\t          var setupFallbackTimer = true;\n\t          if (animationsData.length) {\n\t            var currentTimerData = animationsData[0];\n\t            setupFallbackTimer = endTime > currentTimerData.expectedEndTime;\n\t            if (setupFallbackTimer) {\n\t              $timeout.cancel(currentTimerData.timer);\n\t            } else {\n\t              animationsData.push(close);\n\t            }\n\t          }\n\t\n\t          if (setupFallbackTimer) {\n\t            var timer = $timeout(onAnimationExpired, timerTime, false);\n\t            animationsData[0] = {\n\t              timer: timer,\n\t              expectedEndTime: endTime\n\t            };\n\t            animationsData.push(close);\n\t            element.data(ANIMATE_TIMER_KEY, animationsData);\n\t          }\n\t\n\t          if (events.length) {\n\t            element.on(events.join(' '), onAnimationProgress);\n\t          }\n\t\n\t          if (options.to) {\n\t            if (options.cleanupStyles) {\n\t              registerRestorableStyles(restoreStyles, node, Object.keys(options.to));\n\t            }\n\t            applyAnimationToStyles(element, options);\n\t          }\n\t        }\n\t\n\t        function onAnimationExpired() {\n\t          var animationsData = element.data(ANIMATE_TIMER_KEY);\n\t\n\t          // this will be false in the event that the element was\n\t          // removed from the DOM (via a leave animation or something\n\t          // similar)\n\t          if (animationsData) {\n\t            for (var i = 1; i < animationsData.length; i++) {\n\t              animationsData[i]();\n\t            }\n\t            element.removeData(ANIMATE_TIMER_KEY);\n\t          }\n\t        }\n\t      }\n\t    };\n\t  }];\n\t}];\n\t\n\tvar $$AnimateCssDriverProvider = ['$$animationProvider', function($$animationProvider) {\n\t  $$animationProvider.drivers.push('$$animateCssDriver');\n\t\n\t  var NG_ANIMATE_SHIM_CLASS_NAME = 'ng-animate-shim';\n\t  var NG_ANIMATE_ANCHOR_CLASS_NAME = 'ng-anchor';\n\t\n\t  var NG_OUT_ANCHOR_CLASS_NAME = 'ng-anchor-out';\n\t  var NG_IN_ANCHOR_CLASS_NAME = 'ng-anchor-in';\n\t\n\t  function isDocumentFragment(node) {\n\t    return node.parentNode && node.parentNode.nodeType === 11;\n\t  }\n\t\n\t  this.$get = ['$animateCss', '$rootScope', '$$AnimateRunner', '$rootElement', '$sniffer', '$$jqLite', '$document',\n\t       function($animateCss,   $rootScope,   $$AnimateRunner,   $rootElement,   $sniffer,   $$jqLite,   $document) {\n\t\n\t    // only browsers that support these properties can render animations\n\t    if (!$sniffer.animations && !$sniffer.transitions) return noop;\n\t\n\t    var bodyNode = $document[0].body;\n\t    var rootNode = getDomNode($rootElement);\n\t\n\t    var rootBodyElement = jqLite(\n\t      // this is to avoid using something that exists outside of the body\n\t      // we also special case the doc fragment case because our unit test code\n\t      // appends the $rootElement to the body after the app has been bootstrapped\n\t      isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode\n\t    );\n\t\n\t    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\t\n\t    return function initDriverFn(animationDetails) {\n\t      return animationDetails.from && animationDetails.to\n\t          ? prepareFromToAnchorAnimation(animationDetails.from,\n\t                                         animationDetails.to,\n\t                                         animationDetails.classes,\n\t                                         animationDetails.anchors)\n\t          : prepareRegularAnimation(animationDetails);\n\t    };\n\t\n\t    function filterCssClasses(classes) {\n\t      //remove all the `ng-` stuff\n\t      return classes.replace(/\\bng-\\S+\\b/g, '');\n\t    }\n\t\n\t    function getUniqueValues(a, b) {\n\t      if (isString(a)) a = a.split(' ');\n\t      if (isString(b)) b = b.split(' ');\n\t      return a.filter(function(val) {\n\t        return b.indexOf(val) === -1;\n\t      }).join(' ');\n\t    }\n\t\n\t    function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {\n\t      var clone = jqLite(getDomNode(outAnchor).cloneNode(true));\n\t      var startingClasses = filterCssClasses(getClassVal(clone));\n\t\n\t      outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);\n\t      inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);\n\t\n\t      clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);\n\t\n\t      rootBodyElement.append(clone);\n\t\n\t      var animatorIn, animatorOut = prepareOutAnimation();\n\t\n\t      // the user may not end up using the `out` animation and\n\t      // only making use of the `in` animation or vice-versa.\n\t      // In either case we should allow this and not assume the\n\t      // animation is over unless both animations are not used.\n\t      if (!animatorOut) {\n\t        animatorIn = prepareInAnimation();\n\t        if (!animatorIn) {\n\t          return end();\n\t        }\n\t      }\n\t\n\t      var startingAnimator = animatorOut || animatorIn;\n\t\n\t      return {\n\t        start: function() {\n\t          var runner;\n\t\n\t          var currentAnimation = startingAnimator.start();\n\t          currentAnimation.done(function() {\n\t            currentAnimation = null;\n\t            if (!animatorIn) {\n\t              animatorIn = prepareInAnimation();\n\t              if (animatorIn) {\n\t                currentAnimation = animatorIn.start();\n\t                currentAnimation.done(function() {\n\t                  currentAnimation = null;\n\t                  end();\n\t                  runner.complete();\n\t                });\n\t                return currentAnimation;\n\t              }\n\t            }\n\t            // in the event that there is no `in` animation\n\t            end();\n\t            runner.complete();\n\t          });\n\t\n\t          runner = new $$AnimateRunner({\n\t            end: endFn,\n\t            cancel: endFn\n\t          });\n\t\n\t          return runner;\n\t\n\t          function endFn() {\n\t            if (currentAnimation) {\n\t              currentAnimation.end();\n\t            }\n\t          }\n\t        }\n\t      };\n\t\n\t      function calculateAnchorStyles(anchor) {\n\t        var styles = {};\n\t\n\t        var coords = getDomNode(anchor).getBoundingClientRect();\n\t\n\t        // we iterate directly since safari messes up and doesn't return\n\t        // all the keys for the coords object when iterated\n\t        forEach(['width','height','top','left'], function(key) {\n\t          var value = coords[key];\n\t          switch (key) {\n\t            case 'top':\n\t              value += bodyNode.scrollTop;\n\t              break;\n\t            case 'left':\n\t              value += bodyNode.scrollLeft;\n\t              break;\n\t          }\n\t          styles[key] = Math.floor(value) + 'px';\n\t        });\n\t        return styles;\n\t      }\n\t\n\t      function prepareOutAnimation() {\n\t        var animator = $animateCss(clone, {\n\t          addClass: NG_OUT_ANCHOR_CLASS_NAME,\n\t          delay: true,\n\t          from: calculateAnchorStyles(outAnchor)\n\t        });\n\t\n\t        // read the comment within `prepareRegularAnimation` to understand\n\t        // why this check is necessary\n\t        return animator.$$willAnimate ? animator : null;\n\t      }\n\t\n\t      function getClassVal(element) {\n\t        return element.attr('class') || '';\n\t      }\n\t\n\t      function prepareInAnimation() {\n\t        var endingClasses = filterCssClasses(getClassVal(inAnchor));\n\t        var toAdd = getUniqueValues(endingClasses, startingClasses);\n\t        var toRemove = getUniqueValues(startingClasses, endingClasses);\n\t\n\t        var animator = $animateCss(clone, {\n\t          to: calculateAnchorStyles(inAnchor),\n\t          addClass: NG_IN_ANCHOR_CLASS_NAME + ' ' + toAdd,\n\t          removeClass: NG_OUT_ANCHOR_CLASS_NAME + ' ' + toRemove,\n\t          delay: true\n\t        });\n\t\n\t        // read the comment within `prepareRegularAnimation` to understand\n\t        // why this check is necessary\n\t        return animator.$$willAnimate ? animator : null;\n\t      }\n\t\n\t      function end() {\n\t        clone.remove();\n\t        outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);\n\t        inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);\n\t      }\n\t    }\n\t\n\t    function prepareFromToAnchorAnimation(from, to, classes, anchors) {\n\t      var fromAnimation = prepareRegularAnimation(from, noop);\n\t      var toAnimation = prepareRegularAnimation(to, noop);\n\t\n\t      var anchorAnimations = [];\n\t      forEach(anchors, function(anchor) {\n\t        var outElement = anchor['out'];\n\t        var inElement = anchor['in'];\n\t        var animator = prepareAnchoredAnimation(classes, outElement, inElement);\n\t        if (animator) {\n\t          anchorAnimations.push(animator);\n\t        }\n\t      });\n\t\n\t      // no point in doing anything when there are no elements to animate\n\t      if (!fromAnimation && !toAnimation && anchorAnimations.length === 0) return;\n\t\n\t      return {\n\t        start: function() {\n\t          var animationRunners = [];\n\t\n\t          if (fromAnimation) {\n\t            animationRunners.push(fromAnimation.start());\n\t          }\n\t\n\t          if (toAnimation) {\n\t            animationRunners.push(toAnimation.start());\n\t          }\n\t\n\t          forEach(anchorAnimations, function(animation) {\n\t            animationRunners.push(animation.start());\n\t          });\n\t\n\t          var runner = new $$AnimateRunner({\n\t            end: endFn,\n\t            cancel: endFn // CSS-driven animations cannot be cancelled, only ended\n\t          });\n\t\n\t          $$AnimateRunner.all(animationRunners, function(status) {\n\t            runner.complete(status);\n\t          });\n\t\n\t          return runner;\n\t\n\t          function endFn() {\n\t            forEach(animationRunners, function(runner) {\n\t              runner.end();\n\t            });\n\t          }\n\t        }\n\t      };\n\t    }\n\t\n\t    function prepareRegularAnimation(animationDetails) {\n\t      var element = animationDetails.element;\n\t      var options = animationDetails.options || {};\n\t\n\t      if (animationDetails.structural) {\n\t        options.event = animationDetails.event;\n\t        options.structural = true;\n\t        options.applyClassesEarly = true;\n\t\n\t        // we special case the leave animation since we want to ensure that\n\t        // the element is removed as soon as the animation is over. Otherwise\n\t        // a flicker might appear or the element may not be removed at all\n\t        if (animationDetails.event === 'leave') {\n\t          options.onDone = options.domOperation;\n\t        }\n\t      }\n\t\n\t      // We assign the preparationClasses as the actual animation event since\n\t      // the internals of $animateCss will just suffix the event token values\n\t      // with `-active` to trigger the animation.\n\t      if (options.preparationClasses) {\n\t        options.event = concatWithSpace(options.event, options.preparationClasses);\n\t      }\n\t\n\t      var animator = $animateCss(element, options);\n\t\n\t      // the driver lookup code inside of $$animation attempts to spawn a\n\t      // driver one by one until a driver returns a.$$willAnimate animator object.\n\t      // $animateCss will always return an object, however, it will pass in\n\t      // a flag as a hint as to whether an animation was detected or not\n\t      return animator.$$willAnimate ? animator : null;\n\t    }\n\t  }];\n\t}];\n\t\n\t// TODO(matsko): use caching here to speed things up for detection\n\t// TODO(matsko): add documentation\n\t//  by the time...\n\t\n\tvar $$AnimateJsProvider = ['$animateProvider', function($animateProvider) {\n\t  this.$get = ['$injector', '$$AnimateRunner', '$$jqLite',\n\t       function($injector,   $$AnimateRunner,   $$jqLite) {\n\t\n\t    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\t         // $animateJs(element, 'enter');\n\t    return function(element, event, classes, options) {\n\t      var animationClosed = false;\n\t\n\t      // the `classes` argument is optional and if it is not used\n\t      // then the classes will be resolved from the element's className\n\t      // property as well as options.addClass/options.removeClass.\n\t      if (arguments.length === 3 && isObject(classes)) {\n\t        options = classes;\n\t        classes = null;\n\t      }\n\t\n\t      options = prepareAnimationOptions(options);\n\t      if (!classes) {\n\t        classes = element.attr('class') || '';\n\t        if (options.addClass) {\n\t          classes += ' ' + options.addClass;\n\t        }\n\t        if (options.removeClass) {\n\t          classes += ' ' + options.removeClass;\n\t        }\n\t      }\n\t\n\t      var classesToAdd = options.addClass;\n\t      var classesToRemove = options.removeClass;\n\t\n\t      // the lookupAnimations function returns a series of animation objects that are\n\t      // matched up with one or more of the CSS classes. These animation objects are\n\t      // defined via the module.animation factory function. If nothing is detected then\n\t      // we don't return anything which then makes $animation query the next driver.\n\t      var animations = lookupAnimations(classes);\n\t      var before, after;\n\t      if (animations.length) {\n\t        var afterFn, beforeFn;\n\t        if (event == 'leave') {\n\t          beforeFn = 'leave';\n\t          afterFn = 'afterLeave'; // TODO(matsko): get rid of this\n\t        } else {\n\t          beforeFn = 'before' + event.charAt(0).toUpperCase() + event.substr(1);\n\t          afterFn = event;\n\t        }\n\t\n\t        if (event !== 'enter' && event !== 'move') {\n\t          before = packageAnimations(element, event, options, animations, beforeFn);\n\t        }\n\t        after  = packageAnimations(element, event, options, animations, afterFn);\n\t      }\n\t\n\t      // no matching animations\n\t      if (!before && !after) return;\n\t\n\t      function applyOptions() {\n\t        options.domOperation();\n\t        applyAnimationClasses(element, options);\n\t      }\n\t\n\t      function close() {\n\t        animationClosed = true;\n\t        applyOptions();\n\t        applyAnimationStyles(element, options);\n\t      }\n\t\n\t      var runner;\n\t\n\t      return {\n\t        $$willAnimate: true,\n\t        end: function() {\n\t          if (runner) {\n\t            runner.end();\n\t          } else {\n\t            close();\n\t            runner = new $$AnimateRunner();\n\t            runner.complete(true);\n\t          }\n\t          return runner;\n\t        },\n\t        start: function() {\n\t          if (runner) {\n\t            return runner;\n\t          }\n\t\n\t          runner = new $$AnimateRunner();\n\t          var closeActiveAnimations;\n\t          var chain = [];\n\t\n\t          if (before) {\n\t            chain.push(function(fn) {\n\t              closeActiveAnimations = before(fn);\n\t            });\n\t          }\n\t\n\t          if (chain.length) {\n\t            chain.push(function(fn) {\n\t              applyOptions();\n\t              fn(true);\n\t            });\n\t          } else {\n\t            applyOptions();\n\t          }\n\t\n\t          if (after) {\n\t            chain.push(function(fn) {\n\t              closeActiveAnimations = after(fn);\n\t            });\n\t          }\n\t\n\t          runner.setHost({\n\t            end: function() {\n\t              endAnimations();\n\t            },\n\t            cancel: function() {\n\t              endAnimations(true);\n\t            }\n\t          });\n\t\n\t          $$AnimateRunner.chain(chain, onComplete);\n\t          return runner;\n\t\n\t          function onComplete(success) {\n\t            close(success);\n\t            runner.complete(success);\n\t          }\n\t\n\t          function endAnimations(cancelled) {\n\t            if (!animationClosed) {\n\t              (closeActiveAnimations || noop)(cancelled);\n\t              onComplete(cancelled);\n\t            }\n\t          }\n\t        }\n\t      };\n\t\n\t      function executeAnimationFn(fn, element, event, options, onDone) {\n\t        var args;\n\t        switch (event) {\n\t          case 'animate':\n\t            args = [element, options.from, options.to, onDone];\n\t            break;\n\t\n\t          case 'setClass':\n\t            args = [element, classesToAdd, classesToRemove, onDone];\n\t            break;\n\t\n\t          case 'addClass':\n\t            args = [element, classesToAdd, onDone];\n\t            break;\n\t\n\t          case 'removeClass':\n\t            args = [element, classesToRemove, onDone];\n\t            break;\n\t\n\t          default:\n\t            args = [element, onDone];\n\t            break;\n\t        }\n\t\n\t        args.push(options);\n\t\n\t        var value = fn.apply(fn, args);\n\t        if (value) {\n\t          if (isFunction(value.start)) {\n\t            value = value.start();\n\t          }\n\t\n\t          if (value instanceof $$AnimateRunner) {\n\t            value.done(onDone);\n\t          } else if (isFunction(value)) {\n\t            // optional onEnd / onCancel callback\n\t            return value;\n\t          }\n\t        }\n\t\n\t        return noop;\n\t      }\n\t\n\t      function groupEventedAnimations(element, event, options, animations, fnName) {\n\t        var operations = [];\n\t        forEach(animations, function(ani) {\n\t          var animation = ani[fnName];\n\t          if (!animation) return;\n\t\n\t          // note that all of these animations will run in parallel\n\t          operations.push(function() {\n\t            var runner;\n\t            var endProgressCb;\n\t\n\t            var resolved = false;\n\t            var onAnimationComplete = function(rejected) {\n\t              if (!resolved) {\n\t                resolved = true;\n\t                (endProgressCb || noop)(rejected);\n\t                runner.complete(!rejected);\n\t              }\n\t            };\n\t\n\t            runner = new $$AnimateRunner({\n\t              end: function() {\n\t                onAnimationComplete();\n\t              },\n\t              cancel: function() {\n\t                onAnimationComplete(true);\n\t              }\n\t            });\n\t\n\t            endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {\n\t              var cancelled = result === false;\n\t              onAnimationComplete(cancelled);\n\t            });\n\t\n\t            return runner;\n\t          });\n\t        });\n\t\n\t        return operations;\n\t      }\n\t\n\t      function packageAnimations(element, event, options, animations, fnName) {\n\t        var operations = groupEventedAnimations(element, event, options, animations, fnName);\n\t        if (operations.length === 0) {\n\t          var a,b;\n\t          if (fnName === 'beforeSetClass') {\n\t            a = groupEventedAnimations(element, 'removeClass', options, animations, 'beforeRemoveClass');\n\t            b = groupEventedAnimations(element, 'addClass', options, animations, 'beforeAddClass');\n\t          } else if (fnName === 'setClass') {\n\t            a = groupEventedAnimations(element, 'removeClass', options, animations, 'removeClass');\n\t            b = groupEventedAnimations(element, 'addClass', options, animations, 'addClass');\n\t          }\n\t\n\t          if (a) {\n\t            operations = operations.concat(a);\n\t          }\n\t          if (b) {\n\t            operations = operations.concat(b);\n\t          }\n\t        }\n\t\n\t        if (operations.length === 0) return;\n\t\n\t        // TODO(matsko): add documentation\n\t        return function startAnimation(callback) {\n\t          var runners = [];\n\t          if (operations.length) {\n\t            forEach(operations, function(animateFn) {\n\t              runners.push(animateFn());\n\t            });\n\t          }\n\t\n\t          runners.length ? $$AnimateRunner.all(runners, callback) : callback();\n\t\n\t          return function endFn(reject) {\n\t            forEach(runners, function(runner) {\n\t              reject ? runner.cancel() : runner.end();\n\t            });\n\t          };\n\t        };\n\t      }\n\t    };\n\t\n\t    function lookupAnimations(classes) {\n\t      classes = isArray(classes) ? classes : classes.split(' ');\n\t      var matches = [], flagMap = {};\n\t      for (var i=0; i < classes.length; i++) {\n\t        var klass = classes[i],\n\t            animationFactory = $animateProvider.$$registeredAnimations[klass];\n\t        if (animationFactory && !flagMap[klass]) {\n\t          matches.push($injector.get(animationFactory));\n\t          flagMap[klass] = true;\n\t        }\n\t      }\n\t      return matches;\n\t    }\n\t  }];\n\t}];\n\t\n\tvar $$AnimateJsDriverProvider = ['$$animationProvider', function($$animationProvider) {\n\t  $$animationProvider.drivers.push('$$animateJsDriver');\n\t  this.$get = ['$$animateJs', '$$AnimateRunner', function($$animateJs, $$AnimateRunner) {\n\t    return function initDriverFn(animationDetails) {\n\t      if (animationDetails.from && animationDetails.to) {\n\t        var fromAnimation = prepareAnimation(animationDetails.from);\n\t        var toAnimation = prepareAnimation(animationDetails.to);\n\t        if (!fromAnimation && !toAnimation) return;\n\t\n\t        return {\n\t          start: function() {\n\t            var animationRunners = [];\n\t\n\t            if (fromAnimation) {\n\t              animationRunners.push(fromAnimation.start());\n\t            }\n\t\n\t            if (toAnimation) {\n\t              animationRunners.push(toAnimation.start());\n\t            }\n\t\n\t            $$AnimateRunner.all(animationRunners, done);\n\t\n\t            var runner = new $$AnimateRunner({\n\t              end: endFnFactory(),\n\t              cancel: endFnFactory()\n\t            });\n\t\n\t            return runner;\n\t\n\t            function endFnFactory() {\n\t              return function() {\n\t                forEach(animationRunners, function(runner) {\n\t                  // at this point we cannot cancel animations for groups just yet. 1.5+\n\t                  runner.end();\n\t                });\n\t              };\n\t            }\n\t\n\t            function done(status) {\n\t              runner.complete(status);\n\t            }\n\t          }\n\t        };\n\t      } else {\n\t        return prepareAnimation(animationDetails);\n\t      }\n\t    };\n\t\n\t    function prepareAnimation(animationDetails) {\n\t      // TODO(matsko): make sure to check for grouped animations and delegate down to normal animations\n\t      var element = animationDetails.element;\n\t      var event = animationDetails.event;\n\t      var options = animationDetails.options;\n\t      var classes = animationDetails.classes;\n\t      return $$animateJs(element, event, classes, options);\n\t    }\n\t  }];\n\t}];\n\t\n\tvar NG_ANIMATE_ATTR_NAME = 'data-ng-animate';\n\tvar NG_ANIMATE_PIN_DATA = '$ngAnimatePin';\n\tvar $$AnimateQueueProvider = ['$animateProvider', function($animateProvider) {\n\t  var PRE_DIGEST_STATE = 1;\n\t  var RUNNING_STATE = 2;\n\t  var ONE_SPACE = ' ';\n\t\n\t  var rules = this.rules = {\n\t    skip: [],\n\t    cancel: [],\n\t    join: []\n\t  };\n\t\n\t  function makeTruthyCssClassMap(classString) {\n\t    if (!classString) {\n\t      return null;\n\t    }\n\t\n\t    var keys = classString.split(ONE_SPACE);\n\t    var map = Object.create(null);\n\t\n\t    forEach(keys, function(key) {\n\t      map[key] = true;\n\t    });\n\t    return map;\n\t  }\n\t\n\t  function hasMatchingClasses(newClassString, currentClassString) {\n\t    if (newClassString && currentClassString) {\n\t      var currentClassMap = makeTruthyCssClassMap(currentClassString);\n\t      return newClassString.split(ONE_SPACE).some(function(className) {\n\t        return currentClassMap[className];\n\t      });\n\t    }\n\t  }\n\t\n\t  function isAllowed(ruleType, element, currentAnimation, previousAnimation) {\n\t    return rules[ruleType].some(function(fn) {\n\t      return fn(element, currentAnimation, previousAnimation);\n\t    });\n\t  }\n\t\n\t  function hasAnimationClasses(animation, and) {\n\t    var a = (animation.addClass || '').length > 0;\n\t    var b = (animation.removeClass || '').length > 0;\n\t    return and ? a && b : a || b;\n\t  }\n\t\n\t  rules.join.push(function(element, newAnimation, currentAnimation) {\n\t    // if the new animation is class-based then we can just tack that on\n\t    return !newAnimation.structural && hasAnimationClasses(newAnimation);\n\t  });\n\t\n\t  rules.skip.push(function(element, newAnimation, currentAnimation) {\n\t    // there is no need to animate anything if no classes are being added and\n\t    // there is no structural animation that will be triggered\n\t    return !newAnimation.structural && !hasAnimationClasses(newAnimation);\n\t  });\n\t\n\t  rules.skip.push(function(element, newAnimation, currentAnimation) {\n\t    // why should we trigger a new structural animation if the element will\n\t    // be removed from the DOM anyway?\n\t    return currentAnimation.event == 'leave' && newAnimation.structural;\n\t  });\n\t\n\t  rules.skip.push(function(element, newAnimation, currentAnimation) {\n\t    // if there is an ongoing current animation then don't even bother running the class-based animation\n\t    return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;\n\t  });\n\t\n\t  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n\t    // there can never be two structural animations running at the same time\n\t    return currentAnimation.structural && newAnimation.structural;\n\t  });\n\t\n\t  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n\t    // if the previous animation is already running, but the new animation will\n\t    // be triggered, but the new animation is structural\n\t    return currentAnimation.state === RUNNING_STATE && newAnimation.structural;\n\t  });\n\t\n\t  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n\t    // cancel the animation if classes added / removed in both animation cancel each other out,\n\t    // but only if the current animation isn't structural\n\t\n\t    if (currentAnimation.structural) return false;\n\t\n\t    var nA = newAnimation.addClass;\n\t    var nR = newAnimation.removeClass;\n\t    var cA = currentAnimation.addClass;\n\t    var cR = currentAnimation.removeClass;\n\t\n\t    // early detection to save the global CPU shortage :)\n\t    if ((isUndefined(nA) && isUndefined(nR)) || (isUndefined(cA) && isUndefined(cR))) {\n\t      return false;\n\t    }\n\t\n\t    return hasMatchingClasses(nA, cR) || hasMatchingClasses(nR, cA);\n\t  });\n\t\n\t  this.$get = ['$$rAF', '$rootScope', '$rootElement', '$document', '$$HashMap',\n\t               '$$animation', '$$AnimateRunner', '$templateRequest', '$$jqLite', '$$forceReflow',\n\t       function($$rAF,   $rootScope,   $rootElement,   $document,   $$HashMap,\n\t                $$animation,   $$AnimateRunner,   $templateRequest,   $$jqLite,   $$forceReflow) {\n\t\n\t    var activeAnimationsLookup = new $$HashMap();\n\t    var disabledElementsLookup = new $$HashMap();\n\t    var animationsEnabled = null;\n\t\n\t    function postDigestTaskFactory() {\n\t      var postDigestCalled = false;\n\t      return function(fn) {\n\t        // we only issue a call to postDigest before\n\t        // it has first passed. This prevents any callbacks\n\t        // from not firing once the animation has completed\n\t        // since it will be out of the digest cycle.\n\t        if (postDigestCalled) {\n\t          fn();\n\t        } else {\n\t          $rootScope.$$postDigest(function() {\n\t            postDigestCalled = true;\n\t            fn();\n\t          });\n\t        }\n\t      };\n\t    }\n\t\n\t    // Wait until all directive and route-related templates are downloaded and\n\t    // compiled. The $templateRequest.totalPendingRequests variable keeps track of\n\t    // all of the remote templates being currently downloaded. If there are no\n\t    // templates currently downloading then the watcher will still fire anyway.\n\t    var deregisterWatch = $rootScope.$watch(\n\t      function() { return $templateRequest.totalPendingRequests === 0; },\n\t      function(isEmpty) {\n\t        if (!isEmpty) return;\n\t        deregisterWatch();\n\t\n\t        // Now that all templates have been downloaded, $animate will wait until\n\t        // the post digest queue is empty before enabling animations. By having two\n\t        // calls to $postDigest calls we can ensure that the flag is enabled at the\n\t        // very end of the post digest queue. Since all of the animations in $animate\n\t        // use $postDigest, it's important that the code below executes at the end.\n\t        // This basically means that the page is fully downloaded and compiled before\n\t        // any animations are triggered.\n\t        $rootScope.$$postDigest(function() {\n\t          $rootScope.$$postDigest(function() {\n\t            // we check for null directly in the event that the application already called\n\t            // .enabled() with whatever arguments that it provided it with\n\t            if (animationsEnabled === null) {\n\t              animationsEnabled = true;\n\t            }\n\t          });\n\t        });\n\t      }\n\t    );\n\t\n\t    var callbackRegistry = {};\n\t\n\t    // remember that the classNameFilter is set during the provider/config\n\t    // stage therefore we can optimize here and setup a helper function\n\t    var classNameFilter = $animateProvider.classNameFilter();\n\t    var isAnimatableClassName = !classNameFilter\n\t              ? function() { return true; }\n\t              : function(className) {\n\t                return classNameFilter.test(className);\n\t              };\n\t\n\t    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\t\n\t    function normalizeAnimationDetails(element, animation) {\n\t      return mergeAnimationDetails(element, animation, {});\n\t    }\n\t\n\t    // IE9-11 has no method \"contains\" in SVG element and in Node.prototype. Bug #10259.\n\t    var contains = window.Node.prototype.contains || function(arg) {\n\t      // jshint bitwise: false\n\t      return this === arg || !!(this.compareDocumentPosition(arg) & 16);\n\t      // jshint bitwise: true\n\t    };\n\t\n\t    function findCallbacks(parent, element, event) {\n\t      var targetNode = getDomNode(element);\n\t      var targetParentNode = getDomNode(parent);\n\t\n\t      var matches = [];\n\t      var entries = callbackRegistry[event];\n\t      if (entries) {\n\t        forEach(entries, function(entry) {\n\t          if (contains.call(entry.node, targetNode)) {\n\t            matches.push(entry.callback);\n\t          } else if (event === 'leave' && contains.call(entry.node, targetParentNode)) {\n\t            matches.push(entry.callback);\n\t          }\n\t        });\n\t      }\n\t\n\t      return matches;\n\t    }\n\t\n\t    function filterFromRegistry(list, matchContainer, matchCallback) {\n\t      var containerNode = extractElementNode(matchContainer);\n\t      return list.filter(function(entry) {\n\t        var isMatch = entry.node === containerNode &&\n\t                        (!matchCallback || entry.callback === matchCallback);\n\t        return !isMatch;\n\t      });\n\t    }\n\t\n\t    function cleanupEventListeners(phase, element) {\n\t      if (phase === 'close' && !element[0].parentNode) {\n\t        // If the element is not attached to a parentNode, it has been removed by\n\t        // the domOperation, and we can safely remove the event callbacks\n\t        $animate.off(element);\n\t      }\n\t    }\n\t\n\t    var $animate = {\n\t      on: function(event, container, callback) {\n\t        var node = extractElementNode(container);\n\t        callbackRegistry[event] = callbackRegistry[event] || [];\n\t        callbackRegistry[event].push({\n\t          node: node,\n\t          callback: callback\n\t        });\n\t\n\t        // Remove the callback when the element is removed from the DOM\n\t        jqLite(container).on('$destroy', function() {\n\t          var animationDetails = activeAnimationsLookup.get(node);\n\t\n\t          if (!animationDetails) {\n\t            // If there's an animation ongoing, the callback calling code will remove\n\t            // the event listeners. If we'd remove here, the callbacks would be removed\n\t            // before the animation ends\n\t            $animate.off(event, container, callback);\n\t          }\n\t        });\n\t      },\n\t\n\t      off: function(event, container, callback) {\n\t        if (arguments.length === 1 && !angular.isString(arguments[0])) {\n\t          container = arguments[0];\n\t          for (var eventType in callbackRegistry) {\n\t            callbackRegistry[eventType] = filterFromRegistry(callbackRegistry[eventType], container);\n\t          }\n\t\n\t          return;\n\t        }\n\t\n\t        var entries = callbackRegistry[event];\n\t        if (!entries) return;\n\t\n\t        callbackRegistry[event] = arguments.length === 1\n\t            ? null\n\t            : filterFromRegistry(entries, container, callback);\n\t      },\n\t\n\t      pin: function(element, parentElement) {\n\t        assertArg(isElement(element), 'element', 'not an element');\n\t        assertArg(isElement(parentElement), 'parentElement', 'not an element');\n\t        element.data(NG_ANIMATE_PIN_DATA, parentElement);\n\t      },\n\t\n\t      push: function(element, event, options, domOperation) {\n\t        options = options || {};\n\t        options.domOperation = domOperation;\n\t        return queueAnimation(element, event, options);\n\t      },\n\t\n\t      // this method has four signatures:\n\t      //  () - global getter\n\t      //  (bool) - global setter\n\t      //  (element) - element getter\n\t      //  (element, bool) - element setter<F37>\n\t      enabled: function(element, bool) {\n\t        var argCount = arguments.length;\n\t\n\t        if (argCount === 0) {\n\t          // () - Global getter\n\t          bool = !!animationsEnabled;\n\t        } else {\n\t          var hasElement = isElement(element);\n\t\n\t          if (!hasElement) {\n\t            // (bool) - Global setter\n\t            bool = animationsEnabled = !!element;\n\t          } else {\n\t            var node = getDomNode(element);\n\t            var recordExists = disabledElementsLookup.get(node);\n\t\n\t            if (argCount === 1) {\n\t              // (element) - Element getter\n\t              bool = !recordExists;\n\t            } else {\n\t              // (element, bool) - Element setter\n\t              disabledElementsLookup.put(node, !bool);\n\t            }\n\t          }\n\t        }\n\t\n\t        return bool;\n\t      }\n\t    };\n\t\n\t    return $animate;\n\t\n\t    function queueAnimation(element, event, initialOptions) {\n\t      // we always make a copy of the options since\n\t      // there should never be any side effects on\n\t      // the input data when running `$animateCss`.\n\t      var options = copy(initialOptions);\n\t\n\t      var node, parent;\n\t      element = stripCommentsFromElement(element);\n\t      if (element) {\n\t        node = getDomNode(element);\n\t        parent = element.parent();\n\t      }\n\t\n\t      options = prepareAnimationOptions(options);\n\t\n\t      // we create a fake runner with a working promise.\n\t      // These methods will become available after the digest has passed\n\t      var runner = new $$AnimateRunner();\n\t\n\t      // this is used to trigger callbacks in postDigest mode\n\t      var runInNextPostDigestOrNow = postDigestTaskFactory();\n\t\n\t      if (isArray(options.addClass)) {\n\t        options.addClass = options.addClass.join(' ');\n\t      }\n\t\n\t      if (options.addClass && !isString(options.addClass)) {\n\t        options.addClass = null;\n\t      }\n\t\n\t      if (isArray(options.removeClass)) {\n\t        options.removeClass = options.removeClass.join(' ');\n\t      }\n\t\n\t      if (options.removeClass && !isString(options.removeClass)) {\n\t        options.removeClass = null;\n\t      }\n\t\n\t      if (options.from && !isObject(options.from)) {\n\t        options.from = null;\n\t      }\n\t\n\t      if (options.to && !isObject(options.to)) {\n\t        options.to = null;\n\t      }\n\t\n\t      // there are situations where a directive issues an animation for\n\t      // a jqLite wrapper that contains only comment nodes... If this\n\t      // happens then there is no way we can perform an animation\n\t      if (!node) {\n\t        close();\n\t        return runner;\n\t      }\n\t\n\t      var className = [node.className, options.addClass, options.removeClass].join(' ');\n\t      if (!isAnimatableClassName(className)) {\n\t        close();\n\t        return runner;\n\t      }\n\t\n\t      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;\n\t\n\t      var documentHidden = $document[0].hidden;\n\t\n\t      // this is a hard disable of all animations for the application or on\n\t      // the element itself, therefore  there is no need to continue further\n\t      // past this point if not enabled\n\t      // Animations are also disabled if the document is currently hidden (page is not visible\n\t      // to the user), because browsers slow down or do not flush calls to requestAnimationFrame\n\t      var skipAnimations = !animationsEnabled || documentHidden || disabledElementsLookup.get(node);\n\t      var existingAnimation = (!skipAnimations && activeAnimationsLookup.get(node)) || {};\n\t      var hasExistingAnimation = !!existingAnimation.state;\n\t\n\t      // there is no point in traversing the same collection of parent ancestors if a followup\n\t      // animation will be run on the same element that already did all that checking work\n\t      if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state != PRE_DIGEST_STATE)) {\n\t        skipAnimations = !areAnimationsAllowed(element, parent, event);\n\t      }\n\t\n\t      if (skipAnimations) {\n\t        // Callbacks should fire even if the document is hidden (regression fix for issue #14120)\n\t        if (documentHidden) notifyProgress(runner, event, 'start');\n\t        close();\n\t        if (documentHidden) notifyProgress(runner, event, 'close');\n\t        return runner;\n\t      }\n\t\n\t      if (isStructural) {\n\t        closeChildAnimations(element);\n\t      }\n\t\n\t      var newAnimation = {\n\t        structural: isStructural,\n\t        element: element,\n\t        event: event,\n\t        addClass: options.addClass,\n\t        removeClass: options.removeClass,\n\t        close: close,\n\t        options: options,\n\t        runner: runner\n\t      };\n\t\n\t      if (hasExistingAnimation) {\n\t        var skipAnimationFlag = isAllowed('skip', element, newAnimation, existingAnimation);\n\t        if (skipAnimationFlag) {\n\t          if (existingAnimation.state === RUNNING_STATE) {\n\t            close();\n\t            return runner;\n\t          } else {\n\t            mergeAnimationDetails(element, existingAnimation, newAnimation);\n\t            return existingAnimation.runner;\n\t          }\n\t        }\n\t        var cancelAnimationFlag = isAllowed('cancel', element, newAnimation, existingAnimation);\n\t        if (cancelAnimationFlag) {\n\t          if (existingAnimation.state === RUNNING_STATE) {\n\t            // this will end the animation right away and it is safe\n\t            // to do so since the animation is already running and the\n\t            // runner callback code will run in async\n\t            existingAnimation.runner.end();\n\t          } else if (existingAnimation.structural) {\n\t            // this means that the animation is queued into a digest, but\n\t            // hasn't started yet. Therefore it is safe to run the close\n\t            // method which will call the runner methods in async.\n\t            existingAnimation.close();\n\t          } else {\n\t            // this will merge the new animation options into existing animation options\n\t            mergeAnimationDetails(element, existingAnimation, newAnimation);\n\t\n\t            return existingAnimation.runner;\n\t          }\n\t        } else {\n\t          // a joined animation means that this animation will take over the existing one\n\t          // so an example would involve a leave animation taking over an enter. Then when\n\t          // the postDigest kicks in the enter will be ignored.\n\t          var joinAnimationFlag = isAllowed('join', element, newAnimation, existingAnimation);\n\t          if (joinAnimationFlag) {\n\t            if (existingAnimation.state === RUNNING_STATE) {\n\t              normalizeAnimationDetails(element, newAnimation);\n\t            } else {\n\t              applyGeneratedPreparationClasses(element, isStructural ? event : null, options);\n\t\n\t              event = newAnimation.event = existingAnimation.event;\n\t              options = mergeAnimationDetails(element, existingAnimation, newAnimation);\n\t\n\t              //we return the same runner since only the option values of this animation will\n\t              //be fed into the `existingAnimation`.\n\t              return existingAnimation.runner;\n\t            }\n\t          }\n\t        }\n\t      } else {\n\t        // normalization in this case means that it removes redundant CSS classes that\n\t        // already exist (addClass) or do not exist (removeClass) on the element\n\t        normalizeAnimationDetails(element, newAnimation);\n\t      }\n\t\n\t      // when the options are merged and cleaned up we may end up not having to do\n\t      // an animation at all, therefore we should check this before issuing a post\n\t      // digest callback. Structural animations will always run no matter what.\n\t      var isValidAnimation = newAnimation.structural;\n\t      if (!isValidAnimation) {\n\t        // animate (from/to) can be quickly checked first, otherwise we check if any classes are present\n\t        isValidAnimation = (newAnimation.event === 'animate' && Object.keys(newAnimation.options.to || {}).length > 0)\n\t                            || hasAnimationClasses(newAnimation);\n\t      }\n\t\n\t      if (!isValidAnimation) {\n\t        close();\n\t        clearElementAnimationState(element);\n\t        return runner;\n\t      }\n\t\n\t      // the counter keeps track of cancelled animations\n\t      var counter = (existingAnimation.counter || 0) + 1;\n\t      newAnimation.counter = counter;\n\t\n\t      markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation);\n\t\n\t      $rootScope.$$postDigest(function() {\n\t        var animationDetails = activeAnimationsLookup.get(node);\n\t        var animationCancelled = !animationDetails;\n\t        animationDetails = animationDetails || {};\n\t\n\t        // if addClass/removeClass is called before something like enter then the\n\t        // registered parent element may not be present. The code below will ensure\n\t        // that a final value for parent element is obtained\n\t        var parentElement = element.parent() || [];\n\t\n\t        // animate/structural/class-based animations all have requirements. Otherwise there\n\t        // is no point in performing an animation. The parent node must also be set.\n\t        var isValidAnimation = parentElement.length > 0\n\t                                && (animationDetails.event === 'animate'\n\t                                    || animationDetails.structural\n\t                                    || hasAnimationClasses(animationDetails));\n\t\n\t        // this means that the previous animation was cancelled\n\t        // even if the follow-up animation is the same event\n\t        if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {\n\t          // if another animation did not take over then we need\n\t          // to make sure that the domOperation and options are\n\t          // handled accordingly\n\t          if (animationCancelled) {\n\t            applyAnimationClasses(element, options);\n\t            applyAnimationStyles(element, options);\n\t          }\n\t\n\t          // if the event changed from something like enter to leave then we do\n\t          // it, otherwise if it's the same then the end result will be the same too\n\t          if (animationCancelled || (isStructural && animationDetails.event !== event)) {\n\t            options.domOperation();\n\t            runner.end();\n\t          }\n\t\n\t          // in the event that the element animation was not cancelled or a follow-up animation\n\t          // isn't allowed to animate from here then we need to clear the state of the element\n\t          // so that any future animations won't read the expired animation data.\n\t          if (!isValidAnimation) {\n\t            clearElementAnimationState(element);\n\t          }\n\t\n\t          return;\n\t        }\n\t\n\t        // this combined multiple class to addClass / removeClass into a setClass event\n\t        // so long as a structural event did not take over the animation\n\t        event = !animationDetails.structural && hasAnimationClasses(animationDetails, true)\n\t            ? 'setClass'\n\t            : animationDetails.event;\n\t\n\t        markElementAnimationState(element, RUNNING_STATE);\n\t        var realRunner = $$animation(element, event, animationDetails.options);\n\t\n\t        // this will update the runner's flow-control events based on\n\t        // the `realRunner` object.\n\t        runner.setHost(realRunner);\n\t        notifyProgress(runner, event, 'start', {});\n\t\n\t        realRunner.done(function(status) {\n\t          close(!status);\n\t          var animationDetails = activeAnimationsLookup.get(node);\n\t          if (animationDetails && animationDetails.counter === counter) {\n\t            clearElementAnimationState(getDomNode(element));\n\t          }\n\t          notifyProgress(runner, event, 'close', {});\n\t        });\n\t      });\n\t\n\t      return runner;\n\t\n\t      function notifyProgress(runner, event, phase, data) {\n\t        runInNextPostDigestOrNow(function() {\n\t          var callbacks = findCallbacks(parent, element, event);\n\t          if (callbacks.length) {\n\t            // do not optimize this call here to RAF because\n\t            // we don't know how heavy the callback code here will\n\t            // be and if this code is buffered then this can\n\t            // lead to a performance regression.\n\t            $$rAF(function() {\n\t              forEach(callbacks, function(callback) {\n\t                callback(element, phase, data);\n\t              });\n\t              cleanupEventListeners(phase, element);\n\t            });\n\t          } else {\n\t            cleanupEventListeners(phase, element);\n\t          }\n\t        });\n\t        runner.progress(event, phase, data);\n\t      }\n\t\n\t      function close(reject) { // jshint ignore:line\n\t        clearGeneratedClasses(element, options);\n\t        applyAnimationClasses(element, options);\n\t        applyAnimationStyles(element, options);\n\t        options.domOperation();\n\t        runner.complete(!reject);\n\t      }\n\t    }\n\t\n\t    function closeChildAnimations(element) {\n\t      var node = getDomNode(element);\n\t      var children = node.querySelectorAll('[' + NG_ANIMATE_ATTR_NAME + ']');\n\t      forEach(children, function(child) {\n\t        var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME));\n\t        var animationDetails = activeAnimationsLookup.get(child);\n\t        if (animationDetails) {\n\t          switch (state) {\n\t            case RUNNING_STATE:\n\t              animationDetails.runner.end();\n\t              /* falls through */\n\t            case PRE_DIGEST_STATE:\n\t              activeAnimationsLookup.remove(child);\n\t              break;\n\t          }\n\t        }\n\t      });\n\t    }\n\t\n\t    function clearElementAnimationState(element) {\n\t      var node = getDomNode(element);\n\t      node.removeAttribute(NG_ANIMATE_ATTR_NAME);\n\t      activeAnimationsLookup.remove(node);\n\t    }\n\t\n\t    function isMatchingElement(nodeOrElmA, nodeOrElmB) {\n\t      return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);\n\t    }\n\t\n\t    /**\n\t     * This fn returns false if any of the following is true:\n\t     * a) animations on any parent element are disabled, and animations on the element aren't explicitly allowed\n\t     * b) a parent element has an ongoing structural animation, and animateChildren is false\n\t     * c) the element is not a child of the body\n\t     * d) the element is not a child of the $rootElement\n\t     */\n\t    function areAnimationsAllowed(element, parentElement, event) {\n\t      var bodyElement = jqLite($document[0].body);\n\t      var bodyElementDetected = isMatchingElement(element, bodyElement) || element[0].nodeName === 'HTML';\n\t      var rootElementDetected = isMatchingElement(element, $rootElement);\n\t      var parentAnimationDetected = false;\n\t      var animateChildren;\n\t      var elementDisabled = disabledElementsLookup.get(getDomNode(element));\n\t\n\t      var parentHost = jqLite.data(element[0], NG_ANIMATE_PIN_DATA);\n\t      if (parentHost) {\n\t        parentElement = parentHost;\n\t      }\n\t\n\t      parentElement = getDomNode(parentElement);\n\t\n\t      while (parentElement) {\n\t        if (!rootElementDetected) {\n\t          // angular doesn't want to attempt to animate elements outside of the application\n\t          // therefore we need to ensure that the rootElement is an ancestor of the current element\n\t          rootElementDetected = isMatchingElement(parentElement, $rootElement);\n\t        }\n\t\n\t        if (parentElement.nodeType !== ELEMENT_NODE) {\n\t          // no point in inspecting the #document element\n\t          break;\n\t        }\n\t\n\t        var details = activeAnimationsLookup.get(parentElement) || {};\n\t        // either an enter, leave or move animation will commence\n\t        // therefore we can't allow any animations to take place\n\t        // but if a parent animation is class-based then that's ok\n\t        if (!parentAnimationDetected) {\n\t          var parentElementDisabled = disabledElementsLookup.get(parentElement);\n\t\n\t          if (parentElementDisabled === true && elementDisabled !== false) {\n\t            // disable animations if the user hasn't explicitly enabled animations on the\n\t            // current element\n\t            elementDisabled = true;\n\t            // element is disabled via parent element, no need to check anything else\n\t            break;\n\t          } else if (parentElementDisabled === false) {\n\t            elementDisabled = false;\n\t          }\n\t          parentAnimationDetected = details.structural;\n\t        }\n\t\n\t        if (isUndefined(animateChildren) || animateChildren === true) {\n\t          var value = jqLite.data(parentElement, NG_ANIMATE_CHILDREN_DATA);\n\t          if (isDefined(value)) {\n\t            animateChildren = value;\n\t          }\n\t        }\n\t\n\t        // there is no need to continue traversing at this point\n\t        if (parentAnimationDetected && animateChildren === false) break;\n\t\n\t        if (!bodyElementDetected) {\n\t          // we also need to ensure that the element is or will be a part of the body element\n\t          // otherwise it is pointless to even issue an animation to be rendered\n\t          bodyElementDetected = isMatchingElement(parentElement, bodyElement);\n\t        }\n\t\n\t        if (bodyElementDetected && rootElementDetected) {\n\t          // If both body and root have been found, any other checks are pointless,\n\t          // as no animation data should live outside the application\n\t          break;\n\t        }\n\t\n\t        if (!rootElementDetected) {\n\t          // If no rootElement is detected, check if the parentElement is pinned to another element\n\t          parentHost = jqLite.data(parentElement, NG_ANIMATE_PIN_DATA);\n\t          if (parentHost) {\n\t            // The pin target element becomes the next parent element\n\t            parentElement = getDomNode(parentHost);\n\t            continue;\n\t          }\n\t        }\n\t\n\t        parentElement = parentElement.parentNode;\n\t      }\n\t\n\t      var allowAnimation = (!parentAnimationDetected || animateChildren) && elementDisabled !== true;\n\t      return allowAnimation && rootElementDetected && bodyElementDetected;\n\t    }\n\t\n\t    function markElementAnimationState(element, state, details) {\n\t      details = details || {};\n\t      details.state = state;\n\t\n\t      var node = getDomNode(element);\n\t      node.setAttribute(NG_ANIMATE_ATTR_NAME, state);\n\t\n\t      var oldValue = activeAnimationsLookup.get(node);\n\t      var newValue = oldValue\n\t          ? extend(oldValue, details)\n\t          : details;\n\t      activeAnimationsLookup.put(node, newValue);\n\t    }\n\t  }];\n\t}];\n\t\n\tvar $$AnimationProvider = ['$animateProvider', function($animateProvider) {\n\t  var NG_ANIMATE_REF_ATTR = 'ng-animate-ref';\n\t\n\t  var drivers = this.drivers = [];\n\t\n\t  var RUNNER_STORAGE_KEY = '$$animationRunner';\n\t\n\t  function setRunner(element, runner) {\n\t    element.data(RUNNER_STORAGE_KEY, runner);\n\t  }\n\t\n\t  function removeRunner(element) {\n\t    element.removeData(RUNNER_STORAGE_KEY);\n\t  }\n\t\n\t  function getRunner(element) {\n\t    return element.data(RUNNER_STORAGE_KEY);\n\t  }\n\t\n\t  this.$get = ['$$jqLite', '$rootScope', '$injector', '$$AnimateRunner', '$$HashMap', '$$rAFScheduler',\n\t       function($$jqLite,   $rootScope,   $injector,   $$AnimateRunner,   $$HashMap,   $$rAFScheduler) {\n\t\n\t    var animationQueue = [];\n\t    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\t\n\t    function sortAnimations(animations) {\n\t      var tree = { children: [] };\n\t      var i, lookup = new $$HashMap();\n\t\n\t      // this is done first beforehand so that the hashmap\n\t      // is filled with a list of the elements that will be animated\n\t      for (i = 0; i < animations.length; i++) {\n\t        var animation = animations[i];\n\t        lookup.put(animation.domNode, animations[i] = {\n\t          domNode: animation.domNode,\n\t          fn: animation.fn,\n\t          children: []\n\t        });\n\t      }\n\t\n\t      for (i = 0; i < animations.length; i++) {\n\t        processNode(animations[i]);\n\t      }\n\t\n\t      return flatten(tree);\n\t\n\t      function processNode(entry) {\n\t        if (entry.processed) return entry;\n\t        entry.processed = true;\n\t\n\t        var elementNode = entry.domNode;\n\t        var parentNode = elementNode.parentNode;\n\t        lookup.put(elementNode, entry);\n\t\n\t        var parentEntry;\n\t        while (parentNode) {\n\t          parentEntry = lookup.get(parentNode);\n\t          if (parentEntry) {\n\t            if (!parentEntry.processed) {\n\t              parentEntry = processNode(parentEntry);\n\t            }\n\t            break;\n\t          }\n\t          parentNode = parentNode.parentNode;\n\t        }\n\t\n\t        (parentEntry || tree).children.push(entry);\n\t        return entry;\n\t      }\n\t\n\t      function flatten(tree) {\n\t        var result = [];\n\t        var queue = [];\n\t        var i;\n\t\n\t        for (i = 0; i < tree.children.length; i++) {\n\t          queue.push(tree.children[i]);\n\t        }\n\t\n\t        var remainingLevelEntries = queue.length;\n\t        var nextLevelEntries = 0;\n\t        var row = [];\n\t\n\t        for (i = 0; i < queue.length; i++) {\n\t          var entry = queue[i];\n\t          if (remainingLevelEntries <= 0) {\n\t            remainingLevelEntries = nextLevelEntries;\n\t            nextLevelEntries = 0;\n\t            result.push(row);\n\t            row = [];\n\t          }\n\t          row.push(entry.fn);\n\t          entry.children.forEach(function(childEntry) {\n\t            nextLevelEntries++;\n\t            queue.push(childEntry);\n\t          });\n\t          remainingLevelEntries--;\n\t        }\n\t\n\t        if (row.length) {\n\t          result.push(row);\n\t        }\n\t\n\t        return result;\n\t      }\n\t    }\n\t\n\t    // TODO(matsko): document the signature in a better way\n\t    return function(element, event, options) {\n\t      options = prepareAnimationOptions(options);\n\t      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;\n\t\n\t      // there is no animation at the current moment, however\n\t      // these runner methods will get later updated with the\n\t      // methods leading into the driver's end/cancel methods\n\t      // for now they just stop the animation from starting\n\t      var runner = new $$AnimateRunner({\n\t        end: function() { close(); },\n\t        cancel: function() { close(true); }\n\t      });\n\t\n\t      if (!drivers.length) {\n\t        close();\n\t        return runner;\n\t      }\n\t\n\t      setRunner(element, runner);\n\t\n\t      var classes = mergeClasses(element.attr('class'), mergeClasses(options.addClass, options.removeClass));\n\t      var tempClasses = options.tempClasses;\n\t      if (tempClasses) {\n\t        classes += ' ' + tempClasses;\n\t        options.tempClasses = null;\n\t      }\n\t\n\t      var prepareClassName;\n\t      if (isStructural) {\n\t        prepareClassName = 'ng-' + event + PREPARE_CLASS_SUFFIX;\n\t        $$jqLite.addClass(element, prepareClassName);\n\t      }\n\t\n\t      animationQueue.push({\n\t        // this data is used by the postDigest code and passed into\n\t        // the driver step function\n\t        element: element,\n\t        classes: classes,\n\t        event: event,\n\t        structural: isStructural,\n\t        options: options,\n\t        beforeStart: beforeStart,\n\t        close: close\n\t      });\n\t\n\t      element.on('$destroy', handleDestroyedElement);\n\t\n\t      // we only want there to be one function called within the post digest\n\t      // block. This way we can group animations for all the animations that\n\t      // were apart of the same postDigest flush call.\n\t      if (animationQueue.length > 1) return runner;\n\t\n\t      $rootScope.$$postDigest(function() {\n\t        var animations = [];\n\t        forEach(animationQueue, function(entry) {\n\t          // the element was destroyed early on which removed the runner\n\t          // form its storage. This means we can't animate this element\n\t          // at all and it already has been closed due to destruction.\n\t          if (getRunner(entry.element)) {\n\t            animations.push(entry);\n\t          } else {\n\t            entry.close();\n\t          }\n\t        });\n\t\n\t        // now any future animations will be in another postDigest\n\t        animationQueue.length = 0;\n\t\n\t        var groupedAnimations = groupAnimations(animations);\n\t        var toBeSortedAnimations = [];\n\t\n\t        forEach(groupedAnimations, function(animationEntry) {\n\t          toBeSortedAnimations.push({\n\t            domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),\n\t            fn: function triggerAnimationStart() {\n\t              // it's important that we apply the `ng-animate` CSS class and the\n\t              // temporary classes before we do any driver invoking since these\n\t              // CSS classes may be required for proper CSS detection.\n\t              animationEntry.beforeStart();\n\t\n\t              var startAnimationFn, closeFn = animationEntry.close;\n\t\n\t              // in the event that the element was removed before the digest runs or\n\t              // during the RAF sequencing then we should not trigger the animation.\n\t              var targetElement = animationEntry.anchors\n\t                  ? (animationEntry.from.element || animationEntry.to.element)\n\t                  : animationEntry.element;\n\t\n\t              if (getRunner(targetElement)) {\n\t                var operation = invokeFirstDriver(animationEntry);\n\t                if (operation) {\n\t                  startAnimationFn = operation.start;\n\t                }\n\t              }\n\t\n\t              if (!startAnimationFn) {\n\t                closeFn();\n\t              } else {\n\t                var animationRunner = startAnimationFn();\n\t                animationRunner.done(function(status) {\n\t                  closeFn(!status);\n\t                });\n\t                updateAnimationRunners(animationEntry, animationRunner);\n\t              }\n\t            }\n\t          });\n\t        });\n\t\n\t        // we need to sort each of the animations in order of parent to child\n\t        // relationships. This ensures that the child classes are applied at the\n\t        // right time.\n\t        $$rAFScheduler(sortAnimations(toBeSortedAnimations));\n\t      });\n\t\n\t      return runner;\n\t\n\t      // TODO(matsko): change to reference nodes\n\t      function getAnchorNodes(node) {\n\t        var SELECTOR = '[' + NG_ANIMATE_REF_ATTR + ']';\n\t        var items = node.hasAttribute(NG_ANIMATE_REF_ATTR)\n\t              ? [node]\n\t              : node.querySelectorAll(SELECTOR);\n\t        var anchors = [];\n\t        forEach(items, function(node) {\n\t          var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);\n\t          if (attr && attr.length) {\n\t            anchors.push(node);\n\t          }\n\t        });\n\t        return anchors;\n\t      }\n\t\n\t      function groupAnimations(animations) {\n\t        var preparedAnimations = [];\n\t        var refLookup = {};\n\t        forEach(animations, function(animation, index) {\n\t          var element = animation.element;\n\t          var node = getDomNode(element);\n\t          var event = animation.event;\n\t          var enterOrMove = ['enter', 'move'].indexOf(event) >= 0;\n\t          var anchorNodes = animation.structural ? getAnchorNodes(node) : [];\n\t\n\t          if (anchorNodes.length) {\n\t            var direction = enterOrMove ? 'to' : 'from';\n\t\n\t            forEach(anchorNodes, function(anchor) {\n\t              var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);\n\t              refLookup[key] = refLookup[key] || {};\n\t              refLookup[key][direction] = {\n\t                animationID: index,\n\t                element: jqLite(anchor)\n\t              };\n\t            });\n\t          } else {\n\t            preparedAnimations.push(animation);\n\t          }\n\t        });\n\t\n\t        var usedIndicesLookup = {};\n\t        var anchorGroups = {};\n\t        forEach(refLookup, function(operations, key) {\n\t          var from = operations.from;\n\t          var to = operations.to;\n\t\n\t          if (!from || !to) {\n\t            // only one of these is set therefore we can't have an\n\t            // anchor animation since all three pieces are required\n\t            var index = from ? from.animationID : to.animationID;\n\t            var indexKey = index.toString();\n\t            if (!usedIndicesLookup[indexKey]) {\n\t              usedIndicesLookup[indexKey] = true;\n\t              preparedAnimations.push(animations[index]);\n\t            }\n\t            return;\n\t          }\n\t\n\t          var fromAnimation = animations[from.animationID];\n\t          var toAnimation = animations[to.animationID];\n\t          var lookupKey = from.animationID.toString();\n\t          if (!anchorGroups[lookupKey]) {\n\t            var group = anchorGroups[lookupKey] = {\n\t              structural: true,\n\t              beforeStart: function() {\n\t                fromAnimation.beforeStart();\n\t                toAnimation.beforeStart();\n\t              },\n\t              close: function() {\n\t                fromAnimation.close();\n\t                toAnimation.close();\n\t              },\n\t              classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),\n\t              from: fromAnimation,\n\t              to: toAnimation,\n\t              anchors: [] // TODO(matsko): change to reference nodes\n\t            };\n\t\n\t            // the anchor animations require that the from and to elements both have at least\n\t            // one shared CSS class which effectively marries the two elements together to use\n\t            // the same animation driver and to properly sequence the anchor animation.\n\t            if (group.classes.length) {\n\t              preparedAnimations.push(group);\n\t            } else {\n\t              preparedAnimations.push(fromAnimation);\n\t              preparedAnimations.push(toAnimation);\n\t            }\n\t          }\n\t\n\t          anchorGroups[lookupKey].anchors.push({\n\t            'out': from.element, 'in': to.element\n\t          });\n\t        });\n\t\n\t        return preparedAnimations;\n\t      }\n\t\n\t      function cssClassesIntersection(a,b) {\n\t        a = a.split(' ');\n\t        b = b.split(' ');\n\t        var matches = [];\n\t\n\t        for (var i = 0; i < a.length; i++) {\n\t          var aa = a[i];\n\t          if (aa.substring(0,3) === 'ng-') continue;\n\t\n\t          for (var j = 0; j < b.length; j++) {\n\t            if (aa === b[j]) {\n\t              matches.push(aa);\n\t              break;\n\t            }\n\t          }\n\t        }\n\t\n\t        return matches.join(' ');\n\t      }\n\t\n\t      function invokeFirstDriver(animationDetails) {\n\t        // we loop in reverse order since the more general drivers (like CSS and JS)\n\t        // may attempt more elements, but custom drivers are more particular\n\t        for (var i = drivers.length - 1; i >= 0; i--) {\n\t          var driverName = drivers[i];\n\t          var factory = $injector.get(driverName);\n\t          var driver = factory(animationDetails);\n\t          if (driver) {\n\t            return driver;\n\t          }\n\t        }\n\t      }\n\t\n\t      function beforeStart() {\n\t        element.addClass(NG_ANIMATE_CLASSNAME);\n\t        if (tempClasses) {\n\t          $$jqLite.addClass(element, tempClasses);\n\t        }\n\t        if (prepareClassName) {\n\t          $$jqLite.removeClass(element, prepareClassName);\n\t          prepareClassName = null;\n\t        }\n\t      }\n\t\n\t      function updateAnimationRunners(animation, newRunner) {\n\t        if (animation.from && animation.to) {\n\t          update(animation.from.element);\n\t          update(animation.to.element);\n\t        } else {\n\t          update(animation.element);\n\t        }\n\t\n\t        function update(element) {\n\t          var runner = getRunner(element);\n\t          if (runner) runner.setHost(newRunner);\n\t        }\n\t      }\n\t\n\t      function handleDestroyedElement() {\n\t        var runner = getRunner(element);\n\t        if (runner && (event !== 'leave' || !options.$$domOperationFired)) {\n\t          runner.end();\n\t        }\n\t      }\n\t\n\t      function close(rejected) { // jshint ignore:line\n\t        element.off('$destroy', handleDestroyedElement);\n\t        removeRunner(element);\n\t\n\t        applyAnimationClasses(element, options);\n\t        applyAnimationStyles(element, options);\n\t        options.domOperation();\n\t\n\t        if (tempClasses) {\n\t          $$jqLite.removeClass(element, tempClasses);\n\t        }\n\t\n\t        element.removeClass(NG_ANIMATE_CLASSNAME);\n\t        runner.complete(!rejected);\n\t      }\n\t    };\n\t  }];\n\t}];\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ngAnimateSwap\n\t * @restrict A\n\t * @scope\n\t *\n\t * @description\n\t *\n\t * ngAnimateSwap is a animation-oriented directive that allows for the container to\n\t * be removed and entered in whenever the associated expression changes. A\n\t * common usecase for this directive is a rotating banner or slider component which\n\t * contains one image being present at a time. When the active image changes\n\t * then the old image will perform a `leave` animation and the new element\n\t * will be inserted via an `enter` animation.\n\t *\n\t * @animations\n\t * | Animation                        | Occurs                               |\n\t * |----------------------------------|--------------------------------------|\n\t * | {@link ng.$animate#enter enter}  | when the new element is inserted to the DOM  |\n\t * | {@link ng.$animate#leave leave}  | when the old element is removed from the DOM |\n\t *\n\t * @example\n\t * <example name=\"ngAnimateSwap-directive\" module=\"ngAnimateSwapExample\"\n\t *          deps=\"angular-animate.js\"\n\t *          animations=\"true\" fixBase=\"true\">\n\t *   <file name=\"index.html\">\n\t *     <div class=\"container\" ng-controller=\"AppCtrl\">\n\t *       <div ng-animate-swap=\"number\" class=\"cell swap-animation\" ng-class=\"colorClass(number)\">\n\t *         {{ number }}\n\t *       </div>\n\t *     </div>\n\t *   </file>\n\t *   <file name=\"script.js\">\n\t *     angular.module('ngAnimateSwapExample', ['ngAnimate'])\n\t *       .controller('AppCtrl', ['$scope', '$interval', function($scope, $interval) {\n\t *         $scope.number = 0;\n\t *         $interval(function() {\n\t *           $scope.number++;\n\t *         }, 1000);\n\t *\n\t *         var colors = ['red','blue','green','yellow','orange'];\n\t *         $scope.colorClass = function(number) {\n\t *           return colors[number % colors.length];\n\t *         };\n\t *       }]);\n\t *   </file>\n\t *  <file name=\"animations.css\">\n\t *  .container {\n\t *    height:250px;\n\t *    width:250px;\n\t *    position:relative;\n\t *    overflow:hidden;\n\t *    border:2px solid black;\n\t *  }\n\t *  .container .cell {\n\t *    font-size:150px;\n\t *    text-align:center;\n\t *    line-height:250px;\n\t *    position:absolute;\n\t *    top:0;\n\t *    left:0;\n\t *    right:0;\n\t *    border-bottom:2px solid black;\n\t *  }\n\t *  .swap-animation.ng-enter, .swap-animation.ng-leave {\n\t *    transition:0.5s linear all;\n\t *  }\n\t *  .swap-animation.ng-enter {\n\t *    top:-250px;\n\t *  }\n\t *  .swap-animation.ng-enter-active {\n\t *    top:0px;\n\t *  }\n\t *  .swap-animation.ng-leave {\n\t *    top:0px;\n\t *  }\n\t *  .swap-animation.ng-leave-active {\n\t *    top:250px;\n\t *  }\n\t *  .red { background:red; }\n\t *  .green { background:green; }\n\t *  .blue { background:blue; }\n\t *  .yellow { background:yellow; }\n\t *  .orange { background:orange; }\n\t *  </file>\n\t * </example>\n\t */\n\tvar ngAnimateSwapDirective = ['$animate', '$rootScope', function($animate, $rootScope) {\n\t  return {\n\t    restrict: 'A',\n\t    transclude: 'element',\n\t    terminal: true,\n\t    priority: 600, // we use 600 here to ensure that the directive is caught before others\n\t    link: function(scope, $element, attrs, ctrl, $transclude) {\n\t      var previousElement, previousScope;\n\t      scope.$watchCollection(attrs.ngAnimateSwap || attrs['for'], function(value) {\n\t        if (previousElement) {\n\t          $animate.leave(previousElement);\n\t        }\n\t        if (previousScope) {\n\t          previousScope.$destroy();\n\t          previousScope = null;\n\t        }\n\t        if (value || value === 0) {\n\t          previousScope = scope.$new();\n\t          $transclude(previousScope, function(element) {\n\t            previousElement = element;\n\t            $animate.enter(element, null, $element);\n\t          });\n\t        }\n\t      });\n\t    }\n\t  };\n\t}];\n\t\n\t/* global angularAnimateModule: true,\n\t\n\t   ngAnimateSwapDirective,\n\t   $$AnimateAsyncRunFactory,\n\t   $$rAFSchedulerFactory,\n\t   $$AnimateChildrenDirective,\n\t   $$AnimateQueueProvider,\n\t   $$AnimationProvider,\n\t   $AnimateCssProvider,\n\t   $$AnimateCssDriverProvider,\n\t   $$AnimateJsProvider,\n\t   $$AnimateJsDriverProvider,\n\t*/\n\t\n\t/**\n\t * @ngdoc module\n\t * @name ngAnimate\n\t * @description\n\t *\n\t * The `ngAnimate` module provides support for CSS-based animations (keyframes and transitions) as well as JavaScript-based animations via\n\t * callback hooks. Animations are not enabled by default, however, by including `ngAnimate` the animation hooks are enabled for an Angular app.\n\t *\n\t * <div doc-module-components=\"ngAnimate\"></div>\n\t *\n\t * # Usage\n\t * Simply put, there are two ways to make use of animations when ngAnimate is used: by using **CSS** and **JavaScript**. The former works purely based\n\t * using CSS (by using matching CSS selectors/styles) and the latter triggers animations that are registered via `module.animation()`. For\n\t * both CSS and JS animations the sole requirement is to have a matching `CSS class` that exists both in the registered animation and within\n\t * the HTML element that the animation will be triggered on.\n\t *\n\t * ## Directive Support\n\t * The following directives are \"animation aware\":\n\t *\n\t * | Directive                                                                                                | Supported Animations                                                     |\n\t * |----------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|\n\t * | {@link ng.directive:ngRepeat#animations ngRepeat}                                                        | enter, leave and move                                                    |\n\t * | {@link ngRoute.directive:ngView#animations ngView}                                                       | enter and leave                                                          |\n\t * | {@link ng.directive:ngInclude#animations ngInclude}                                                      | enter and leave                                                          |\n\t * | {@link ng.directive:ngSwitch#animations ngSwitch}                                                        | enter and leave                                                          |\n\t * | {@link ng.directive:ngIf#animations ngIf}                                                                | enter and leave                                                          |\n\t * | {@link ng.directive:ngClass#animations ngClass}                                                          | add and remove (the CSS class(es) present)                               |\n\t * | {@link ng.directive:ngShow#animations ngShow} & {@link ng.directive:ngHide#animations ngHide}            | add and remove (the ng-hide class value)                                 |\n\t * | {@link ng.directive:form#animation-hooks form} & {@link ng.directive:ngModel#animation-hooks ngModel}    | add and remove (dirty, pristine, valid, invalid & all other validations) |\n\t * | {@link module:ngMessages#animations ngMessages}                                                          | add and remove (ng-active & ng-inactive)                                 |\n\t * | {@link module:ngMessages#animations ngMessage}                                                           | enter and leave                                                          |\n\t *\n\t * (More information can be found by visiting each the documentation associated with each directive.)\n\t *\n\t * ## CSS-based Animations\n\t *\n\t * CSS-based animations with ngAnimate are unique since they require no JavaScript code at all. By using a CSS class that we reference between our HTML\n\t * and CSS code we can create an animation that will be picked up by Angular when an the underlying directive performs an operation.\n\t *\n\t * The example below shows how an `enter` animation can be made possible on an element using `ng-if`:\n\t *\n\t * ```html\n\t * <div ng-if=\"bool\" class=\"fade\">\n\t *    Fade me in out\n\t * </div>\n\t * <button ng-click=\"bool=true\">Fade In!</button>\n\t * <button ng-click=\"bool=false\">Fade Out!</button>\n\t * ```\n\t *\n\t * Notice the CSS class **fade**? We can now create the CSS transition code that references this class:\n\t *\n\t * ```css\n\t * /&#42; The starting CSS styles for the enter animation &#42;/\n\t * .fade.ng-enter {\n\t *   transition:0.5s linear all;\n\t *   opacity:0;\n\t * }\n\t *\n\t * /&#42; The finishing CSS styles for the enter animation &#42;/\n\t * .fade.ng-enter.ng-enter-active {\n\t *   opacity:1;\n\t * }\n\t * ```\n\t *\n\t * The key thing to remember here is that, depending on the animation event (which each of the directives above trigger depending on what's going on) two\n\t * generated CSS classes will be applied to the element; in the example above we have `.ng-enter` and `.ng-enter-active`. For CSS transitions, the transition\n\t * code **must** be defined within the starting CSS class (in this case `.ng-enter`). The destination class is what the transition will animate towards.\n\t *\n\t * If for example we wanted to create animations for `leave` and `move` (ngRepeat triggers move) then we can do so using the same CSS naming conventions:\n\t *\n\t * ```css\n\t * /&#42; now the element will fade out before it is removed from the DOM &#42;/\n\t * .fade.ng-leave {\n\t *   transition:0.5s linear all;\n\t *   opacity:1;\n\t * }\n\t * .fade.ng-leave.ng-leave-active {\n\t *   opacity:0;\n\t * }\n\t * ```\n\t *\n\t * We can also make use of **CSS Keyframes** by referencing the keyframe animation within the starting CSS class:\n\t *\n\t * ```css\n\t * /&#42; there is no need to define anything inside of the destination\n\t * CSS class since the keyframe will take charge of the animation &#42;/\n\t * .fade.ng-leave {\n\t *   animation: my_fade_animation 0.5s linear;\n\t *   -webkit-animation: my_fade_animation 0.5s linear;\n\t * }\n\t *\n\t * @keyframes my_fade_animation {\n\t *   from { opacity:1; }\n\t *   to { opacity:0; }\n\t * }\n\t *\n\t * @-webkit-keyframes my_fade_animation {\n\t *   from { opacity:1; }\n\t *   to { opacity:0; }\n\t * }\n\t * ```\n\t *\n\t * Feel free also mix transitions and keyframes together as well as any other CSS classes on the same element.\n\t *\n\t * ### CSS Class-based Animations\n\t *\n\t * Class-based animations (animations that are triggered via `ngClass`, `ngShow`, `ngHide` and some other directives) have a slightly different\n\t * naming convention. Class-based animations are basic enough that a standard transition or keyframe can be referenced on the class being added\n\t * and removed.\n\t *\n\t * For example if we wanted to do a CSS animation for `ngHide` then we place an animation on the `.ng-hide` CSS class:\n\t *\n\t * ```html\n\t * <div ng-show=\"bool\" class=\"fade\">\n\t *   Show and hide me\n\t * </div>\n\t * <button ng-click=\"bool=!bool\">Toggle</button>\n\t *\n\t * <style>\n\t * .fade.ng-hide {\n\t *   transition:0.5s linear all;\n\t *   opacity:0;\n\t * }\n\t * </style>\n\t * ```\n\t *\n\t * All that is going on here with ngShow/ngHide behind the scenes is the `.ng-hide` class is added/removed (when the hidden state is valid). Since\n\t * ngShow and ngHide are animation aware then we can match up a transition and ngAnimate handles the rest.\n\t *\n\t * In addition the addition and removal of the CSS class, ngAnimate also provides two helper methods that we can use to further decorate the animation\n\t * with CSS styles.\n\t *\n\t * ```html\n\t * <div ng-class=\"{on:onOff}\" class=\"highlight\">\n\t *   Highlight this box\n\t * </div>\n\t * <button ng-click=\"onOff=!onOff\">Toggle</button>\n\t *\n\t * <style>\n\t * .highlight {\n\t *   transition:0.5s linear all;\n\t * }\n\t * .highlight.on-add {\n\t *   background:white;\n\t * }\n\t * .highlight.on {\n\t *   background:yellow;\n\t * }\n\t * .highlight.on-remove {\n\t *   background:black;\n\t * }\n\t * </style>\n\t * ```\n\t *\n\t * We can also make use of CSS keyframes by placing them within the CSS classes.\n\t *\n\t *\n\t * ### CSS Staggering Animations\n\t * A Staggering animation is a collection of animations that are issued with a slight delay in between each successive operation resulting in a\n\t * curtain-like effect. The ngAnimate module (versions >=1.2) supports staggering animations and the stagger effect can be\n\t * performed by creating a **ng-EVENT-stagger** CSS class and attaching that class to the base CSS class used for\n\t * the animation. The style property expected within the stagger class can either be a **transition-delay** or an\n\t * **animation-delay** property (or both if your animation contains both transitions and keyframe animations).\n\t *\n\t * ```css\n\t * .my-animation.ng-enter {\n\t *   /&#42; standard transition code &#42;/\n\t *   transition: 1s linear all;\n\t *   opacity:0;\n\t * }\n\t * .my-animation.ng-enter-stagger {\n\t *   /&#42; this will have a 100ms delay between each successive leave animation &#42;/\n\t *   transition-delay: 0.1s;\n\t *\n\t *   /&#42; As of 1.4.4, this must always be set: it signals ngAnimate\n\t *     to not accidentally inherit a delay property from another CSS class &#42;/\n\t *   transition-duration: 0s;\n\t * }\n\t * .my-animation.ng-enter.ng-enter-active {\n\t *   /&#42; standard transition styles &#42;/\n\t *   opacity:1;\n\t * }\n\t * ```\n\t *\n\t * Staggering animations work by default in ngRepeat (so long as the CSS class is defined). Outside of ngRepeat, to use staggering animations\n\t * on your own, they can be triggered by firing multiple calls to the same event on $animate. However, the restrictions surrounding this\n\t * are that each of the elements must have the same CSS className value as well as the same parent element. A stagger operation\n\t * will also be reset if one or more animation frames have passed since the multiple calls to `$animate` were fired.\n\t *\n\t * The following code will issue the **ng-leave-stagger** event on the element provided:\n\t *\n\t * ```js\n\t * var kids = parent.children();\n\t *\n\t * $animate.leave(kids[0]); //stagger index=0\n\t * $animate.leave(kids[1]); //stagger index=1\n\t * $animate.leave(kids[2]); //stagger index=2\n\t * $animate.leave(kids[3]); //stagger index=3\n\t * $animate.leave(kids[4]); //stagger index=4\n\t *\n\t * window.requestAnimationFrame(function() {\n\t *   //stagger has reset itself\n\t *   $animate.leave(kids[5]); //stagger index=0\n\t *   $animate.leave(kids[6]); //stagger index=1\n\t *\n\t *   $scope.$digest();\n\t * });\n\t * ```\n\t *\n\t * Stagger animations are currently only supported within CSS-defined animations.\n\t *\n\t * ### The `ng-animate` CSS class\n\t *\n\t * When ngAnimate is animating an element it will apply the `ng-animate` CSS class to the element for the duration of the animation.\n\t * This is a temporary CSS class and it will be removed once the animation is over (for both JavaScript and CSS-based animations).\n\t *\n\t * Therefore, animations can be applied to an element using this temporary class directly via CSS.\n\t *\n\t * ```css\n\t * .zipper.ng-animate {\n\t *   transition:0.5s linear all;\n\t * }\n\t * .zipper.ng-enter {\n\t *   opacity:0;\n\t * }\n\t * .zipper.ng-enter.ng-enter-active {\n\t *   opacity:1;\n\t * }\n\t * .zipper.ng-leave {\n\t *   opacity:1;\n\t * }\n\t * .zipper.ng-leave.ng-leave-active {\n\t *   opacity:0;\n\t * }\n\t * ```\n\t *\n\t * (Note that the `ng-animate` CSS class is reserved and it cannot be applied on an element directly since ngAnimate will always remove\n\t * the CSS class once an animation has completed.)\n\t *\n\t *\n\t * ### The `ng-[event]-prepare` class\n\t *\n\t * This is a special class that can be used to prevent unwanted flickering / flash of content before\n\t * the actual animation starts. The class is added as soon as an animation is initialized, but removed\n\t * before the actual animation starts (after waiting for a $digest).\n\t * It is also only added for *structural* animations (`enter`, `move`, and `leave`).\n\t *\n\t * In practice, flickering can appear when nesting elements with structural animations such as `ngIf`\n\t * into elements that have class-based animations such as `ngClass`.\n\t *\n\t * ```html\n\t * <div ng-class=\"{red: myProp}\">\n\t *   <div ng-class=\"{blue: myProp}\">\n\t *     <div class=\"message\" ng-if=\"myProp\"></div>\n\t *   </div>\n\t * </div>\n\t * ```\n\t *\n\t * It is possible that during the `enter` animation, the `.message` div will be briefly visible before it starts animating.\n\t * In that case, you can add styles to the CSS that make sure the element stays hidden before the animation starts:\n\t *\n\t * ```css\n\t * .message.ng-enter-prepare {\n\t *   opacity: 0;\n\t * }\n\t *\n\t * ```\n\t *\n\t * ## JavaScript-based Animations\n\t *\n\t * ngAnimate also allows for animations to be consumed by JavaScript code. The approach is similar to CSS-based animations (where there is a shared\n\t * CSS class that is referenced in our HTML code) but in addition we need to register the JavaScript animation on the module. By making use of the\n\t * `module.animation()` module function we can register the animation.\n\t *\n\t * Let's see an example of a enter/leave animation using `ngRepeat`:\n\t *\n\t * ```html\n\t * <div ng-repeat=\"item in items\" class=\"slide\">\n\t *   {{ item }}\n\t * </div>\n\t * ```\n\t *\n\t * See the **slide** CSS class? Let's use that class to define an animation that we'll structure in our module code by using `module.animation`:\n\t *\n\t * ```js\n\t * myModule.animation('.slide', [function() {\n\t *   return {\n\t *     // make note that other events (like addClass/removeClass)\n\t *     // have different function input parameters\n\t *     enter: function(element, doneFn) {\n\t *       jQuery(element).fadeIn(1000, doneFn);\n\t *\n\t *       // remember to call doneFn so that angular\n\t *       // knows that the animation has concluded\n\t *     },\n\t *\n\t *     move: function(element, doneFn) {\n\t *       jQuery(element).fadeIn(1000, doneFn);\n\t *     },\n\t *\n\t *     leave: function(element, doneFn) {\n\t *       jQuery(element).fadeOut(1000, doneFn);\n\t *     }\n\t *   }\n\t * }]);\n\t * ```\n\t *\n\t * The nice thing about JS-based animations is that we can inject other services and make use of advanced animation libraries such as\n\t * greensock.js and velocity.js.\n\t *\n\t * If our animation code class-based (meaning that something like `ngClass`, `ngHide` and `ngShow` triggers it) then we can still define\n\t * our animations inside of the same registered animation, however, the function input arguments are a bit different:\n\t *\n\t * ```html\n\t * <div ng-class=\"color\" class=\"colorful\">\n\t *   this box is moody\n\t * </div>\n\t * <button ng-click=\"color='red'\">Change to red</button>\n\t * <button ng-click=\"color='blue'\">Change to blue</button>\n\t * <button ng-click=\"color='green'\">Change to green</button>\n\t * ```\n\t *\n\t * ```js\n\t * myModule.animation('.colorful', [function() {\n\t *   return {\n\t *     addClass: function(element, className, doneFn) {\n\t *       // do some cool animation and call the doneFn\n\t *     },\n\t *     removeClass: function(element, className, doneFn) {\n\t *       // do some cool animation and call the doneFn\n\t *     },\n\t *     setClass: function(element, addedClass, removedClass, doneFn) {\n\t *       // do some cool animation and call the doneFn\n\t *     }\n\t *   }\n\t * }]);\n\t * ```\n\t *\n\t * ## CSS + JS Animations Together\n\t *\n\t * AngularJS 1.4 and higher has taken steps to make the amalgamation of CSS and JS animations more flexible. However, unlike earlier versions of Angular,\n\t * defining CSS and JS animations to work off of the same CSS class will not work anymore. Therefore the example below will only result in **JS animations taking\n\t * charge of the animation**:\n\t *\n\t * ```html\n\t * <div ng-if=\"bool\" class=\"slide\">\n\t *   Slide in and out\n\t * </div>\n\t * ```\n\t *\n\t * ```js\n\t * myModule.animation('.slide', [function() {\n\t *   return {\n\t *     enter: function(element, doneFn) {\n\t *       jQuery(element).slideIn(1000, doneFn);\n\t *     }\n\t *   }\n\t * }]);\n\t * ```\n\t *\n\t * ```css\n\t * .slide.ng-enter {\n\t *   transition:0.5s linear all;\n\t *   transform:translateY(-100px);\n\t * }\n\t * .slide.ng-enter.ng-enter-active {\n\t *   transform:translateY(0);\n\t * }\n\t * ```\n\t *\n\t * Does this mean that CSS and JS animations cannot be used together? Do JS-based animations always have higher priority? We can make up for the\n\t * lack of CSS animations by using the `$animateCss` service to trigger our own tweaked-out, CSS-based animations directly from\n\t * our own JS-based animation code:\n\t *\n\t * ```js\n\t * myModule.animation('.slide', ['$animateCss', function($animateCss) {\n\t *   return {\n\t *     enter: function(element) {\n\t*        // this will trigger `.slide.ng-enter` and `.slide.ng-enter-active`.\n\t *       return $animateCss(element, {\n\t *         event: 'enter',\n\t *         structural: true\n\t *       });\n\t *     }\n\t *   }\n\t * }]);\n\t * ```\n\t *\n\t * The nice thing here is that we can save bandwidth by sticking to our CSS-based animation code and we don't need to rely on a 3rd-party animation framework.\n\t *\n\t * The `$animateCss` service is very powerful since we can feed in all kinds of extra properties that will be evaluated and fed into a CSS transition or\n\t * keyframe animation. For example if we wanted to animate the height of an element while adding and removing classes then we can do so by providing that\n\t * data into `$animateCss` directly:\n\t *\n\t * ```js\n\t * myModule.animation('.slide', ['$animateCss', function($animateCss) {\n\t *   return {\n\t *     enter: function(element) {\n\t *       return $animateCss(element, {\n\t *         event: 'enter',\n\t *         structural: true,\n\t *         addClass: 'maroon-setting',\n\t *         from: { height:0 },\n\t *         to: { height: 200 }\n\t *       });\n\t *     }\n\t *   }\n\t * }]);\n\t * ```\n\t *\n\t * Now we can fill in the rest via our transition CSS code:\n\t *\n\t * ```css\n\t * /&#42; the transition tells ngAnimate to make the animation happen &#42;/\n\t * .slide.ng-enter { transition:0.5s linear all; }\n\t *\n\t * /&#42; this extra CSS class will be absorbed into the transition\n\t * since the $animateCss code is adding the class &#42;/\n\t * .maroon-setting { background:red; }\n\t * ```\n\t *\n\t * And `$animateCss` will figure out the rest. Just make sure to have the `done()` callback fire the `doneFn` function to signal when the animation is over.\n\t *\n\t * To learn more about what's possible be sure to visit the {@link ngAnimate.$animateCss $animateCss service}.\n\t *\n\t * ## Animation Anchoring (via `ng-animate-ref`)\n\t *\n\t * ngAnimate in AngularJS 1.4 comes packed with the ability to cross-animate elements between\n\t * structural areas of an application (like views) by pairing up elements using an attribute\n\t * called `ng-animate-ref`.\n\t *\n\t * Let's say for example we have two views that are managed by `ng-view` and we want to show\n\t * that there is a relationship between two components situated in within these views. By using the\n\t * `ng-animate-ref` attribute we can identify that the two components are paired together and we\n\t * can then attach an animation, which is triggered when the view changes.\n\t *\n\t * Say for example we have the following template code:\n\t *\n\t * ```html\n\t * <!-- index.html -->\n\t * <div ng-view class=\"view-animation\">\n\t * </div>\n\t *\n\t * <!-- home.html -->\n\t * <a href=\"#/banner-page\">\n\t *   <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">\n\t * </a>\n\t *\n\t * <!-- banner-page.html -->\n\t * <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">\n\t * ```\n\t *\n\t * Now, when the view changes (once the link is clicked), ngAnimate will examine the\n\t * HTML contents to see if there is a match reference between any components in the view\n\t * that is leaving and the view that is entering. It will scan both the view which is being\n\t * removed (leave) and inserted (enter) to see if there are any paired DOM elements that\n\t * contain a matching ref value.\n\t *\n\t * The two images match since they share the same ref value. ngAnimate will now create a\n\t * transport element (which is a clone of the first image element) and it will then attempt\n\t * to animate to the position of the second image element in the next view. For the animation to\n\t * work a special CSS class called `ng-anchor` will be added to the transported element.\n\t *\n\t * We can now attach a transition onto the `.banner.ng-anchor` CSS class and then\n\t * ngAnimate will handle the entire transition for us as well as the addition and removal of\n\t * any changes of CSS classes between the elements:\n\t *\n\t * ```css\n\t * .banner.ng-anchor {\n\t *   /&#42; this animation will last for 1 second since there are\n\t *          two phases to the animation (an `in` and an `out` phase) &#42;/\n\t *   transition:0.5s linear all;\n\t * }\n\t * ```\n\t *\n\t * We also **must** include animations for the views that are being entered and removed\n\t * (otherwise anchoring wouldn't be possible since the new view would be inserted right away).\n\t *\n\t * ```css\n\t * .view-animation.ng-enter, .view-animation.ng-leave {\n\t *   transition:0.5s linear all;\n\t *   position:fixed;\n\t *   left:0;\n\t *   top:0;\n\t *   width:100%;\n\t * }\n\t * .view-animation.ng-enter {\n\t *   transform:translateX(100%);\n\t * }\n\t * .view-animation.ng-leave,\n\t * .view-animation.ng-enter.ng-enter-active {\n\t *   transform:translateX(0%);\n\t * }\n\t * .view-animation.ng-leave.ng-leave-active {\n\t *   transform:translateX(-100%);\n\t * }\n\t * ```\n\t *\n\t * Now we can jump back to the anchor animation. When the animation happens, there are two stages that occur:\n\t * an `out` and an `in` stage. The `out` stage happens first and that is when the element is animated away\n\t * from its origin. Once that animation is over then the `in` stage occurs which animates the\n\t * element to its destination. The reason why there are two animations is to give enough time\n\t * for the enter animation on the new element to be ready.\n\t *\n\t * The example above sets up a transition for both the in and out phases, but we can also target the out or\n\t * in phases directly via `ng-anchor-out` and `ng-anchor-in`.\n\t *\n\t * ```css\n\t * .banner.ng-anchor-out {\n\t *   transition: 0.5s linear all;\n\t *\n\t *   /&#42; the scale will be applied during the out animation,\n\t *          but will be animated away when the in animation runs &#42;/\n\t *   transform: scale(1.2);\n\t * }\n\t *\n\t * .banner.ng-anchor-in {\n\t *   transition: 1s linear all;\n\t * }\n\t * ```\n\t *\n\t *\n\t *\n\t *\n\t * ### Anchoring Demo\n\t *\n\t  <example module=\"anchoringExample\"\n\t           name=\"anchoringExample\"\n\t           id=\"anchoringExample\"\n\t           deps=\"angular-animate.js;angular-route.js\"\n\t           animations=\"true\">\n\t    <file name=\"index.html\">\n\t      <a href=\"#/\">Home</a>\n\t      <hr />\n\t      <div class=\"view-container\">\n\t        <div ng-view class=\"view\"></div>\n\t      </div>\n\t    </file>\n\t    <file name=\"script.js\">\n\t      angular.module('anchoringExample', ['ngAnimate', 'ngRoute'])\n\t        .config(['$routeProvider', function($routeProvider) {\n\t          $routeProvider.when('/', {\n\t            templateUrl: 'home.html',\n\t            controller: 'HomeController as home'\n\t          });\n\t          $routeProvider.when('/profile/:id', {\n\t            templateUrl: 'profile.html',\n\t            controller: 'ProfileController as profile'\n\t          });\n\t        }])\n\t        .run(['$rootScope', function($rootScope) {\n\t          $rootScope.records = [\n\t            { id:1, title: \"Miss Beulah Roob\" },\n\t            { id:2, title: \"Trent Morissette\" },\n\t            { id:3, title: \"Miss Ava Pouros\" },\n\t            { id:4, title: \"Rod Pouros\" },\n\t            { id:5, title: \"Abdul Rice\" },\n\t            { id:6, title: \"Laurie Rutherford Sr.\" },\n\t            { id:7, title: \"Nakia McLaughlin\" },\n\t            { id:8, title: \"Jordon Blanda DVM\" },\n\t            { id:9, title: \"Rhoda Hand\" },\n\t            { id:10, title: \"Alexandrea Sauer\" }\n\t          ];\n\t        }])\n\t        .controller('HomeController', [function() {\n\t          //empty\n\t        }])\n\t        .controller('ProfileController', ['$rootScope', '$routeParams', function($rootScope, $routeParams) {\n\t          var index = parseInt($routeParams.id, 10);\n\t          var record = $rootScope.records[index - 1];\n\t\n\t          this.title = record.title;\n\t          this.id = record.id;\n\t        }]);\n\t    </file>\n\t    <file name=\"home.html\">\n\t      <h2>Welcome to the home page</h1>\n\t      <p>Please click on an element</p>\n\t      <a class=\"record\"\n\t         ng-href=\"#/profile/{{ record.id }}\"\n\t         ng-animate-ref=\"{{ record.id }}\"\n\t         ng-repeat=\"record in records\">\n\t        {{ record.title }}\n\t      </a>\n\t    </file>\n\t    <file name=\"profile.html\">\n\t      <div class=\"profile record\" ng-animate-ref=\"{{ profile.id }}\">\n\t        {{ profile.title }}\n\t      </div>\n\t    </file>\n\t    <file name=\"animations.css\">\n\t      .record {\n\t        display:block;\n\t        font-size:20px;\n\t      }\n\t      .profile {\n\t        background:black;\n\t        color:white;\n\t        font-size:100px;\n\t      }\n\t      .view-container {\n\t        position:relative;\n\t      }\n\t      .view-container > .view.ng-animate {\n\t        position:absolute;\n\t        top:0;\n\t        left:0;\n\t        width:100%;\n\t        min-height:500px;\n\t      }\n\t      .view.ng-enter, .view.ng-leave,\n\t      .record.ng-anchor {\n\t        transition:0.5s linear all;\n\t      }\n\t      .view.ng-enter {\n\t        transform:translateX(100%);\n\t      }\n\t      .view.ng-enter.ng-enter-active, .view.ng-leave {\n\t        transform:translateX(0%);\n\t      }\n\t      .view.ng-leave.ng-leave-active {\n\t        transform:translateX(-100%);\n\t      }\n\t      .record.ng-anchor-out {\n\t        background:red;\n\t      }\n\t    </file>\n\t  </example>\n\t *\n\t * ### How is the element transported?\n\t *\n\t * When an anchor animation occurs, ngAnimate will clone the starting element and position it exactly where the starting\n\t * element is located on screen via absolute positioning. The cloned element will be placed inside of the root element\n\t * of the application (where ng-app was defined) and all of the CSS classes of the starting element will be applied. The\n\t * element will then animate into the `out` and `in` animations and will eventually reach the coordinates and match\n\t * the dimensions of the destination element. During the entire animation a CSS class of `.ng-animate-shim` will be applied\n\t * to both the starting and destination elements in order to hide them from being visible (the CSS styling for the class\n\t * is: `visibility:hidden`). Once the anchor reaches its destination then it will be removed and the destination element\n\t * will become visible since the shim class will be removed.\n\t *\n\t * ### How is the morphing handled?\n\t *\n\t * CSS Anchoring relies on transitions and keyframes and the internal code is intelligent enough to figure out\n\t * what CSS classes differ between the starting element and the destination element. These different CSS classes\n\t * will be added/removed on the anchor element and a transition will be applied (the transition that is provided\n\t * in the anchor class). Long story short, ngAnimate will figure out what classes to add and remove which will\n\t * make the transition of the element as smooth and automatic as possible. Be sure to use simple CSS classes that\n\t * do not rely on DOM nesting structure so that the anchor element appears the same as the starting element (since\n\t * the cloned element is placed inside of root element which is likely close to the body element).\n\t *\n\t * Note that if the root element is on the `<html>` element then the cloned node will be placed inside of body.\n\t *\n\t *\n\t * ## Using $animate in your directive code\n\t *\n\t * So far we've explored how to feed in animations into an Angular application, but how do we trigger animations within our own directives in our application?\n\t * By injecting the `$animate` service into our directive code, we can trigger structural and class-based hooks which can then be consumed by animations. Let's\n\t * imagine we have a greeting box that shows and hides itself when the data changes\n\t *\n\t * ```html\n\t * <greeting-box active=\"onOrOff\">Hi there</greeting-box>\n\t * ```\n\t *\n\t * ```js\n\t * ngModule.directive('greetingBox', ['$animate', function($animate) {\n\t *   return function(scope, element, attrs) {\n\t *     attrs.$observe('active', function(value) {\n\t *       value ? $animate.addClass(element, 'on') : $animate.removeClass(element, 'on');\n\t *     });\n\t *   });\n\t * }]);\n\t * ```\n\t *\n\t * Now the `on` CSS class is added and removed on the greeting box component. Now if we add a CSS class on top of the greeting box element\n\t * in our HTML code then we can trigger a CSS or JS animation to happen.\n\t *\n\t * ```css\n\t * /&#42; normally we would create a CSS class to reference on the element &#42;/\n\t * greeting-box.on { transition:0.5s linear all; background:green; color:white; }\n\t * ```\n\t *\n\t * The `$animate` service contains a variety of other methods like `enter`, `leave`, `animate` and `setClass`. To learn more about what's\n\t * possible be sure to visit the {@link ng.$animate $animate service API page}.\n\t *\n\t *\n\t * ## Callbacks and Promises\n\t *\n\t * When `$animate` is called it returns a promise that can be used to capture when the animation has ended. Therefore if we were to trigger\n\t * an animation (within our directive code) then we can continue performing directive and scope related activities after the animation has\n\t * ended by chaining onto the returned promise that animation method returns.\n\t *\n\t * ```js\n\t * // somewhere within the depths of the directive\n\t * $animate.enter(element, parent).then(function() {\n\t *   //the animation has completed\n\t * });\n\t * ```\n\t *\n\t * (Note that earlier versions of Angular prior to v1.4 required the promise code to be wrapped using `$scope.$apply(...)`. This is not the case\n\t * anymore.)\n\t *\n\t * In addition to the animation promise, we can also make use of animation-related callbacks within our directives and controller code by registering\n\t * an event listener using the `$animate` service. Let's say for example that an animation was triggered on our view\n\t * routing controller to hook into that:\n\t *\n\t * ```js\n\t * ngModule.controller('HomePageController', ['$animate', function($animate) {\n\t *   $animate.on('enter', ngViewElement, function(element) {\n\t *     // the animation for this route has completed\n\t *   }]);\n\t * }])\n\t * ```\n\t *\n\t * (Note that you will need to trigger a digest within the callback to get angular to notice any scope-related changes.)\n\t */\n\t\n\t/**\n\t * @ngdoc service\n\t * @name $animate\n\t * @kind object\n\t *\n\t * @description\n\t * The ngAnimate `$animate` service documentation is the same for the core `$animate` service.\n\t *\n\t * Click here {@link ng.$animate to learn more about animations with `$animate`}.\n\t */\n\tangular.module('ngAnimate', [])\n\t  .directive('ngAnimateSwap', ngAnimateSwapDirective)\n\t\n\t  .directive('ngAnimateChildren', $$AnimateChildrenDirective)\n\t  .factory('$$rAFScheduler', $$rAFSchedulerFactory)\n\t\n\t  .provider('$$animateQueue', $$AnimateQueueProvider)\n\t  .provider('$$animation', $$AnimationProvider)\n\t\n\t  .provider('$animateCss', $AnimateCssProvider)\n\t  .provider('$$animateCssDriver', $$AnimateCssDriverProvider)\n\t\n\t  .provider('$$animateJs', $$AnimateJsProvider)\n\t  .provider('$$animateJsDriver', $$AnimateJsDriverProvider);\n\t\n\t\n\t})(window, window.angular);\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(8);\n\t\n\tmodule.exports = 'ui.bootstrap';\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t/*\n\t * angular-ui-bootstrap\n\t * http://angular-ui.github.io/bootstrap/\n\t\n\t * Version: 1.3.3 - 2016-05-22\n\t * License: MIT\n\t */angular.module(\"ui.bootstrap\", [\"ui.bootstrap.tpls\", \"ui.bootstrap.collapse\",\"ui.bootstrap.accordion\",\"ui.bootstrap.alert\",\"ui.bootstrap.buttons\",\"ui.bootstrap.carousel\",\"ui.bootstrap.dateparser\",\"ui.bootstrap.isClass\",\"ui.bootstrap.datepicker\",\"ui.bootstrap.position\",\"ui.bootstrap.datepickerPopup\",\"ui.bootstrap.debounce\",\"ui.bootstrap.dropdown\",\"ui.bootstrap.stackedMap\",\"ui.bootstrap.modal\",\"ui.bootstrap.paging\",\"ui.bootstrap.pager\",\"ui.bootstrap.pagination\",\"ui.bootstrap.tooltip\",\"ui.bootstrap.popover\",\"ui.bootstrap.progressbar\",\"ui.bootstrap.rating\",\"ui.bootstrap.tabs\",\"ui.bootstrap.timepicker\",\"ui.bootstrap.typeahead\"]);\n\tangular.module(\"ui.bootstrap.tpls\", [\"uib/template/accordion/accordion-group.html\",\"uib/template/accordion/accordion.html\",\"uib/template/alert/alert.html\",\"uib/template/carousel/carousel.html\",\"uib/template/carousel/slide.html\",\"uib/template/datepicker/datepicker.html\",\"uib/template/datepicker/day.html\",\"uib/template/datepicker/month.html\",\"uib/template/datepicker/year.html\",\"uib/template/datepickerPopup/popup.html\",\"uib/template/modal/backdrop.html\",\"uib/template/modal/window.html\",\"uib/template/pager/pager.html\",\"uib/template/pagination/pagination.html\",\"uib/template/tooltip/tooltip-html-popup.html\",\"uib/template/tooltip/tooltip-popup.html\",\"uib/template/tooltip/tooltip-template-popup.html\",\"uib/template/popover/popover-html.html\",\"uib/template/popover/popover-template.html\",\"uib/template/popover/popover.html\",\"uib/template/progressbar/bar.html\",\"uib/template/progressbar/progress.html\",\"uib/template/progressbar/progressbar.html\",\"uib/template/rating/rating.html\",\"uib/template/tabs/tab.html\",\"uib/template/tabs/tabset.html\",\"uib/template/timepicker/timepicker.html\",\"uib/template/typeahead/typeahead-match.html\",\"uib/template/typeahead/typeahead-popup.html\"]);\n\tangular.module('ui.bootstrap.collapse', [])\n\t\n\t  .directive('uibCollapse', ['$animate', '$q', '$parse', '$injector', function($animate, $q, $parse, $injector) {\n\t    var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;\n\t    return {\n\t      link: function(scope, element, attrs) {\n\t        var expandingExpr = $parse(attrs.expanding),\n\t            expandedExpr = $parse(attrs.expanded),\n\t            collapsingExpr = $parse(attrs.collapsing),\n\t            collapsedExpr = $parse(attrs.collapsed);\n\t\n\t        if (!scope.$eval(attrs.uibCollapse)) {\n\t          element.addClass('in')\n\t            .addClass('collapse')\n\t            .attr('aria-expanded', true)\n\t            .attr('aria-hidden', false)\n\t            .css({height: 'auto'});\n\t        }\n\t\n\t        function expand() {\n\t          if (element.hasClass('collapse') && element.hasClass('in')) {\n\t            return;\n\t          }\n\t\n\t          $q.resolve(expandingExpr(scope))\n\t            .then(function() {\n\t              element.removeClass('collapse')\n\t                .addClass('collapsing')\n\t                .attr('aria-expanded', true)\n\t                .attr('aria-hidden', false);\n\t\n\t              if ($animateCss) {\n\t                $animateCss(element, {\n\t                  addClass: 'in',\n\t                  easing: 'ease',\n\t                  to: { height: element[0].scrollHeight + 'px' }\n\t                }).start()['finally'](expandDone);\n\t              } else {\n\t                $animate.addClass(element, 'in', {\n\t                  to: { height: element[0].scrollHeight + 'px' }\n\t                }).then(expandDone);\n\t              }\n\t            });\n\t        }\n\t\n\t        function expandDone() {\n\t          element.removeClass('collapsing')\n\t            .addClass('collapse')\n\t            .css({height: 'auto'});\n\t          expandedExpr(scope);\n\t        }\n\t\n\t        function collapse() {\n\t          if (!element.hasClass('collapse') && !element.hasClass('in')) {\n\t            return collapseDone();\n\t          }\n\t\n\t          $q.resolve(collapsingExpr(scope))\n\t            .then(function() {\n\t              element\n\t                // IMPORTANT: The height must be set before adding \"collapsing\" class.\n\t                // Otherwise, the browser attempts to animate from height 0 (in\n\t                // collapsing class) to the given height here.\n\t                .css({height: element[0].scrollHeight + 'px'})\n\t                // initially all panel collapse have the collapse class, this removal\n\t                // prevents the animation from jumping to collapsed state\n\t                .removeClass('collapse')\n\t                .addClass('collapsing')\n\t                .attr('aria-expanded', false)\n\t                .attr('aria-hidden', true);\n\t\n\t              if ($animateCss) {\n\t                $animateCss(element, {\n\t                  removeClass: 'in',\n\t                  to: {height: '0'}\n\t                }).start()['finally'](collapseDone);\n\t              } else {\n\t                $animate.removeClass(element, 'in', {\n\t                  to: {height: '0'}\n\t                }).then(collapseDone);\n\t              }\n\t            });\n\t        }\n\t\n\t        function collapseDone() {\n\t          element.css({height: '0'}); // Required so that collapse works when animation is disabled\n\t          element.removeClass('collapsing')\n\t            .addClass('collapse');\n\t          collapsedExpr(scope);\n\t        }\n\t\n\t        scope.$watch(attrs.uibCollapse, function(shouldCollapse) {\n\t          if (shouldCollapse) {\n\t            collapse();\n\t          } else {\n\t            expand();\n\t          }\n\t        });\n\t      }\n\t    };\n\t  }]);\n\t\n\tangular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse'])\n\t\n\t.constant('uibAccordionConfig', {\n\t  closeOthers: true\n\t})\n\t\n\t.controller('UibAccordionController', ['$scope', '$attrs', 'uibAccordionConfig', function($scope, $attrs, accordionConfig) {\n\t  // This array keeps track of the accordion groups\n\t  this.groups = [];\n\t\n\t  // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to\n\t  this.closeOthers = function(openGroup) {\n\t    var closeOthers = angular.isDefined($attrs.closeOthers) ?\n\t      $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;\n\t    if (closeOthers) {\n\t      angular.forEach(this.groups, function(group) {\n\t        if (group !== openGroup) {\n\t          group.isOpen = false;\n\t        }\n\t      });\n\t    }\n\t  };\n\t\n\t  // This is called from the accordion-group directive to add itself to the accordion\n\t  this.addGroup = function(groupScope) {\n\t    var that = this;\n\t    this.groups.push(groupScope);\n\t\n\t    groupScope.$on('$destroy', function(event) {\n\t      that.removeGroup(groupScope);\n\t    });\n\t  };\n\t\n\t  // This is called from the accordion-group directive when to remove itself\n\t  this.removeGroup = function(group) {\n\t    var index = this.groups.indexOf(group);\n\t    if (index !== -1) {\n\t      this.groups.splice(index, 1);\n\t    }\n\t  };\n\t}])\n\t\n\t// The accordion directive simply sets up the directive controller\n\t// and adds an accordion CSS class to itself element.\n\t.directive('uibAccordion', function() {\n\t  return {\n\t    controller: 'UibAccordionController',\n\t    controllerAs: 'accordion',\n\t    transclude: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'uib/template/accordion/accordion.html';\n\t    }\n\t  };\n\t})\n\t\n\t// The accordion-group directive indicates a block of html that will expand and collapse in an accordion\n\t.directive('uibAccordionGroup', function() {\n\t  return {\n\t    require: '^uibAccordion',         // We need this directive to be inside an accordion\n\t    transclude: true,              // It transcludes the contents of the directive into the template\n\t    replace: true,                // The element containing the directive will be replaced with the template\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'uib/template/accordion/accordion-group.html';\n\t    },\n\t    scope: {\n\t      heading: '@',               // Interpolate the heading attribute onto this scope\n\t      panelClass: '@?',           // Ditto with panelClass\n\t      isOpen: '=?',\n\t      isDisabled: '=?'\n\t    },\n\t    controller: function() {\n\t      this.setHeading = function(element) {\n\t        this.heading = element;\n\t      };\n\t    },\n\t    link: function(scope, element, attrs, accordionCtrl) {\n\t      accordionCtrl.addGroup(scope);\n\t\n\t      scope.openClass = attrs.openClass || 'panel-open';\n\t      scope.panelClass = attrs.panelClass || 'panel-default';\n\t      scope.$watch('isOpen', function(value) {\n\t        element.toggleClass(scope.openClass, !!value);\n\t        if (value) {\n\t          accordionCtrl.closeOthers(scope);\n\t        }\n\t      });\n\t\n\t      scope.toggleOpen = function($event) {\n\t        if (!scope.isDisabled) {\n\t          if (!$event || $event.which === 32) {\n\t            scope.isOpen = !scope.isOpen;\n\t          }\n\t        }\n\t      };\n\t\n\t      var id = 'accordiongroup-' + scope.$id + '-' + Math.floor(Math.random() * 10000);\n\t      scope.headingId = id + '-tab';\n\t      scope.panelId = id + '-panel';\n\t    }\n\t  };\n\t})\n\t\n\t// Use accordion-heading below an accordion-group to provide a heading containing HTML\n\t.directive('uibAccordionHeading', function() {\n\t  return {\n\t    transclude: true,   // Grab the contents to be used as the heading\n\t    template: '',       // In effect remove this element!\n\t    replace: true,\n\t    require: '^uibAccordionGroup',\n\t    link: function(scope, element, attrs, accordionGroupCtrl, transclude) {\n\t      // Pass the heading to the accordion-group controller\n\t      // so that it can be transcluded into the right place in the template\n\t      // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]\n\t      accordionGroupCtrl.setHeading(transclude(scope, angular.noop));\n\t    }\n\t  };\n\t})\n\t\n\t// Use in the accordion-group template to indicate where you want the heading to be transcluded\n\t// You must provide the property on the accordion-group controller that will hold the transcluded element\n\t.directive('uibAccordionTransclude', function() {\n\t  return {\n\t    require: '^uibAccordionGroup',\n\t    link: function(scope, element, attrs, controller) {\n\t      scope.$watch(function() { return controller[attrs.uibAccordionTransclude]; }, function(heading) {\n\t        if (heading) {\n\t          var elem = angular.element(element[0].querySelector(getHeaderSelectors()));\n\t          elem.html('');\n\t          elem.append(heading);\n\t        }\n\t      });\n\t    }\n\t  };\n\t\n\t  function getHeaderSelectors() {\n\t      return 'uib-accordion-header,' +\n\t          'data-uib-accordion-header,' +\n\t          'x-uib-accordion-header,' +\n\t          'uib\\\\:accordion-header,' +\n\t          '[uib-accordion-header],' +\n\t          '[data-uib-accordion-header],' +\n\t          '[x-uib-accordion-header]';\n\t  }\n\t});\n\t\n\tangular.module('ui.bootstrap.alert', [])\n\t\n\t.controller('UibAlertController', ['$scope', '$attrs', '$interpolate', '$timeout', function($scope, $attrs, $interpolate, $timeout) {\n\t  $scope.closeable = !!$attrs.close;\n\t\n\t  var dismissOnTimeout = angular.isDefined($attrs.dismissOnTimeout) ?\n\t    $interpolate($attrs.dismissOnTimeout)($scope.$parent) : null;\n\t\n\t  if (dismissOnTimeout) {\n\t    $timeout(function() {\n\t      $scope.close();\n\t    }, parseInt(dismissOnTimeout, 10));\n\t  }\n\t}])\n\t\n\t.directive('uibAlert', function() {\n\t  return {\n\t    controller: 'UibAlertController',\n\t    controllerAs: 'alert',\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'uib/template/alert/alert.html';\n\t    },\n\t    transclude: true,\n\t    replace: true,\n\t    scope: {\n\t      type: '@',\n\t      close: '&'\n\t    }\n\t  };\n\t});\n\t\n\tangular.module('ui.bootstrap.buttons', [])\n\t\n\t.constant('uibButtonConfig', {\n\t  activeClass: 'active',\n\t  toggleEvent: 'click'\n\t})\n\t\n\t.controller('UibButtonsController', ['uibButtonConfig', function(buttonConfig) {\n\t  this.activeClass = buttonConfig.activeClass || 'active';\n\t  this.toggleEvent = buttonConfig.toggleEvent || 'click';\n\t}])\n\t\n\t.directive('uibBtnRadio', ['$parse', function($parse) {\n\t  return {\n\t    require: ['uibBtnRadio', 'ngModel'],\n\t    controller: 'UibButtonsController',\n\t    controllerAs: 'buttons',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t      var uncheckableExpr = $parse(attrs.uibUncheckable);\n\t\n\t      element.find('input').css({display: 'none'});\n\t\n\t      //model -> UI\n\t      ngModelCtrl.$render = function() {\n\t        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.uibBtnRadio)));\n\t      };\n\t\n\t      //ui->model\n\t      element.on(buttonsCtrl.toggleEvent, function() {\n\t        if (attrs.disabled) {\n\t          return;\n\t        }\n\t\n\t        var isActive = element.hasClass(buttonsCtrl.activeClass);\n\t\n\t        if (!isActive || angular.isDefined(attrs.uncheckable)) {\n\t          scope.$apply(function() {\n\t            ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.uibBtnRadio));\n\t            ngModelCtrl.$render();\n\t          });\n\t        }\n\t      });\n\t\n\t      if (attrs.uibUncheckable) {\n\t        scope.$watch(uncheckableExpr, function(uncheckable) {\n\t          attrs.$set('uncheckable', uncheckable ? '' : undefined);\n\t        });\n\t      }\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('uibBtnCheckbox', function() {\n\t  return {\n\t    require: ['uibBtnCheckbox', 'ngModel'],\n\t    controller: 'UibButtonsController',\n\t    controllerAs: 'button',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      element.find('input').css({display: 'none'});\n\t\n\t      function getTrueValue() {\n\t        return getCheckboxValue(attrs.btnCheckboxTrue, true);\n\t      }\n\t\n\t      function getFalseValue() {\n\t        return getCheckboxValue(attrs.btnCheckboxFalse, false);\n\t      }\n\t\n\t      function getCheckboxValue(attribute, defaultValue) {\n\t        return angular.isDefined(attribute) ? scope.$eval(attribute) : defaultValue;\n\t      }\n\t\n\t      //model -> UI\n\t      ngModelCtrl.$render = function() {\n\t        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));\n\t      };\n\t\n\t      //ui->model\n\t      element.on(buttonsCtrl.toggleEvent, function() {\n\t        if (attrs.disabled) {\n\t          return;\n\t        }\n\t\n\t        scope.$apply(function() {\n\t          ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());\n\t          ngModelCtrl.$render();\n\t        });\n\t      });\n\t    }\n\t  };\n\t});\n\t\n\tangular.module('ui.bootstrap.carousel', [])\n\t\n\t.controller('UibCarouselController', ['$scope', '$element', '$interval', '$timeout', '$animate', function($scope, $element, $interval, $timeout, $animate) {\n\t  var self = this,\n\t    slides = self.slides = $scope.slides = [],\n\t    SLIDE_DIRECTION = 'uib-slideDirection',\n\t    currentIndex = $scope.active,\n\t    currentInterval, isPlaying, bufferedTransitions = [];\n\t\n\t  var destroyed = false;\n\t\n\t  self.addSlide = function(slide, element) {\n\t    slides.push({\n\t      slide: slide,\n\t      element: element\n\t    });\n\t    slides.sort(function(a, b) {\n\t      return +a.slide.index - +b.slide.index;\n\t    });\n\t    //if this is the first slide or the slide is set to active, select it\n\t    if (slide.index === $scope.active || slides.length === 1 && !angular.isNumber($scope.active)) {\n\t      if ($scope.$currentTransition) {\n\t        $scope.$currentTransition = null;\n\t      }\n\t\n\t      currentIndex = slide.index;\n\t      $scope.active = slide.index;\n\t      setActive(currentIndex);\n\t      self.select(slides[findSlideIndex(slide)]);\n\t      if (slides.length === 1) {\n\t        $scope.play();\n\t      }\n\t    }\n\t  };\n\t\n\t  self.getCurrentIndex = function() {\n\t    for (var i = 0; i < slides.length; i++) {\n\t      if (slides[i].slide.index === currentIndex) {\n\t        return i;\n\t      }\n\t    }\n\t  };\n\t\n\t  self.next = $scope.next = function() {\n\t    var newIndex = (self.getCurrentIndex() + 1) % slides.length;\n\t\n\t    if (newIndex === 0 && $scope.noWrap()) {\n\t      $scope.pause();\n\t      return;\n\t    }\n\t\n\t    return self.select(slides[newIndex], 'next');\n\t  };\n\t\n\t  self.prev = $scope.prev = function() {\n\t    var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;\n\t\n\t    if ($scope.noWrap() && newIndex === slides.length - 1) {\n\t      $scope.pause();\n\t      return;\n\t    }\n\t\n\t    return self.select(slides[newIndex], 'prev');\n\t  };\n\t\n\t  self.removeSlide = function(slide) {\n\t    var index = findSlideIndex(slide);\n\t\n\t    var bufferedIndex = bufferedTransitions.indexOf(slides[index]);\n\t    if (bufferedIndex !== -1) {\n\t      bufferedTransitions.splice(bufferedIndex, 1);\n\t    }\n\t\n\t    //get the index of the slide inside the carousel\n\t    slides.splice(index, 1);\n\t    if (slides.length > 0 && currentIndex === index) {\n\t      if (index >= slides.length) {\n\t        currentIndex = slides.length - 1;\n\t        $scope.active = currentIndex;\n\t        setActive(currentIndex);\n\t        self.select(slides[slides.length - 1]);\n\t      } else {\n\t        currentIndex = index;\n\t        $scope.active = currentIndex;\n\t        setActive(currentIndex);\n\t        self.select(slides[index]);\n\t      }\n\t    } else if (currentIndex > index) {\n\t      currentIndex--;\n\t      $scope.active = currentIndex;\n\t    }\n\t\n\t    //clean the active value when no more slide\n\t    if (slides.length === 0) {\n\t      currentIndex = null;\n\t      $scope.active = null;\n\t      clearBufferedTransitions();\n\t    }\n\t  };\n\t\n\t  /* direction: \"prev\" or \"next\" */\n\t  self.select = $scope.select = function(nextSlide, direction) {\n\t    var nextIndex = findSlideIndex(nextSlide.slide);\n\t    //Decide direction if it's not given\n\t    if (direction === undefined) {\n\t      direction = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';\n\t    }\n\t    //Prevent this user-triggered transition from occurring if there is already one in progress\n\t    if (nextSlide.slide.index !== currentIndex &&\n\t      !$scope.$currentTransition) {\n\t      goNext(nextSlide.slide, nextIndex, direction);\n\t    } else if (nextSlide && nextSlide.slide.index !== currentIndex && $scope.$currentTransition) {\n\t      bufferedTransitions.push(slides[nextIndex]);\n\t    }\n\t  };\n\t\n\t  /* Allow outside people to call indexOf on slides array */\n\t  $scope.indexOfSlide = function(slide) {\n\t    return +slide.slide.index;\n\t  };\n\t\n\t  $scope.isActive = function(slide) {\n\t    return $scope.active === slide.slide.index;\n\t  };\n\t\n\t  $scope.isPrevDisabled = function() {\n\t    return $scope.active === 0 && $scope.noWrap();\n\t  };\n\t\n\t  $scope.isNextDisabled = function() {\n\t    return $scope.active === slides.length - 1 && $scope.noWrap();\n\t  };\n\t\n\t  $scope.pause = function() {\n\t    if (!$scope.noPause) {\n\t      isPlaying = false;\n\t      resetTimer();\n\t    }\n\t  };\n\t\n\t  $scope.play = function() {\n\t    if (!isPlaying) {\n\t      isPlaying = true;\n\t      restartTimer();\n\t    }\n\t  };\n\t\n\t  $scope.$on('$destroy', function() {\n\t    destroyed = true;\n\t    resetTimer();\n\t  });\n\t\n\t  $scope.$watch('noTransition', function(noTransition) {\n\t    $animate.enabled($element, !noTransition);\n\t  });\n\t\n\t  $scope.$watch('interval', restartTimer);\n\t\n\t  $scope.$watchCollection('slides', resetTransition);\n\t\n\t  $scope.$watch('active', function(index) {\n\t    if (angular.isNumber(index) && currentIndex !== index) {\n\t      for (var i = 0; i < slides.length; i++) {\n\t        if (slides[i].slide.index === index) {\n\t          index = i;\n\t          break;\n\t        }\n\t      }\n\t\n\t      var slide = slides[index];\n\t      if (slide) {\n\t        setActive(index);\n\t        self.select(slides[index]);\n\t        currentIndex = index;\n\t      }\n\t    }\n\t  });\n\t\n\t  function clearBufferedTransitions() {\n\t    while (bufferedTransitions.length) {\n\t      bufferedTransitions.shift();\n\t    }\n\t  }\n\t\n\t  function getSlideByIndex(index) {\n\t    for (var i = 0, l = slides.length; i < l; ++i) {\n\t      if (slides[i].index === index) {\n\t        return slides[i];\n\t      }\n\t    }\n\t  }\n\t\n\t  function setActive(index) {\n\t    for (var i = 0; i < slides.length; i++) {\n\t      slides[i].slide.active = i === index;\n\t    }\n\t  }\n\t\n\t  function goNext(slide, index, direction) {\n\t    if (destroyed) {\n\t      return;\n\t    }\n\t\n\t    angular.extend(slide, {direction: direction});\n\t    angular.extend(slides[currentIndex].slide || {}, {direction: direction});\n\t    if ($animate.enabled($element) && !$scope.$currentTransition &&\n\t      slides[index].element && self.slides.length > 1) {\n\t      slides[index].element.data(SLIDE_DIRECTION, slide.direction);\n\t      var currentIdx = self.getCurrentIndex();\n\t\n\t      if (angular.isNumber(currentIdx) && slides[currentIdx].element) {\n\t        slides[currentIdx].element.data(SLIDE_DIRECTION, slide.direction);\n\t      }\n\t\n\t      $scope.$currentTransition = true;\n\t      $animate.on('addClass', slides[index].element, function(element, phase) {\n\t        if (phase === 'close') {\n\t          $scope.$currentTransition = null;\n\t          $animate.off('addClass', element);\n\t          if (bufferedTransitions.length) {\n\t            var nextSlide = bufferedTransitions.pop().slide;\n\t            var nextIndex = nextSlide.index;\n\t            var nextDirection = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';\n\t            clearBufferedTransitions();\n\t\n\t            goNext(nextSlide, nextIndex, nextDirection);\n\t          }\n\t        }\n\t      });\n\t    }\n\t\n\t    $scope.active = slide.index;\n\t    currentIndex = slide.index;\n\t    setActive(index);\n\t\n\t    //every time you change slides, reset the timer\n\t    restartTimer();\n\t  }\n\t\n\t  function findSlideIndex(slide) {\n\t    for (var i = 0; i < slides.length; i++) {\n\t      if (slides[i].slide === slide) {\n\t        return i;\n\t      }\n\t    }\n\t  }\n\t\n\t  function resetTimer() {\n\t    if (currentInterval) {\n\t      $interval.cancel(currentInterval);\n\t      currentInterval = null;\n\t    }\n\t  }\n\t\n\t  function resetTransition(slides) {\n\t    if (!slides.length) {\n\t      $scope.$currentTransition = null;\n\t      clearBufferedTransitions();\n\t    }\n\t  }\n\t\n\t  function restartTimer() {\n\t    resetTimer();\n\t    var interval = +$scope.interval;\n\t    if (!isNaN(interval) && interval > 0) {\n\t      currentInterval = $interval(timerFn, interval);\n\t    }\n\t  }\n\t\n\t  function timerFn() {\n\t    var interval = +$scope.interval;\n\t    if (isPlaying && !isNaN(interval) && interval > 0 && slides.length) {\n\t      $scope.next();\n\t    } else {\n\t      $scope.pause();\n\t    }\n\t  }\n\t}])\n\t\n\t.directive('uibCarousel', function() {\n\t  return {\n\t    transclude: true,\n\t    replace: true,\n\t    controller: 'UibCarouselController',\n\t    controllerAs: 'carousel',\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'uib/template/carousel/carousel.html';\n\t    },\n\t    scope: {\n\t      active: '=',\n\t      interval: '=',\n\t      noTransition: '=',\n\t      noPause: '=',\n\t      noWrap: '&'\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibSlide', function() {\n\t  return {\n\t    require: '^uibCarousel',\n\t    transclude: true,\n\t    replace: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'uib/template/carousel/slide.html';\n\t    },\n\t    scope: {\n\t      actual: '=?',\n\t      index: '=?'\n\t    },\n\t    link: function (scope, element, attrs, carouselCtrl) {\n\t      carouselCtrl.addSlide(scope, element);\n\t      //when the scope is destroyed then remove the slide from the current slides array\n\t      scope.$on('$destroy', function() {\n\t        carouselCtrl.removeSlide(scope);\n\t      });\n\t    }\n\t  };\n\t})\n\t\n\t.animation('.item', ['$animateCss',\n\tfunction($animateCss) {\n\t  var SLIDE_DIRECTION = 'uib-slideDirection';\n\t\n\t  function removeClass(element, className, callback) {\n\t    element.removeClass(className);\n\t    if (callback) {\n\t      callback();\n\t    }\n\t  }\n\t\n\t  return {\n\t    beforeAddClass: function(element, className, done) {\n\t      if (className === 'active') {\n\t        var stopped = false;\n\t        var direction = element.data(SLIDE_DIRECTION);\n\t        var directionClass = direction === 'next' ? 'left' : 'right';\n\t        var removeClassFn = removeClass.bind(this, element,\n\t          directionClass + ' ' + direction, done);\n\t        element.addClass(direction);\n\t\n\t        $animateCss(element, {addClass: directionClass})\n\t          .start()\n\t          .done(removeClassFn);\n\t\n\t        return function() {\n\t          stopped = true;\n\t        };\n\t      }\n\t      done();\n\t    },\n\t    beforeRemoveClass: function (element, className, done) {\n\t      if (className === 'active') {\n\t        var stopped = false;\n\t        var direction = element.data(SLIDE_DIRECTION);\n\t        var directionClass = direction === 'next' ? 'left' : 'right';\n\t        var removeClassFn = removeClass.bind(this, element, directionClass, done);\n\t\n\t        $animateCss(element, {addClass: directionClass})\n\t          .start()\n\t          .done(removeClassFn);\n\t\n\t        return function() {\n\t          stopped = true;\n\t        };\n\t      }\n\t      done();\n\t    }\n\t  };\n\t}]);\n\t\n\tangular.module('ui.bootstrap.dateparser', [])\n\t\n\t.service('uibDateParser', ['$log', '$locale', 'dateFilter', 'orderByFilter', function($log, $locale, dateFilter, orderByFilter) {\n\t  // Pulled from https://github.com/mbostock/d3/blob/master/src/format/requote.js\n\t  var SPECIAL_CHARACTERS_REGEXP = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n\t\n\t  var localeId;\n\t  var formatCodeToRegex;\n\t\n\t  this.init = function() {\n\t    localeId = $locale.id;\n\t\n\t    this.parsers = {};\n\t    this.formatters = {};\n\t\n\t    formatCodeToRegex = [\n\t      {\n\t        key: 'yyyy',\n\t        regex: '\\\\d{4}',\n\t        apply: function(value) { this.year = +value; },\n\t        formatter: function(date) {\n\t          var _date = new Date();\n\t          _date.setFullYear(Math.abs(date.getFullYear()));\n\t          return dateFilter(_date, 'yyyy');\n\t        }\n\t      },\n\t      {\n\t        key: 'yy',\n\t        regex: '\\\\d{2}',\n\t        apply: function(value) { value = +value; this.year = value < 69 ? value + 2000 : value + 1900; },\n\t        formatter: function(date) {\n\t          var _date = new Date();\n\t          _date.setFullYear(Math.abs(date.getFullYear()));\n\t          return dateFilter(_date, 'yy');\n\t        }\n\t      },\n\t      {\n\t        key: 'y',\n\t        regex: '\\\\d{1,4}',\n\t        apply: function(value) { this.year = +value; },\n\t        formatter: function(date) {\n\t          var _date = new Date();\n\t          _date.setFullYear(Math.abs(date.getFullYear()));\n\t          return dateFilter(_date, 'y');\n\t        }\n\t      },\n\t      {\n\t        key: 'M!',\n\t        regex: '0?[1-9]|1[0-2]',\n\t        apply: function(value) { this.month = value - 1; },\n\t        formatter: function(date) {\n\t          var value = date.getMonth();\n\t          if (/^[0-9]$/.test(value)) {\n\t            return dateFilter(date, 'MM');\n\t          }\n\t\n\t          return dateFilter(date, 'M');\n\t        }\n\t      },\n\t      {\n\t        key: 'MMMM',\n\t        regex: $locale.DATETIME_FORMATS.MONTH.join('|'),\n\t        apply: function(value) { this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value); },\n\t        formatter: function(date) { return dateFilter(date, 'MMMM'); }\n\t      },\n\t      {\n\t        key: 'MMM',\n\t        regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\n\t        apply: function(value) { this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value); },\n\t        formatter: function(date) { return dateFilter(date, 'MMM'); }\n\t      },\n\t      {\n\t        key: 'MM',\n\t        regex: '0[1-9]|1[0-2]',\n\t        apply: function(value) { this.month = value - 1; },\n\t        formatter: function(date) { return dateFilter(date, 'MM'); }\n\t      },\n\t      {\n\t        key: 'M',\n\t        regex: '[1-9]|1[0-2]',\n\t        apply: function(value) { this.month = value - 1; },\n\t        formatter: function(date) { return dateFilter(date, 'M'); }\n\t      },\n\t      {\n\t        key: 'd!',\n\t        regex: '[0-2]?[0-9]{1}|3[0-1]{1}',\n\t        apply: function(value) { this.date = +value; },\n\t        formatter: function(date) {\n\t          var value = date.getDate();\n\t          if (/^[1-9]$/.test(value)) {\n\t            return dateFilter(date, 'dd');\n\t          }\n\t\n\t          return dateFilter(date, 'd');\n\t        }\n\t      },\n\t      {\n\t        key: 'dd',\n\t        regex: '[0-2][0-9]{1}|3[0-1]{1}',\n\t        apply: function(value) { this.date = +value; },\n\t        formatter: function(date) { return dateFilter(date, 'dd'); }\n\t      },\n\t      {\n\t        key: 'd',\n\t        regex: '[1-2]?[0-9]{1}|3[0-1]{1}',\n\t        apply: function(value) { this.date = +value; },\n\t        formatter: function(date) { return dateFilter(date, 'd'); }\n\t      },\n\t      {\n\t        key: 'EEEE',\n\t        regex: $locale.DATETIME_FORMATS.DAY.join('|'),\n\t        formatter: function(date) { return dateFilter(date, 'EEEE'); }\n\t      },\n\t      {\n\t        key: 'EEE',\n\t        regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|'),\n\t        formatter: function(date) { return dateFilter(date, 'EEE'); }\n\t      },\n\t      {\n\t        key: 'HH',\n\t        regex: '(?:0|1)[0-9]|2[0-3]',\n\t        apply: function(value) { this.hours = +value; },\n\t        formatter: function(date) { return dateFilter(date, 'HH'); }\n\t      },\n\t      {\n\t        key: 'hh',\n\t        regex: '0[0-9]|1[0-2]',\n\t        apply: function(value) { this.hours = +value; },\n\t        formatter: function(date) { return dateFilter(date, 'hh'); }\n\t      },\n\t      {\n\t        key: 'H',\n\t        regex: '1?[0-9]|2[0-3]',\n\t        apply: function(value) { this.hours = +value; },\n\t        formatter: function(date) { return dateFilter(date, 'H'); }\n\t      },\n\t      {\n\t        key: 'h',\n\t        regex: '[0-9]|1[0-2]',\n\t        apply: function(value) { this.hours = +value; },\n\t        formatter: function(date) { return dateFilter(date, 'h'); }\n\t      },\n\t      {\n\t        key: 'mm',\n\t        regex: '[0-5][0-9]',\n\t        apply: function(value) { this.minutes = +value; },\n\t        formatter: function(date) { return dateFilter(date, 'mm'); }\n\t      },\n\t      {\n\t        key: 'm',\n\t        regex: '[0-9]|[1-5][0-9]',\n\t        apply: function(value) { this.minutes = +value; },\n\t        formatter: function(date) { return dateFilter(date, 'm'); }\n\t      },\n\t      {\n\t        key: 'sss',\n\t        regex: '[0-9][0-9][0-9]',\n\t        apply: function(value) { this.milliseconds = +value; },\n\t        formatter: function(date) { return dateFilter(date, 'sss'); }\n\t      },\n\t      {\n\t        key: 'ss',\n\t        regex: '[0-5][0-9]',\n\t        apply: function(value) { this.seconds = +value; },\n\t        formatter: function(date) { return dateFilter(date, 'ss'); }\n\t      },\n\t      {\n\t        key: 's',\n\t        regex: '[0-9]|[1-5][0-9]',\n\t        apply: function(value) { this.seconds = +value; },\n\t        formatter: function(date) { return dateFilter(date, 's'); }\n\t      },\n\t      {\n\t        key: 'a',\n\t        regex: $locale.DATETIME_FORMATS.AMPMS.join('|'),\n\t        apply: function(value) {\n\t          if (this.hours === 12) {\n\t            this.hours = 0;\n\t          }\n\t\n\t          if (value === 'PM') {\n\t            this.hours += 12;\n\t          }\n\t        },\n\t        formatter: function(date) { return dateFilter(date, 'a'); }\n\t      },\n\t      {\n\t        key: 'Z',\n\t        regex: '[+-]\\\\d{4}',\n\t        apply: function(value) {\n\t          var matches = value.match(/([+-])(\\d{2})(\\d{2})/),\n\t            sign = matches[1],\n\t            hours = matches[2],\n\t            minutes = matches[3];\n\t          this.hours += toInt(sign + hours);\n\t          this.minutes += toInt(sign + minutes);\n\t        },\n\t        formatter: function(date) {\n\t          return dateFilter(date, 'Z');\n\t        }\n\t      },\n\t      {\n\t        key: 'ww',\n\t        regex: '[0-4][0-9]|5[0-3]',\n\t        formatter: function(date) { return dateFilter(date, 'ww'); }\n\t      },\n\t      {\n\t        key: 'w',\n\t        regex: '[0-9]|[1-4][0-9]|5[0-3]',\n\t        formatter: function(date) { return dateFilter(date, 'w'); }\n\t      },\n\t      {\n\t        key: 'GGGG',\n\t        regex: $locale.DATETIME_FORMATS.ERANAMES.join('|').replace(/\\s/g, '\\\\s'),\n\t        formatter: function(date) { return dateFilter(date, 'GGGG'); }\n\t      },\n\t      {\n\t        key: 'GGG',\n\t        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),\n\t        formatter: function(date) { return dateFilter(date, 'GGG'); }\n\t      },\n\t      {\n\t        key: 'GG',\n\t        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),\n\t        formatter: function(date) { return dateFilter(date, 'GG'); }\n\t      },\n\t      {\n\t        key: 'G',\n\t        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),\n\t        formatter: function(date) { return dateFilter(date, 'G'); }\n\t      }\n\t    ];\n\t  };\n\t\n\t  this.init();\n\t\n\t  function createParser(format, func) {\n\t    var map = [], regex = format.split('');\n\t\n\t    // check for literal values\n\t    var quoteIndex = format.indexOf('\\'');\n\t    if (quoteIndex > -1) {\n\t      var inLiteral = false;\n\t      format = format.split('');\n\t      for (var i = quoteIndex; i < format.length; i++) {\n\t        if (inLiteral) {\n\t          if (format[i] === '\\'') {\n\t            if (i + 1 < format.length && format[i+1] === '\\'') { // escaped single quote\n\t              format[i+1] = '$';\n\t              regex[i+1] = '';\n\t            } else { // end of literal\n\t              regex[i] = '';\n\t              inLiteral = false;\n\t            }\n\t          }\n\t          format[i] = '$';\n\t        } else {\n\t          if (format[i] === '\\'') { // start of literal\n\t            format[i] = '$';\n\t            regex[i] = '';\n\t            inLiteral = true;\n\t          }\n\t        }\n\t      }\n\t\n\t      format = format.join('');\n\t    }\n\t\n\t    angular.forEach(formatCodeToRegex, function(data) {\n\t      var index = format.indexOf(data.key);\n\t\n\t      if (index > -1) {\n\t        format = format.split('');\n\t\n\t        regex[index] = '(' + data.regex + ')';\n\t        format[index] = '$'; // Custom symbol to define consumed part of format\n\t        for (var i = index + 1, n = index + data.key.length; i < n; i++) {\n\t          regex[i] = '';\n\t          format[i] = '$';\n\t        }\n\t        format = format.join('');\n\t\n\t        map.push({\n\t          index: index,\n\t          key: data.key,\n\t          apply: data[func],\n\t          matcher: data.regex\n\t        });\n\t      }\n\t    });\n\t\n\t    return {\n\t      regex: new RegExp('^' + regex.join('') + '$'),\n\t      map: orderByFilter(map, 'index')\n\t    };\n\t  }\n\t\n\t  this.filter = function(date, format) {\n\t    if (!angular.isDate(date) || isNaN(date) || !format) {\n\t      return '';\n\t    }\n\t\n\t    format = $locale.DATETIME_FORMATS[format] || format;\n\t\n\t    if ($locale.id !== localeId) {\n\t      this.init();\n\t    }\n\t\n\t    if (!this.formatters[format]) {\n\t      this.formatters[format] = createParser(format, 'formatter');\n\t    }\n\t\n\t    var parser = this.formatters[format],\n\t      map = parser.map;\n\t\n\t    var _format = format;\n\t\n\t    return map.reduce(function(str, mapper, i) {\n\t      var match = _format.match(new RegExp('(.*)' + mapper.key));\n\t      if (match && angular.isString(match[1])) {\n\t        str += match[1];\n\t        _format = _format.replace(match[1] + mapper.key, '');\n\t      }\n\t\n\t      var endStr = i === map.length - 1 ? _format : '';\n\t\n\t      if (mapper.apply) {\n\t        return str + mapper.apply.call(null, date) + endStr;\n\t      }\n\t\n\t      return str + endStr;\n\t    }, '');\n\t  };\n\t\n\t  this.parse = function(input, format, baseDate) {\n\t    if (!angular.isString(input) || !format) {\n\t      return input;\n\t    }\n\t\n\t    format = $locale.DATETIME_FORMATS[format] || format;\n\t    format = format.replace(SPECIAL_CHARACTERS_REGEXP, '\\\\$&');\n\t\n\t    if ($locale.id !== localeId) {\n\t      this.init();\n\t    }\n\t\n\t    if (!this.parsers[format]) {\n\t      this.parsers[format] = createParser(format, 'apply');\n\t    }\n\t\n\t    var parser = this.parsers[format],\n\t        regex = parser.regex,\n\t        map = parser.map,\n\t        results = input.match(regex),\n\t        tzOffset = false;\n\t    if (results && results.length) {\n\t      var fields, dt;\n\t      if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {\n\t        fields = {\n\t          year: baseDate.getFullYear(),\n\t          month: baseDate.getMonth(),\n\t          date: baseDate.getDate(),\n\t          hours: baseDate.getHours(),\n\t          minutes: baseDate.getMinutes(),\n\t          seconds: baseDate.getSeconds(),\n\t          milliseconds: baseDate.getMilliseconds()\n\t        };\n\t      } else {\n\t        if (baseDate) {\n\t          $log.warn('dateparser:', 'baseDate is not a valid date');\n\t        }\n\t        fields = { year: 1900, month: 0, date: 1, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 };\n\t      }\n\t\n\t      for (var i = 1, n = results.length; i < n; i++) {\n\t        var mapper = map[i - 1];\n\t        if (mapper.matcher === 'Z') {\n\t          tzOffset = true;\n\t        }\n\t\n\t        if (mapper.apply) {\n\t          mapper.apply.call(fields, results[i]);\n\t        }\n\t      }\n\t\n\t      var datesetter = tzOffset ? Date.prototype.setUTCFullYear :\n\t        Date.prototype.setFullYear;\n\t      var timesetter = tzOffset ? Date.prototype.setUTCHours :\n\t        Date.prototype.setHours;\n\t\n\t      if (isValid(fields.year, fields.month, fields.date)) {\n\t        if (angular.isDate(baseDate) && !isNaN(baseDate.getTime()) && !tzOffset) {\n\t          dt = new Date(baseDate);\n\t          datesetter.call(dt, fields.year, fields.month, fields.date);\n\t          timesetter.call(dt, fields.hours, fields.minutes,\n\t            fields.seconds, fields.milliseconds);\n\t        } else {\n\t          dt = new Date(0);\n\t          datesetter.call(dt, fields.year, fields.month, fields.date);\n\t          timesetter.call(dt, fields.hours || 0, fields.minutes || 0,\n\t            fields.seconds || 0, fields.milliseconds || 0);\n\t        }\n\t      }\n\t\n\t      return dt;\n\t    }\n\t  };\n\t\n\t  // Check if date is valid for specific month (and year for February).\n\t  // Month: 0 = Jan, 1 = Feb, etc\n\t  function isValid(year, month, date) {\n\t    if (date < 1) {\n\t      return false;\n\t    }\n\t\n\t    if (month === 1 && date > 28) {\n\t      return date === 29 && (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0);\n\t    }\n\t\n\t    if (month === 3 || month === 5 || month === 8 || month === 10) {\n\t      return date < 31;\n\t    }\n\t\n\t    return true;\n\t  }\n\t\n\t  function toInt(str) {\n\t    return parseInt(str, 10);\n\t  }\n\t\n\t  this.toTimezone = toTimezone;\n\t  this.fromTimezone = fromTimezone;\n\t  this.timezoneToOffset = timezoneToOffset;\n\t  this.addDateMinutes = addDateMinutes;\n\t  this.convertTimezoneToLocal = convertTimezoneToLocal;\n\t\n\t  function toTimezone(date, timezone) {\n\t    return date && timezone ? convertTimezoneToLocal(date, timezone) : date;\n\t  }\n\t\n\t  function fromTimezone(date, timezone) {\n\t    return date && timezone ? convertTimezoneToLocal(date, timezone, true) : date;\n\t  }\n\t\n\t  //https://github.com/angular/angular.js/blob/622c42169699ec07fc6daaa19fe6d224e5d2f70e/src/Angular.js#L1207\n\t  function timezoneToOffset(timezone, fallback) {\n\t    timezone = timezone.replace(/:/g, '');\n\t    var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;\n\t    return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;\n\t  }\n\t\n\t  function addDateMinutes(date, minutes) {\n\t    date = new Date(date.getTime());\n\t    date.setMinutes(date.getMinutes() + minutes);\n\t    return date;\n\t  }\n\t\n\t  function convertTimezoneToLocal(date, timezone, reverse) {\n\t    reverse = reverse ? -1 : 1;\n\t    var dateTimezoneOffset = date.getTimezoneOffset();\n\t    var timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);\n\t    return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));\n\t  }\n\t}]);\n\t\n\t// Avoiding use of ng-class as it creates a lot of watchers when a class is to be applied to\n\t// at most one element.\n\tangular.module('ui.bootstrap.isClass', [])\n\t.directive('uibIsClass', [\n\t         '$animate',\n\tfunction ($animate) {\n\t  //                    11111111          22222222\n\t  var ON_REGEXP = /^\\s*([\\s\\S]+?)\\s+on\\s+([\\s\\S]+?)\\s*$/;\n\t  //                    11111111           22222222\n\t  var IS_REGEXP = /^\\s*([\\s\\S]+?)\\s+for\\s+([\\s\\S]+?)\\s*$/;\n\t\n\t  var dataPerTracked = {};\n\t\n\t  return {\n\t    restrict: 'A',\n\t    compile: function(tElement, tAttrs) {\n\t      var linkedScopes = [];\n\t      var instances = [];\n\t      var expToData = {};\n\t      var lastActivated = null;\n\t      var onExpMatches = tAttrs.uibIsClass.match(ON_REGEXP);\n\t      var onExp = onExpMatches[2];\n\t      var expsStr = onExpMatches[1];\n\t      var exps = expsStr.split(',');\n\t\n\t      return linkFn;\n\t\n\t      function linkFn(scope, element, attrs) {\n\t        linkedScopes.push(scope);\n\t        instances.push({\n\t          scope: scope,\n\t          element: element\n\t        });\n\t\n\t        exps.forEach(function(exp, k) {\n\t          addForExp(exp, scope);\n\t        });\n\t\n\t        scope.$on('$destroy', removeScope);\n\t      }\n\t\n\t      function addForExp(exp, scope) {\n\t        var matches = exp.match(IS_REGEXP);\n\t        var clazz = scope.$eval(matches[1]);\n\t        var compareWithExp = matches[2];\n\t        var data = expToData[exp];\n\t        if (!data) {\n\t          var watchFn = function(compareWithVal) {\n\t            var newActivated = null;\n\t            instances.some(function(instance) {\n\t              var thisVal = instance.scope.$eval(onExp);\n\t              if (thisVal === compareWithVal) {\n\t                newActivated = instance;\n\t                return true;\n\t              }\n\t            });\n\t            if (data.lastActivated !== newActivated) {\n\t              if (data.lastActivated) {\n\t                $animate.removeClass(data.lastActivated.element, clazz);\n\t              }\n\t              if (newActivated) {\n\t                $animate.addClass(newActivated.element, clazz);\n\t              }\n\t              data.lastActivated = newActivated;\n\t            }\n\t          };\n\t          expToData[exp] = data = {\n\t            lastActivated: null,\n\t            scope: scope,\n\t            watchFn: watchFn,\n\t            compareWithExp: compareWithExp,\n\t            watcher: scope.$watch(compareWithExp, watchFn)\n\t          };\n\t        }\n\t        data.watchFn(scope.$eval(compareWithExp));\n\t      }\n\t\n\t      function removeScope(e) {\n\t        var removedScope = e.targetScope;\n\t        var index = linkedScopes.indexOf(removedScope);\n\t        linkedScopes.splice(index, 1);\n\t        instances.splice(index, 1);\n\t        if (linkedScopes.length) {\n\t          var newWatchScope = linkedScopes[0];\n\t          angular.forEach(expToData, function(data) {\n\t            if (data.scope === removedScope) {\n\t              data.watcher = newWatchScope.$watch(data.compareWithExp, data.watchFn);\n\t              data.scope = newWatchScope;\n\t            }\n\t          });\n\t        } else {\n\t          expToData = {};\n\t        }\n\t      }\n\t    }\n\t  };\n\t}]);\n\tangular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.isClass'])\n\t\n\t.value('$datepickerSuppressError', false)\n\t\n\t.value('$datepickerLiteralWarning', true)\n\t\n\t.constant('uibDatepickerConfig', {\n\t  datepickerMode: 'day',\n\t  formatDay: 'dd',\n\t  formatMonth: 'MMMM',\n\t  formatYear: 'yyyy',\n\t  formatDayHeader: 'EEE',\n\t  formatDayTitle: 'MMMM yyyy',\n\t  formatMonthTitle: 'yyyy',\n\t  maxDate: null,\n\t  maxMode: 'year',\n\t  minDate: null,\n\t  minMode: 'day',\n\t  ngModelOptions: {},\n\t  shortcutPropagation: false,\n\t  showWeeks: true,\n\t  yearColumns: 5,\n\t  yearRows: 4\n\t})\n\t\n\t.controller('UibDatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$locale', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerLiteralWarning', '$datepickerSuppressError', 'uibDateParser',\n\t  function($scope, $attrs, $parse, $interpolate, $locale, $log, dateFilter, datepickerConfig, $datepickerLiteralWarning, $datepickerSuppressError, dateParser) {\n\t  var self = this,\n\t      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl;\n\t      ngModelOptions = {},\n\t      watchListeners = [],\n\t      optionsUsed = !!$attrs.datepickerOptions;\n\t\n\t  if (!$scope.datepickerOptions) {\n\t    $scope.datepickerOptions = {};\n\t  }\n\t\n\t  // Modes chain\n\t  this.modes = ['day', 'month', 'year'];\n\t\n\t  [\n\t    'customClass',\n\t    'dateDisabled',\n\t    'datepickerMode',\n\t    'formatDay',\n\t    'formatDayHeader',\n\t    'formatDayTitle',\n\t    'formatMonth',\n\t    'formatMonthTitle',\n\t    'formatYear',\n\t    'maxDate',\n\t    'maxMode',\n\t    'minDate',\n\t    'minMode',\n\t    'showWeeks',\n\t    'shortcutPropagation',\n\t    'startingDay',\n\t    'yearColumns',\n\t    'yearRows'\n\t  ].forEach(function(key) {\n\t    switch (key) {\n\t      case 'customClass':\n\t      case 'dateDisabled':\n\t        $scope[key] = $scope.datepickerOptions[key] || angular.noop;\n\t        break;\n\t      case 'datepickerMode':\n\t        $scope.datepickerMode = angular.isDefined($scope.datepickerOptions.datepickerMode) ?\n\t          $scope.datepickerOptions.datepickerMode : datepickerConfig.datepickerMode;\n\t        break;\n\t      case 'formatDay':\n\t      case 'formatDayHeader':\n\t      case 'formatDayTitle':\n\t      case 'formatMonth':\n\t      case 'formatMonthTitle':\n\t      case 'formatYear':\n\t        self[key] = angular.isDefined($scope.datepickerOptions[key]) ?\n\t          $interpolate($scope.datepickerOptions[key])($scope.$parent) :\n\t          datepickerConfig[key];\n\t        break;\n\t      case 'showWeeks':\n\t      case 'shortcutPropagation':\n\t      case 'yearColumns':\n\t      case 'yearRows':\n\t        self[key] = angular.isDefined($scope.datepickerOptions[key]) ?\n\t          $scope.datepickerOptions[key] : datepickerConfig[key];\n\t        break;\n\t      case 'startingDay':\n\t        if (angular.isDefined($scope.datepickerOptions.startingDay)) {\n\t          self.startingDay = $scope.datepickerOptions.startingDay;\n\t        } else if (angular.isNumber(datepickerConfig.startingDay)) {\n\t          self.startingDay = datepickerConfig.startingDay;\n\t        } else {\n\t          self.startingDay = ($locale.DATETIME_FORMATS.FIRSTDAYOFWEEK + 8) % 7;\n\t        }\n\t\n\t        break;\n\t      case 'maxDate':\n\t      case 'minDate':\n\t        $scope.$watch('datepickerOptions.' + key, function(value) {\n\t          if (value) {\n\t            if (angular.isDate(value)) {\n\t              self[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.timezone);\n\t            } else {\n\t              if ($datepickerLiteralWarning) {\n\t                $log.warn('Literal date support has been deprecated, please switch to date object usage');\n\t              }\n\t\n\t              self[key] = new Date(dateFilter(value, 'medium'));\n\t            }\n\t          } else {\n\t            self[key] = datepickerConfig[key] ?\n\t              dateParser.fromTimezone(new Date(datepickerConfig[key]), ngModelOptions.timezone) :\n\t              null;\n\t          }\n\t\n\t          self.refreshView();\n\t        });\n\t\n\t        break;\n\t      case 'maxMode':\n\t      case 'minMode':\n\t        if ($scope.datepickerOptions[key]) {\n\t          $scope.$watch(function() { return $scope.datepickerOptions[key]; }, function(value) {\n\t            self[key] = $scope[key] = angular.isDefined(value) ? value : datepickerOptions[key];\n\t            if (key === 'minMode' && self.modes.indexOf($scope.datepickerOptions.datepickerMode) < self.modes.indexOf(self[key]) ||\n\t              key === 'maxMode' && self.modes.indexOf($scope.datepickerOptions.datepickerMode) > self.modes.indexOf(self[key])) {\n\t              $scope.datepickerMode = self[key];\n\t              $scope.datepickerOptions.datepickerMode = self[key];\n\t            }\n\t          });\n\t        } else {\n\t          self[key] = $scope[key] = datepickerConfig[key] || null;\n\t        }\n\t\n\t        break;\n\t    }\n\t  });\n\t\n\t  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);\n\t\n\t  $scope.disabled = angular.isDefined($attrs.disabled) || false;\n\t  if (angular.isDefined($attrs.ngDisabled)) {\n\t    watchListeners.push($scope.$parent.$watch($attrs.ngDisabled, function(disabled) {\n\t      $scope.disabled = disabled;\n\t      self.refreshView();\n\t    }));\n\t  }\n\t\n\t  $scope.isActive = function(dateObject) {\n\t    if (self.compare(dateObject.date, self.activeDate) === 0) {\n\t      $scope.activeDateId = dateObject.uid;\n\t      return true;\n\t    }\n\t    return false;\n\t  };\n\t\n\t  this.init = function(ngModelCtrl_) {\n\t    ngModelCtrl = ngModelCtrl_;\n\t    ngModelOptions = ngModelCtrl_.$options || datepickerConfig.ngModelOptions;\n\t    if ($scope.datepickerOptions.initDate) {\n\t      self.activeDate = dateParser.fromTimezone($scope.datepickerOptions.initDate, ngModelOptions.timezone) || new Date();\n\t      $scope.$watch('datepickerOptions.initDate', function(initDate) {\n\t        if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {\n\t          self.activeDate = dateParser.fromTimezone(initDate, ngModelOptions.timezone);\n\t          self.refreshView();\n\t        }\n\t      });\n\t    } else {\n\t      self.activeDate = new Date();\n\t    }\n\t\n\t    var date = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : new Date();\n\t    this.activeDate = !isNaN(date) ?\n\t      dateParser.fromTimezone(date, ngModelOptions.timezone) :\n\t      dateParser.fromTimezone(new Date(), ngModelOptions.timezone);\n\t\n\t    ngModelCtrl.$render = function() {\n\t      self.render();\n\t    };\n\t  };\n\t\n\t  this.render = function() {\n\t    if (ngModelCtrl.$viewValue) {\n\t      var date = new Date(ngModelCtrl.$viewValue),\n\t          isValid = !isNaN(date);\n\t\n\t      if (isValid) {\n\t        this.activeDate = dateParser.fromTimezone(date, ngModelOptions.timezone);\n\t      } else if (!$datepickerSuppressError) {\n\t        $log.error('Datepicker directive: \"ng-model\" value must be a Date object');\n\t      }\n\t    }\n\t    this.refreshView();\n\t  };\n\t\n\t  this.refreshView = function() {\n\t    if (this.element) {\n\t      $scope.selectedDt = null;\n\t      this._refreshView();\n\t      if ($scope.activeDt) {\n\t        $scope.activeDateId = $scope.activeDt.uid;\n\t      }\n\t\n\t      var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n\t      date = dateParser.fromTimezone(date, ngModelOptions.timezone);\n\t      ngModelCtrl.$setValidity('dateDisabled', !date ||\n\t        this.element && !this.isDisabled(date));\n\t    }\n\t  };\n\t\n\t  this.createDateObject = function(date, format) {\n\t    var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n\t    model = dateParser.fromTimezone(model, ngModelOptions.timezone);\n\t    var today = new Date();\n\t    today = dateParser.fromTimezone(today, ngModelOptions.timezone);\n\t    var time = this.compare(date, today);\n\t    var dt = {\n\t      date: date,\n\t      label: dateParser.filter(date, format),\n\t      selected: model && this.compare(date, model) === 0,\n\t      disabled: this.isDisabled(date),\n\t      past: time < 0,\n\t      current: time === 0,\n\t      future: time > 0,\n\t      customClass: this.customClass(date) || null\n\t    };\n\t\n\t    if (model && this.compare(date, model) === 0) {\n\t      $scope.selectedDt = dt;\n\t    }\n\t\n\t    if (self.activeDate && this.compare(dt.date, self.activeDate) === 0) {\n\t      $scope.activeDt = dt;\n\t    }\n\t\n\t    return dt;\n\t  };\n\t\n\t  this.isDisabled = function(date) {\n\t    return $scope.disabled ||\n\t      this.minDate && this.compare(date, this.minDate) < 0 ||\n\t      this.maxDate && this.compare(date, this.maxDate) > 0 ||\n\t      $scope.dateDisabled && $scope.dateDisabled({date: date, mode: $scope.datepickerMode});\n\t  };\n\t\n\t  this.customClass = function(date) {\n\t    return $scope.customClass({date: date, mode: $scope.datepickerMode});\n\t  };\n\t\n\t  // Split array into smaller arrays\n\t  this.split = function(arr, size) {\n\t    var arrays = [];\n\t    while (arr.length > 0) {\n\t      arrays.push(arr.splice(0, size));\n\t    }\n\t    return arrays;\n\t  };\n\t\n\t  $scope.select = function(date) {\n\t    if ($scope.datepickerMode === self.minMode) {\n\t      var dt = ngModelCtrl.$viewValue ? dateParser.fromTimezone(new Date(ngModelCtrl.$viewValue), ngModelOptions.timezone) : new Date(0, 0, 0, 0, 0, 0, 0);\n\t      dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());\n\t      dt = dateParser.toTimezone(dt, ngModelOptions.timezone);\n\t      ngModelCtrl.$setViewValue(dt);\n\t      ngModelCtrl.$render();\n\t    } else {\n\t      self.activeDate = date;\n\t      setMode(self.modes[self.modes.indexOf($scope.datepickerMode) - 1]);\n\t\n\t      $scope.$emit('uib:datepicker.mode');\n\t    }\n\t\n\t    $scope.$broadcast('uib:datepicker.focus');\n\t  };\n\t\n\t  $scope.move = function(direction) {\n\t    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),\n\t        month = self.activeDate.getMonth() + direction * (self.step.months || 0);\n\t    self.activeDate.setFullYear(year, month, 1);\n\t    self.refreshView();\n\t  };\n\t\n\t  $scope.toggleMode = function(direction) {\n\t    direction = direction || 1;\n\t\n\t    if ($scope.datepickerMode === self.maxMode && direction === 1 ||\n\t      $scope.datepickerMode === self.minMode && direction === -1) {\n\t      return;\n\t    }\n\t\n\t    setMode(self.modes[self.modes.indexOf($scope.datepickerMode) + direction]);\n\t\n\t    $scope.$emit('uib:datepicker.mode');\n\t  };\n\t\n\t  // Key event mapper\n\t  $scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };\n\t\n\t  var focusElement = function() {\n\t    self.element[0].focus();\n\t  };\n\t\n\t  // Listen for focus requests from popup directive\n\t  $scope.$on('uib:datepicker.focus', focusElement);\n\t\n\t  $scope.keydown = function(evt) {\n\t    var key = $scope.keys[evt.which];\n\t\n\t    if (!key || evt.shiftKey || evt.altKey || $scope.disabled) {\n\t      return;\n\t    }\n\t\n\t    evt.preventDefault();\n\t    if (!self.shortcutPropagation) {\n\t      evt.stopPropagation();\n\t    }\n\t\n\t    if (key === 'enter' || key === 'space') {\n\t      if (self.isDisabled(self.activeDate)) {\n\t        return; // do nothing\n\t      }\n\t      $scope.select(self.activeDate);\n\t    } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {\n\t      $scope.toggleMode(key === 'up' ? 1 : -1);\n\t    } else {\n\t      self.handleKeyDown(key, evt);\n\t      self.refreshView();\n\t    }\n\t  };\n\t\n\t  $scope.$on('$destroy', function() {\n\t    //Clear all watch listeners on destroy\n\t    while (watchListeners.length) {\n\t      watchListeners.shift()();\n\t    }\n\t  });\n\t\n\t  function setMode(mode) {\n\t    $scope.datepickerMode = mode;\n\t    $scope.datepickerOptions.datepickerMode = mode;\n\t  }\n\t}])\n\t\n\t.controller('UibDaypickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\n\t  var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\t\n\t  this.step = { months: 1 };\n\t  this.element = $element;\n\t  function getDaysInMonth(year, month) {\n\t    return month === 1 && year % 4 === 0 &&\n\t      (year % 100 !== 0 || year % 400 === 0) ? 29 : DAYS_IN_MONTH[month];\n\t  }\n\t\n\t  this.init = function(ctrl) {\n\t    angular.extend(ctrl, this);\n\t    scope.showWeeks = ctrl.showWeeks;\n\t    ctrl.refreshView();\n\t  };\n\t\n\t  this.getDates = function(startDate, n) {\n\t    var dates = new Array(n), current = new Date(startDate), i = 0, date;\n\t    while (i < n) {\n\t      date = new Date(current);\n\t      dates[i++] = date;\n\t      current.setDate(current.getDate() + 1);\n\t    }\n\t    return dates;\n\t  };\n\t\n\t  this._refreshView = function() {\n\t    var year = this.activeDate.getFullYear(),\n\t      month = this.activeDate.getMonth(),\n\t      firstDayOfMonth = new Date(this.activeDate);\n\t\n\t    firstDayOfMonth.setFullYear(year, month, 1);\n\t\n\t    var difference = this.startingDay - firstDayOfMonth.getDay(),\n\t      numDisplayedFromPreviousMonth = difference > 0 ?\n\t        7 - difference : - difference,\n\t      firstDate = new Date(firstDayOfMonth);\n\t\n\t    if (numDisplayedFromPreviousMonth > 0) {\n\t      firstDate.setDate(-numDisplayedFromPreviousMonth + 1);\n\t    }\n\t\n\t    // 42 is the number of days on a six-week calendar\n\t    var days = this.getDates(firstDate, 42);\n\t    for (var i = 0; i < 42; i ++) {\n\t      days[i] = angular.extend(this.createDateObject(days[i], this.formatDay), {\n\t        secondary: days[i].getMonth() !== month,\n\t        uid: scope.uniqueId + '-' + i\n\t      });\n\t    }\n\t\n\t    scope.labels = new Array(7);\n\t    for (var j = 0; j < 7; j++) {\n\t      scope.labels[j] = {\n\t        abbr: dateFilter(days[j].date, this.formatDayHeader),\n\t        full: dateFilter(days[j].date, 'EEEE')\n\t      };\n\t    }\n\t\n\t    scope.title = dateFilter(this.activeDate, this.formatDayTitle);\n\t    scope.rows = this.split(days, 7);\n\t\n\t    if (scope.showWeeks) {\n\t      scope.weekNumbers = [];\n\t      var thursdayIndex = (4 + 7 - this.startingDay) % 7,\n\t          numWeeks = scope.rows.length;\n\t      for (var curWeek = 0; curWeek < numWeeks; curWeek++) {\n\t        scope.weekNumbers.push(\n\t          getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));\n\t      }\n\t    }\n\t  };\n\t\n\t  this.compare = function(date1, date2) {\n\t    var _date1 = new Date(date1.getFullYear(), date1.getMonth(), date1.getDate());\n\t    var _date2 = new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());\n\t    _date1.setFullYear(date1.getFullYear());\n\t    _date2.setFullYear(date2.getFullYear());\n\t    return _date1 - _date2;\n\t  };\n\t\n\t  function getISO8601WeekNumber(date) {\n\t    var checkDate = new Date(date);\n\t    checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday\n\t    var time = checkDate.getTime();\n\t    checkDate.setMonth(0); // Compare with Jan 1\n\t    checkDate.setDate(1);\n\t    return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;\n\t  }\n\t\n\t  this.handleKeyDown = function(key, evt) {\n\t    var date = this.activeDate.getDate();\n\t\n\t    if (key === 'left') {\n\t      date = date - 1;\n\t    } else if (key === 'up') {\n\t      date = date - 7;\n\t    } else if (key === 'right') {\n\t      date = date + 1;\n\t    } else if (key === 'down') {\n\t      date = date + 7;\n\t    } else if (key === 'pageup' || key === 'pagedown') {\n\t      var month = this.activeDate.getMonth() + (key === 'pageup' ? - 1 : 1);\n\t      this.activeDate.setMonth(month, 1);\n\t      date = Math.min(getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()), date);\n\t    } else if (key === 'home') {\n\t      date = 1;\n\t    } else if (key === 'end') {\n\t      date = getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth());\n\t    }\n\t    this.activeDate.setDate(date);\n\t  };\n\t}])\n\t\n\t.controller('UibMonthpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\n\t  this.step = { years: 1 };\n\t  this.element = $element;\n\t\n\t  this.init = function(ctrl) {\n\t    angular.extend(ctrl, this);\n\t    ctrl.refreshView();\n\t  };\n\t\n\t  this._refreshView = function() {\n\t    var months = new Array(12),\n\t        year = this.activeDate.getFullYear(),\n\t        date;\n\t\n\t    for (var i = 0; i < 12; i++) {\n\t      date = new Date(this.activeDate);\n\t      date.setFullYear(year, i, 1);\n\t      months[i] = angular.extend(this.createDateObject(date, this.formatMonth), {\n\t        uid: scope.uniqueId + '-' + i\n\t      });\n\t    }\n\t\n\t    scope.title = dateFilter(this.activeDate, this.formatMonthTitle);\n\t    scope.rows = this.split(months, 3);\n\t  };\n\t\n\t  this.compare = function(date1, date2) {\n\t    var _date1 = new Date(date1.getFullYear(), date1.getMonth());\n\t    var _date2 = new Date(date2.getFullYear(), date2.getMonth());\n\t    _date1.setFullYear(date1.getFullYear());\n\t    _date2.setFullYear(date2.getFullYear());\n\t    return _date1 - _date2;\n\t  };\n\t\n\t  this.handleKeyDown = function(key, evt) {\n\t    var date = this.activeDate.getMonth();\n\t\n\t    if (key === 'left') {\n\t      date = date - 1;\n\t    } else if (key === 'up') {\n\t      date = date - 3;\n\t    } else if (key === 'right') {\n\t      date = date + 1;\n\t    } else if (key === 'down') {\n\t      date = date + 3;\n\t    } else if (key === 'pageup' || key === 'pagedown') {\n\t      var year = this.activeDate.getFullYear() + (key === 'pageup' ? - 1 : 1);\n\t      this.activeDate.setFullYear(year);\n\t    } else if (key === 'home') {\n\t      date = 0;\n\t    } else if (key === 'end') {\n\t      date = 11;\n\t    }\n\t    this.activeDate.setMonth(date);\n\t  };\n\t}])\n\t\n\t.controller('UibYearpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\n\t  var columns, range;\n\t  this.element = $element;\n\t\n\t  function getStartingYear(year) {\n\t    return parseInt((year - 1) / range, 10) * range + 1;\n\t  }\n\t\n\t  this.yearpickerInit = function() {\n\t    columns = this.yearColumns;\n\t    range = this.yearRows * columns;\n\t    this.step = { years: range };\n\t  };\n\t\n\t  this._refreshView = function() {\n\t    var years = new Array(range), date;\n\t\n\t    for (var i = 0, start = getStartingYear(this.activeDate.getFullYear()); i < range; i++) {\n\t      date = new Date(this.activeDate);\n\t      date.setFullYear(start + i, 0, 1);\n\t      years[i] = angular.extend(this.createDateObject(date, this.formatYear), {\n\t        uid: scope.uniqueId + '-' + i\n\t      });\n\t    }\n\t\n\t    scope.title = [years[0].label, years[range - 1].label].join(' - ');\n\t    scope.rows = this.split(years, columns);\n\t    scope.columns = columns;\n\t  };\n\t\n\t  this.compare = function(date1, date2) {\n\t    return date1.getFullYear() - date2.getFullYear();\n\t  };\n\t\n\t  this.handleKeyDown = function(key, evt) {\n\t    var date = this.activeDate.getFullYear();\n\t\n\t    if (key === 'left') {\n\t      date = date - 1;\n\t    } else if (key === 'up') {\n\t      date = date - columns;\n\t    } else if (key === 'right') {\n\t      date = date + 1;\n\t    } else if (key === 'down') {\n\t      date = date + columns;\n\t    } else if (key === 'pageup' || key === 'pagedown') {\n\t      date += (key === 'pageup' ? - 1 : 1) * range;\n\t    } else if (key === 'home') {\n\t      date = getStartingYear(this.activeDate.getFullYear());\n\t    } else if (key === 'end') {\n\t      date = getStartingYear(this.activeDate.getFullYear()) + range - 1;\n\t    }\n\t    this.activeDate.setFullYear(date);\n\t  };\n\t}])\n\t\n\t.directive('uibDatepicker', function() {\n\t  return {\n\t    replace: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'uib/template/datepicker/datepicker.html';\n\t    },\n\t    scope: {\n\t      datepickerOptions: '=?'\n\t    },\n\t    require: ['uibDatepicker', '^ngModel'],\n\t    controller: 'UibDatepickerController',\n\t    controllerAs: 'datepicker',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      datepickerCtrl.init(ngModelCtrl);\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibDaypicker', function() {\n\t  return {\n\t    replace: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'uib/template/datepicker/day.html';\n\t    },\n\t    require: ['^uibDatepicker', 'uibDaypicker'],\n\t    controller: 'UibDaypickerController',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var datepickerCtrl = ctrls[0],\n\t        daypickerCtrl = ctrls[1];\n\t\n\t      daypickerCtrl.init(datepickerCtrl);\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibMonthpicker', function() {\n\t  return {\n\t    replace: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'uib/template/datepicker/month.html';\n\t    },\n\t    require: ['^uibDatepicker', 'uibMonthpicker'],\n\t    controller: 'UibMonthpickerController',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var datepickerCtrl = ctrls[0],\n\t        monthpickerCtrl = ctrls[1];\n\t\n\t      monthpickerCtrl.init(datepickerCtrl);\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibYearpicker', function() {\n\t  return {\n\t    replace: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'uib/template/datepicker/year.html';\n\t    },\n\t    require: ['^uibDatepicker', 'uibYearpicker'],\n\t    controller: 'UibYearpickerController',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var ctrl = ctrls[0];\n\t      angular.extend(ctrl, ctrls[1]);\n\t      ctrl.yearpickerInit();\n\t\n\t      ctrl.refreshView();\n\t    }\n\t  };\n\t});\n\t\n\tangular.module('ui.bootstrap.position', [])\n\t\n\t/**\n\t * A set of utility methods for working with the DOM.\n\t * It is meant to be used where we need to absolute-position elements in\n\t * relation to another element (this is the case for tooltips, popovers,\n\t * typeahead suggestions etc.).\n\t */\n\t  .factory('$uibPosition', ['$document', '$window', function($document, $window) {\n\t    /**\n\t     * Used by scrollbarWidth() function to cache scrollbar's width.\n\t     * Do not access this variable directly, use scrollbarWidth() instead.\n\t     */\n\t    var SCROLLBAR_WIDTH;\n\t    /**\n\t     * scrollbar on body and html element in IE and Edge overlay\n\t     * content and should be considered 0 width.\n\t     */\n\t    var BODY_SCROLLBAR_WIDTH;\n\t    var OVERFLOW_REGEX = {\n\t      normal: /(auto|scroll)/,\n\t      hidden: /(auto|scroll|hidden)/\n\t    };\n\t    var PLACEMENT_REGEX = {\n\t      auto: /\\s?auto?\\s?/i,\n\t      primary: /^(top|bottom|left|right)$/,\n\t      secondary: /^(top|bottom|left|right|center)$/,\n\t      vertical: /^(top|bottom)$/\n\t    };\n\t    var BODY_REGEX = /(HTML|BODY)/;\n\t\n\t    return {\n\t\n\t      /**\n\t       * Provides a raw DOM element from a jQuery/jQLite element.\n\t       *\n\t       * @param {element} elem - The element to convert.\n\t       *\n\t       * @returns {element} A HTML element.\n\t       */\n\t      getRawNode: function(elem) {\n\t        return elem.nodeName ? elem : elem[0] || elem;\n\t      },\n\t\n\t      /**\n\t       * Provides a parsed number for a style property.  Strips\n\t       * units and casts invalid numbers to 0.\n\t       *\n\t       * @param {string} value - The style value to parse.\n\t       *\n\t       * @returns {number} A valid number.\n\t       */\n\t      parseStyle: function(value) {\n\t        value = parseFloat(value);\n\t        return isFinite(value) ? value : 0;\n\t      },\n\t\n\t      /**\n\t       * Provides the closest positioned ancestor.\n\t       *\n\t       * @param {element} element - The element to get the offest parent for.\n\t       *\n\t       * @returns {element} The closest positioned ancestor.\n\t       */\n\t      offsetParent: function(elem) {\n\t        elem = this.getRawNode(elem);\n\t\n\t        var offsetParent = elem.offsetParent || $document[0].documentElement;\n\t\n\t        function isStaticPositioned(el) {\n\t          return ($window.getComputedStyle(el).position || 'static') === 'static';\n\t        }\n\t\n\t        while (offsetParent && offsetParent !== $document[0].documentElement && isStaticPositioned(offsetParent)) {\n\t          offsetParent = offsetParent.offsetParent;\n\t        }\n\t\n\t        return offsetParent || $document[0].documentElement;\n\t      },\n\t\n\t      /**\n\t       * Provides the scrollbar width, concept from TWBS measureScrollbar()\n\t       * function in https://github.com/twbs/bootstrap/blob/master/js/modal.js\n\t       * In IE and Edge, scollbar on body and html element overlay and should\n\t       * return a width of 0.\n\t       *\n\t       * @returns {number} The width of the browser scollbar.\n\t       */\n\t      scrollbarWidth: function(isBody) {\n\t        if (isBody) {\n\t          if (angular.isUndefined(BODY_SCROLLBAR_WIDTH)) {\n\t            var bodyElem = $document.find('body');\n\t            bodyElem.addClass('uib-position-body-scrollbar-measure');\n\t            BODY_SCROLLBAR_WIDTH = $window.innerWidth - bodyElem[0].clientWidth;\n\t            BODY_SCROLLBAR_WIDTH = isFinite(BODY_SCROLLBAR_WIDTH) ? BODY_SCROLLBAR_WIDTH : 0;\n\t            bodyElem.removeClass('uib-position-body-scrollbar-measure');\n\t          }\n\t          return BODY_SCROLLBAR_WIDTH;\n\t        }\n\t\n\t        if (angular.isUndefined(SCROLLBAR_WIDTH)) {\n\t          var scrollElem = angular.element('<div class=\"uib-position-scrollbar-measure\"></div>');\n\t          $document.find('body').append(scrollElem);\n\t          SCROLLBAR_WIDTH = scrollElem[0].offsetWidth - scrollElem[0].clientWidth;\n\t          SCROLLBAR_WIDTH = isFinite(SCROLLBAR_WIDTH) ? SCROLLBAR_WIDTH : 0;\n\t          scrollElem.remove();\n\t        }\n\t\n\t        return SCROLLBAR_WIDTH;\n\t      },\n\t\n\t      /**\n\t       * Provides the padding required on an element to replace the scrollbar.\n\t       *\n\t       * @returns {object} An object with the following properties:\n\t       *   <ul>\n\t       *     <li>**scrollbarWidth**: the width of the scrollbar</li>\n\t       *     <li>**widthOverflow**: whether the the width is overflowing</li>\n\t       *     <li>**right**: the amount of right padding on the element needed to replace the scrollbar</li>\n\t       *     <li>**rightOriginal**: the amount of right padding currently on the element</li>\n\t       *     <li>**heightOverflow**: whether the the height is overflowing</li>\n\t       *     <li>**bottom**: the amount of bottom padding on the element needed to replace the scrollbar</li>\n\t       *     <li>**bottomOriginal**: the amount of bottom padding currently on the element</li>\n\t       *   </ul>\n\t       */\n\t      scrollbarPadding: function(elem) {\n\t        elem = this.getRawNode(elem);\n\t\n\t        var elemStyle = $window.getComputedStyle(elem);\n\t        var paddingRight = this.parseStyle(elemStyle.paddingRight);\n\t        var paddingBottom = this.parseStyle(elemStyle.paddingBottom);\n\t        var scrollParent = this.scrollParent(elem, false, true);\n\t        var scrollbarWidth = this.scrollbarWidth(scrollParent, BODY_REGEX.test(scrollParent.tagName));\n\t\n\t        return {\n\t          scrollbarWidth: scrollbarWidth,\n\t          widthOverflow: scrollParent.scrollWidth > scrollParent.clientWidth,\n\t          right: paddingRight + scrollbarWidth,\n\t          originalRight: paddingRight,\n\t          heightOverflow: scrollParent.scrollHeight > scrollParent.clientHeight,\n\t          bottom: paddingBottom + scrollbarWidth,\n\t          originalBottom: paddingBottom\n\t         };\n\t      },\n\t\n\t      /**\n\t       * Checks to see if the element is scrollable.\n\t       *\n\t       * @param {element} elem - The element to check.\n\t       * @param {boolean=} [includeHidden=false] - Should scroll style of 'hidden' be considered,\n\t       *   default is false.\n\t       *\n\t       * @returns {boolean} Whether the element is scrollable.\n\t       */\n\t      isScrollable: function(elem, includeHidden) {\n\t        elem = this.getRawNode(elem);\n\t\n\t        var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;\n\t        var elemStyle = $window.getComputedStyle(elem);\n\t        return overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX);\n\t      },\n\t\n\t      /**\n\t       * Provides the closest scrollable ancestor.\n\t       * A port of the jQuery UI scrollParent method:\n\t       * https://github.com/jquery/jquery-ui/blob/master/ui/scroll-parent.js\n\t       *\n\t       * @param {element} elem - The element to find the scroll parent of.\n\t       * @param {boolean=} [includeHidden=false] - Should scroll style of 'hidden' be considered,\n\t       *   default is false.\n\t       * @param {boolean=} [includeSelf=false] - Should the element being passed be\n\t       * included in the scrollable llokup.\n\t       *\n\t       * @returns {element} A HTML element.\n\t       */\n\t      scrollParent: function(elem, includeHidden, includeSelf) {\n\t        elem = this.getRawNode(elem);\n\t\n\t        var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;\n\t        var documentEl = $document[0].documentElement;\n\t        var elemStyle = $window.getComputedStyle(elem);\n\t        if (includeSelf && overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX)) {\n\t          return elem;\n\t        }\n\t        var excludeStatic = elemStyle.position === 'absolute';\n\t        var scrollParent = elem.parentElement || documentEl;\n\t\n\t        if (scrollParent === documentEl || elemStyle.position === 'fixed') {\n\t          return documentEl;\n\t        }\n\t\n\t        while (scrollParent.parentElement && scrollParent !== documentEl) {\n\t          var spStyle = $window.getComputedStyle(scrollParent);\n\t          if (excludeStatic && spStyle.position !== 'static') {\n\t            excludeStatic = false;\n\t          }\n\t\n\t          if (!excludeStatic && overflowRegex.test(spStyle.overflow + spStyle.overflowY + spStyle.overflowX)) {\n\t            break;\n\t          }\n\t          scrollParent = scrollParent.parentElement;\n\t        }\n\t\n\t        return scrollParent;\n\t      },\n\t\n\t      /**\n\t       * Provides read-only equivalent of jQuery's position function:\n\t       * http://api.jquery.com/position/ - distance to closest positioned\n\t       * ancestor.  Does not account for margins by default like jQuery position.\n\t       *\n\t       * @param {element} elem - The element to caclulate the position on.\n\t       * @param {boolean=} [includeMargins=false] - Should margins be accounted\n\t       * for, default is false.\n\t       *\n\t       * @returns {object} An object with the following properties:\n\t       *   <ul>\n\t       *     <li>**width**: the width of the element</li>\n\t       *     <li>**height**: the height of the element</li>\n\t       *     <li>**top**: distance to top edge of offset parent</li>\n\t       *     <li>**left**: distance to left edge of offset parent</li>\n\t       *   </ul>\n\t       */\n\t      position: function(elem, includeMagins) {\n\t        elem = this.getRawNode(elem);\n\t\n\t        var elemOffset = this.offset(elem);\n\t        if (includeMagins) {\n\t          var elemStyle = $window.getComputedStyle(elem);\n\t          elemOffset.top -= this.parseStyle(elemStyle.marginTop);\n\t          elemOffset.left -= this.parseStyle(elemStyle.marginLeft);\n\t        }\n\t        var parent = this.offsetParent(elem);\n\t        var parentOffset = {top: 0, left: 0};\n\t\n\t        if (parent !== $document[0].documentElement) {\n\t          parentOffset = this.offset(parent);\n\t          parentOffset.top += parent.clientTop - parent.scrollTop;\n\t          parentOffset.left += parent.clientLeft - parent.scrollLeft;\n\t        }\n\t\n\t        return {\n\t          width: Math.round(angular.isNumber(elemOffset.width) ? elemOffset.width : elem.offsetWidth),\n\t          height: Math.round(angular.isNumber(elemOffset.height) ? elemOffset.height : elem.offsetHeight),\n\t          top: Math.round(elemOffset.top - parentOffset.top),\n\t          left: Math.round(elemOffset.left - parentOffset.left)\n\t        };\n\t      },\n\t\n\t      /**\n\t       * Provides read-only equivalent of jQuery's offset function:\n\t       * http://api.jquery.com/offset/ - distance to viewport.  Does\n\t       * not account for borders, margins, or padding on the body\n\t       * element.\n\t       *\n\t       * @param {element} elem - The element to calculate the offset on.\n\t       *\n\t       * @returns {object} An object with the following properties:\n\t       *   <ul>\n\t       *     <li>**width**: the width of the element</li>\n\t       *     <li>**height**: the height of the element</li>\n\t       *     <li>**top**: distance to top edge of viewport</li>\n\t       *     <li>**right**: distance to bottom edge of viewport</li>\n\t       *   </ul>\n\t       */\n\t      offset: function(elem) {\n\t        elem = this.getRawNode(elem);\n\t\n\t        var elemBCR = elem.getBoundingClientRect();\n\t        return {\n\t          width: Math.round(angular.isNumber(elemBCR.width) ? elemBCR.width : elem.offsetWidth),\n\t          height: Math.round(angular.isNumber(elemBCR.height) ? elemBCR.height : elem.offsetHeight),\n\t          top: Math.round(elemBCR.top + ($window.pageYOffset || $document[0].documentElement.scrollTop)),\n\t          left: Math.round(elemBCR.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft))\n\t        };\n\t      },\n\t\n\t      /**\n\t       * Provides offset distance to the closest scrollable ancestor\n\t       * or viewport.  Accounts for border and scrollbar width.\n\t       *\n\t       * Right and bottom dimensions represent the distance to the\n\t       * respective edge of the viewport element.  If the element\n\t       * edge extends beyond the viewport, a negative value will be\n\t       * reported.\n\t       *\n\t       * @param {element} elem - The element to get the viewport offset for.\n\t       * @param {boolean=} [useDocument=false] - Should the viewport be the document element instead\n\t       * of the first scrollable element, default is false.\n\t       * @param {boolean=} [includePadding=true] - Should the padding on the offset parent element\n\t       * be accounted for, default is true.\n\t       *\n\t       * @returns {object} An object with the following properties:\n\t       *   <ul>\n\t       *     <li>**top**: distance to the top content edge of viewport element</li>\n\t       *     <li>**bottom**: distance to the bottom content edge of viewport element</li>\n\t       *     <li>**left**: distance to the left content edge of viewport element</li>\n\t       *     <li>**right**: distance to the right content edge of viewport element</li>\n\t       *   </ul>\n\t       */\n\t      viewportOffset: function(elem, useDocument, includePadding) {\n\t        elem = this.getRawNode(elem);\n\t        includePadding = includePadding !== false ? true : false;\n\t\n\t        var elemBCR = elem.getBoundingClientRect();\n\t        var offsetBCR = {top: 0, left: 0, bottom: 0, right: 0};\n\t\n\t        var offsetParent = useDocument ? $document[0].documentElement : this.scrollParent(elem);\n\t        var offsetParentBCR = offsetParent.getBoundingClientRect();\n\t\n\t        offsetBCR.top = offsetParentBCR.top + offsetParent.clientTop;\n\t        offsetBCR.left = offsetParentBCR.left + offsetParent.clientLeft;\n\t        if (offsetParent === $document[0].documentElement) {\n\t          offsetBCR.top += $window.pageYOffset;\n\t          offsetBCR.left += $window.pageXOffset;\n\t        }\n\t        offsetBCR.bottom = offsetBCR.top + offsetParent.clientHeight;\n\t        offsetBCR.right = offsetBCR.left + offsetParent.clientWidth;\n\t\n\t        if (includePadding) {\n\t          var offsetParentStyle = $window.getComputedStyle(offsetParent);\n\t          offsetBCR.top += this.parseStyle(offsetParentStyle.paddingTop);\n\t          offsetBCR.bottom -= this.parseStyle(offsetParentStyle.paddingBottom);\n\t          offsetBCR.left += this.parseStyle(offsetParentStyle.paddingLeft);\n\t          offsetBCR.right -= this.parseStyle(offsetParentStyle.paddingRight);\n\t        }\n\t\n\t        return {\n\t          top: Math.round(elemBCR.top - offsetBCR.top),\n\t          bottom: Math.round(offsetBCR.bottom - elemBCR.bottom),\n\t          left: Math.round(elemBCR.left - offsetBCR.left),\n\t          right: Math.round(offsetBCR.right - elemBCR.right)\n\t        };\n\t      },\n\t\n\t      /**\n\t       * Provides an array of placement values parsed from a placement string.\n\t       * Along with the 'auto' indicator, supported placement strings are:\n\t       *   <ul>\n\t       *     <li>top: element on top, horizontally centered on host element.</li>\n\t       *     <li>top-left: element on top, left edge aligned with host element left edge.</li>\n\t       *     <li>top-right: element on top, lerightft edge aligned with host element right edge.</li>\n\t       *     <li>bottom: element on bottom, horizontally centered on host element.</li>\n\t       *     <li>bottom-left: element on bottom, left edge aligned with host element left edge.</li>\n\t       *     <li>bottom-right: element on bottom, right edge aligned with host element right edge.</li>\n\t       *     <li>left: element on left, vertically centered on host element.</li>\n\t       *     <li>left-top: element on left, top edge aligned with host element top edge.</li>\n\t       *     <li>left-bottom: element on left, bottom edge aligned with host element bottom edge.</li>\n\t       *     <li>right: element on right, vertically centered on host element.</li>\n\t       *     <li>right-top: element on right, top edge aligned with host element top edge.</li>\n\t       *     <li>right-bottom: element on right, bottom edge aligned with host element bottom edge.</li>\n\t       *   </ul>\n\t       * A placement string with an 'auto' indicator is expected to be\n\t       * space separated from the placement, i.e: 'auto bottom-left'  If\n\t       * the primary and secondary placement values do not match 'top,\n\t       * bottom, left, right' then 'top' will be the primary placement and\n\t       * 'center' will be the secondary placement.  If 'auto' is passed, true\n\t       * will be returned as the 3rd value of the array.\n\t       *\n\t       * @param {string} placement - The placement string to parse.\n\t       *\n\t       * @returns {array} An array with the following values\n\t       * <ul>\n\t       *   <li>**[0]**: The primary placement.</li>\n\t       *   <li>**[1]**: The secondary placement.</li>\n\t       *   <li>**[2]**: If auto is passed: true, else undefined.</li>\n\t       * </ul>\n\t       */\n\t      parsePlacement: function(placement) {\n\t        var autoPlace = PLACEMENT_REGEX.auto.test(placement);\n\t        if (autoPlace) {\n\t          placement = placement.replace(PLACEMENT_REGEX.auto, '');\n\t        }\n\t\n\t        placement = placement.split('-');\n\t\n\t        placement[0] = placement[0] || 'top';\n\t        if (!PLACEMENT_REGEX.primary.test(placement[0])) {\n\t          placement[0] = 'top';\n\t        }\n\t\n\t        placement[1] = placement[1] || 'center';\n\t        if (!PLACEMENT_REGEX.secondary.test(placement[1])) {\n\t          placement[1] = 'center';\n\t        }\n\t\n\t        if (autoPlace) {\n\t          placement[2] = true;\n\t        } else {\n\t          placement[2] = false;\n\t        }\n\t\n\t        return placement;\n\t      },\n\t\n\t      /**\n\t       * Provides coordinates for an element to be positioned relative to\n\t       * another element.  Passing 'auto' as part of the placement parameter\n\t       * will enable smart placement - where the element fits. i.e:\n\t       * 'auto left-top' will check to see if there is enough space to the left\n\t       * of the hostElem to fit the targetElem, if not place right (same for secondary\n\t       * top placement).  Available space is calculated using the viewportOffset\n\t       * function.\n\t       *\n\t       * @param {element} hostElem - The element to position against.\n\t       * @param {element} targetElem - The element to position.\n\t       * @param {string=} [placement=top] - The placement for the targetElem,\n\t       *   default is 'top'. 'center' is assumed as secondary placement for\n\t       *   'top', 'left', 'right', and 'bottom' placements.  Available placements are:\n\t       *   <ul>\n\t       *     <li>top</li>\n\t       *     <li>top-right</li>\n\t       *     <li>top-left</li>\n\t       *     <li>bottom</li>\n\t       *     <li>bottom-left</li>\n\t       *     <li>bottom-right</li>\n\t       *     <li>left</li>\n\t       *     <li>left-top</li>\n\t       *     <li>left-bottom</li>\n\t       *     <li>right</li>\n\t       *     <li>right-top</li>\n\t       *     <li>right-bottom</li>\n\t       *   </ul>\n\t       * @param {boolean=} [appendToBody=false] - Should the top and left values returned\n\t       *   be calculated from the body element, default is false.\n\t       *\n\t       * @returns {object} An object with the following properties:\n\t       *   <ul>\n\t       *     <li>**top**: Value for targetElem top.</li>\n\t       *     <li>**left**: Value for targetElem left.</li>\n\t       *     <li>**placement**: The resolved placement.</li>\n\t       *   </ul>\n\t       */\n\t      positionElements: function(hostElem, targetElem, placement, appendToBody) {\n\t        hostElem = this.getRawNode(hostElem);\n\t        targetElem = this.getRawNode(targetElem);\n\t\n\t        // need to read from prop to support tests.\n\t        var targetWidth = angular.isDefined(targetElem.offsetWidth) ? targetElem.offsetWidth : targetElem.prop('offsetWidth');\n\t        var targetHeight = angular.isDefined(targetElem.offsetHeight) ? targetElem.offsetHeight : targetElem.prop('offsetHeight');\n\t\n\t        placement = this.parsePlacement(placement);\n\t\n\t        var hostElemPos = appendToBody ? this.offset(hostElem) : this.position(hostElem);\n\t        var targetElemPos = {top: 0, left: 0, placement: ''};\n\t\n\t        if (placement[2]) {\n\t          var viewportOffset = this.viewportOffset(hostElem, appendToBody);\n\t\n\t          var targetElemStyle = $window.getComputedStyle(targetElem);\n\t          var adjustedSize = {\n\t            width: targetWidth + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginLeft) + this.parseStyle(targetElemStyle.marginRight))),\n\t            height: targetHeight + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginTop) + this.parseStyle(targetElemStyle.marginBottom)))\n\t          };\n\t\n\t          placement[0] = placement[0] === 'top' && adjustedSize.height > viewportOffset.top && adjustedSize.height <= viewportOffset.bottom ? 'bottom' :\n\t                         placement[0] === 'bottom' && adjustedSize.height > viewportOffset.bottom && adjustedSize.height <= viewportOffset.top ? 'top' :\n\t                         placement[0] === 'left' && adjustedSize.width > viewportOffset.left && adjustedSize.width <= viewportOffset.right ? 'right' :\n\t                         placement[0] === 'right' && adjustedSize.width > viewportOffset.right && adjustedSize.width <= viewportOffset.left ? 'left' :\n\t                         placement[0];\n\t\n\t          placement[1] = placement[1] === 'top' && adjustedSize.height - hostElemPos.height > viewportOffset.bottom && adjustedSize.height - hostElemPos.height <= viewportOffset.top ? 'bottom' :\n\t                         placement[1] === 'bottom' && adjustedSize.height - hostElemPos.height > viewportOffset.top && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom ? 'top' :\n\t                         placement[1] === 'left' && adjustedSize.width - hostElemPos.width > viewportOffset.right && adjustedSize.width - hostElemPos.width <= viewportOffset.left ? 'right' :\n\t                         placement[1] === 'right' && adjustedSize.width - hostElemPos.width > viewportOffset.left && adjustedSize.width - hostElemPos.width <= viewportOffset.right ? 'left' :\n\t                         placement[1];\n\t\n\t          if (placement[1] === 'center') {\n\t            if (PLACEMENT_REGEX.vertical.test(placement[0])) {\n\t              var xOverflow = hostElemPos.width / 2 - targetWidth / 2;\n\t              if (viewportOffset.left + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.right) {\n\t                placement[1] = 'left';\n\t              } else if (viewportOffset.right + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.left) {\n\t                placement[1] = 'right';\n\t              }\n\t            } else {\n\t              var yOverflow = hostElemPos.height / 2 - adjustedSize.height / 2;\n\t              if (viewportOffset.top + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom) {\n\t                placement[1] = 'top';\n\t              } else if (viewportOffset.bottom + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.top) {\n\t                placement[1] = 'bottom';\n\t              }\n\t            }\n\t          }\n\t        }\n\t\n\t        switch (placement[0]) {\n\t          case 'top':\n\t            targetElemPos.top = hostElemPos.top - targetHeight;\n\t            break;\n\t          case 'bottom':\n\t            targetElemPos.top = hostElemPos.top + hostElemPos.height;\n\t            break;\n\t          case 'left':\n\t            targetElemPos.left = hostElemPos.left - targetWidth;\n\t            break;\n\t          case 'right':\n\t            targetElemPos.left = hostElemPos.left + hostElemPos.width;\n\t            break;\n\t        }\n\t\n\t        switch (placement[1]) {\n\t          case 'top':\n\t            targetElemPos.top = hostElemPos.top;\n\t            break;\n\t          case 'bottom':\n\t            targetElemPos.top = hostElemPos.top + hostElemPos.height - targetHeight;\n\t            break;\n\t          case 'left':\n\t            targetElemPos.left = hostElemPos.left;\n\t            break;\n\t          case 'right':\n\t            targetElemPos.left = hostElemPos.left + hostElemPos.width - targetWidth;\n\t            break;\n\t          case 'center':\n\t            if (PLACEMENT_REGEX.vertical.test(placement[0])) {\n\t              targetElemPos.left = hostElemPos.left + hostElemPos.width / 2 - targetWidth / 2;\n\t            } else {\n\t              targetElemPos.top = hostElemPos.top + hostElemPos.height / 2 - targetHeight / 2;\n\t            }\n\t            break;\n\t        }\n\t\n\t        targetElemPos.top = Math.round(targetElemPos.top);\n\t        targetElemPos.left = Math.round(targetElemPos.left);\n\t        targetElemPos.placement = placement[1] === 'center' ? placement[0] : placement[0] + '-' + placement[1];\n\t\n\t        return targetElemPos;\n\t      },\n\t\n\t      /**\n\t      * Provides a way for positioning tooltip & dropdown\n\t      * arrows when using placement options beyond the standard\n\t      * left, right, top, or bottom.\n\t      *\n\t      * @param {element} elem - The tooltip/dropdown element.\n\t      * @param {string} placement - The placement for the elem.\n\t      */\n\t      positionArrow: function(elem, placement) {\n\t        elem = this.getRawNode(elem);\n\t\n\t        var innerElem = elem.querySelector('.tooltip-inner, .popover-inner');\n\t        if (!innerElem) {\n\t          return;\n\t        }\n\t\n\t        var isTooltip = angular.element(innerElem).hasClass('tooltip-inner');\n\t\n\t        var arrowElem = isTooltip ? elem.querySelector('.tooltip-arrow') : elem.querySelector('.arrow');\n\t        if (!arrowElem) {\n\t          return;\n\t        }\n\t\n\t        var arrowCss = {\n\t          top: '',\n\t          bottom: '',\n\t          left: '',\n\t          right: ''\n\t        };\n\t\n\t        placement = this.parsePlacement(placement);\n\t        if (placement[1] === 'center') {\n\t          // no adjustment necessary - just reset styles\n\t          angular.element(arrowElem).css(arrowCss);\n\t          return;\n\t        }\n\t\n\t        var borderProp = 'border-' + placement[0] + '-width';\n\t        var borderWidth = $window.getComputedStyle(arrowElem)[borderProp];\n\t\n\t        var borderRadiusProp = 'border-';\n\t        if (PLACEMENT_REGEX.vertical.test(placement[0])) {\n\t          borderRadiusProp += placement[0] + '-' + placement[1];\n\t        } else {\n\t          borderRadiusProp += placement[1] + '-' + placement[0];\n\t        }\n\t        borderRadiusProp += '-radius';\n\t        var borderRadius = $window.getComputedStyle(isTooltip ? innerElem : elem)[borderRadiusProp];\n\t\n\t        switch (placement[0]) {\n\t          case 'top':\n\t            arrowCss.bottom = isTooltip ? '0' : '-' + borderWidth;\n\t            break;\n\t          case 'bottom':\n\t            arrowCss.top = isTooltip ? '0' : '-' + borderWidth;\n\t            break;\n\t          case 'left':\n\t            arrowCss.right = isTooltip ? '0' : '-' + borderWidth;\n\t            break;\n\t          case 'right':\n\t            arrowCss.left = isTooltip ? '0' : '-' + borderWidth;\n\t            break;\n\t        }\n\t\n\t        arrowCss[placement[1]] = borderRadius;\n\t\n\t        angular.element(arrowElem).css(arrowCss);\n\t      }\n\t    };\n\t  }]);\n\t\n\tangular.module('ui.bootstrap.datepickerPopup', ['ui.bootstrap.datepicker', 'ui.bootstrap.position'])\n\t\n\t.value('$datepickerPopupLiteralWarning', true)\n\t\n\t.constant('uibDatepickerPopupConfig', {\n\t  altInputFormats: [],\n\t  appendToBody: false,\n\t  clearText: 'Clear',\n\t  closeOnDateSelection: true,\n\t  closeText: 'Done',\n\t  currentText: 'Today',\n\t  datepickerPopup: 'yyyy-MM-dd',\n\t  datepickerPopupTemplateUrl: 'uib/template/datepickerPopup/popup.html',\n\t  datepickerTemplateUrl: 'uib/template/datepicker/datepicker.html',\n\t  html5Types: {\n\t    date: 'yyyy-MM-dd',\n\t    'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss',\n\t    'month': 'yyyy-MM'\n\t  },\n\t  onOpenFocus: true,\n\t  showButtonBar: true,\n\t  placement: 'auto bottom-left'\n\t})\n\t\n\t.controller('UibDatepickerPopupController', ['$scope', '$element', '$attrs', '$compile', '$log', '$parse', '$window', '$document', '$rootScope', '$uibPosition', 'dateFilter', 'uibDateParser', 'uibDatepickerPopupConfig', '$timeout', 'uibDatepickerConfig', '$datepickerPopupLiteralWarning',\n\tfunction($scope, $element, $attrs, $compile, $log, $parse, $window, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout, datepickerConfig, $datepickerPopupLiteralWarning) {\n\t  var cache = {},\n\t    isHtml5DateInput = false;\n\t  var dateFormat, closeOnDateSelection, appendToBody, onOpenFocus,\n\t    datepickerPopupTemplateUrl, datepickerTemplateUrl, popupEl, datepickerEl, scrollParentEl,\n\t    ngModel, ngModelOptions, $popup, altInputFormats, watchListeners = [],\n\t    timezone;\n\t\n\t  this.init = function(_ngModel_) {\n\t    ngModel = _ngModel_;\n\t    ngModelOptions = _ngModel_.$options;\n\t    closeOnDateSelection = angular.isDefined($attrs.closeOnDateSelection) ?\n\t      $scope.$parent.$eval($attrs.closeOnDateSelection) :\n\t      datepickerPopupConfig.closeOnDateSelection;\n\t    appendToBody = angular.isDefined($attrs.datepickerAppendToBody) ?\n\t      $scope.$parent.$eval($attrs.datepickerAppendToBody) :\n\t      datepickerPopupConfig.appendToBody;\n\t    onOpenFocus = angular.isDefined($attrs.onOpenFocus) ?\n\t      $scope.$parent.$eval($attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus;\n\t    datepickerPopupTemplateUrl = angular.isDefined($attrs.datepickerPopupTemplateUrl) ?\n\t      $attrs.datepickerPopupTemplateUrl :\n\t      datepickerPopupConfig.datepickerPopupTemplateUrl;\n\t    datepickerTemplateUrl = angular.isDefined($attrs.datepickerTemplateUrl) ?\n\t      $attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl;\n\t    altInputFormats = angular.isDefined($attrs.altInputFormats) ?\n\t      $scope.$parent.$eval($attrs.altInputFormats) :\n\t      datepickerPopupConfig.altInputFormats;\n\t\n\t    $scope.showButtonBar = angular.isDefined($attrs.showButtonBar) ?\n\t      $scope.$parent.$eval($attrs.showButtonBar) :\n\t      datepickerPopupConfig.showButtonBar;\n\t\n\t    if (datepickerPopupConfig.html5Types[$attrs.type]) {\n\t      dateFormat = datepickerPopupConfig.html5Types[$attrs.type];\n\t      isHtml5DateInput = true;\n\t    } else {\n\t      dateFormat = $attrs.uibDatepickerPopup || datepickerPopupConfig.datepickerPopup;\n\t      $attrs.$observe('uibDatepickerPopup', function(value, oldValue) {\n\t        var newDateFormat = value || datepickerPopupConfig.datepickerPopup;\n\t        // Invalidate the $modelValue to ensure that formatters re-run\n\t        // FIXME: Refactor when PR is merged: https://github.com/angular/angular.js/pull/10764\n\t        if (newDateFormat !== dateFormat) {\n\t          dateFormat = newDateFormat;\n\t          ngModel.$modelValue = null;\n\t\n\t          if (!dateFormat) {\n\t            throw new Error('uibDatepickerPopup must have a date format specified.');\n\t          }\n\t        }\n\t      });\n\t    }\n\t\n\t    if (!dateFormat) {\n\t      throw new Error('uibDatepickerPopup must have a date format specified.');\n\t    }\n\t\n\t    if (isHtml5DateInput && $attrs.uibDatepickerPopup) {\n\t      throw new Error('HTML5 date input types do not support custom formats.');\n\t    }\n\t\n\t    // popup element used to display calendar\n\t    popupEl = angular.element('<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>');\n\t    if (ngModelOptions) {\n\t      timezone = ngModelOptions.timezone;\n\t      $scope.ngModelOptions = angular.copy(ngModelOptions);\n\t      $scope.ngModelOptions.timezone = null;\n\t      if ($scope.ngModelOptions.updateOnDefault === true) {\n\t        $scope.ngModelOptions.updateOn = $scope.ngModelOptions.updateOn ?\n\t          $scope.ngModelOptions.updateOn + ' default' : 'default';\n\t      }\n\t\n\t      popupEl.attr('ng-model-options', 'ngModelOptions');\n\t    } else {\n\t      timezone = null;\n\t    }\n\t\n\t    popupEl.attr({\n\t      'ng-model': 'date',\n\t      'ng-change': 'dateSelection(date)',\n\t      'template-url': datepickerPopupTemplateUrl\n\t    });\n\t\n\t    // datepicker element\n\t    datepickerEl = angular.element(popupEl.children()[0]);\n\t    datepickerEl.attr('template-url', datepickerTemplateUrl);\n\t\n\t    if (!$scope.datepickerOptions) {\n\t      $scope.datepickerOptions = {};\n\t    }\n\t\n\t    if (isHtml5DateInput) {\n\t      if ($attrs.type === 'month') {\n\t        $scope.datepickerOptions.datepickerMode = 'month';\n\t        $scope.datepickerOptions.minMode = 'month';\n\t      }\n\t    }\n\t\n\t    datepickerEl.attr('datepicker-options', 'datepickerOptions');\n\t\n\t    if (!isHtml5DateInput) {\n\t      // Internal API to maintain the correct ng-invalid-[key] class\n\t      ngModel.$$parserName = 'date';\n\t      ngModel.$validators.date = validator;\n\t      ngModel.$parsers.unshift(parseDate);\n\t      ngModel.$formatters.push(function(value) {\n\t        if (ngModel.$isEmpty(value)) {\n\t          $scope.date = value;\n\t          return value;\n\t        }\n\t\n\t        if (angular.isNumber(value)) {\n\t          value = new Date(value);\n\t        }\n\t\n\t        $scope.date = dateParser.fromTimezone(value, timezone);\n\t\n\t        return dateParser.filter($scope.date, dateFormat);\n\t      });\n\t    } else {\n\t      ngModel.$formatters.push(function(value) {\n\t        $scope.date = dateParser.fromTimezone(value, timezone);\n\t        return value;\n\t      });\n\t    }\n\t\n\t    // Detect changes in the view from the text box\n\t    ngModel.$viewChangeListeners.push(function() {\n\t      $scope.date = parseDateString(ngModel.$viewValue);\n\t    });\n\t\n\t    $element.on('keydown', inputKeydownBind);\n\t\n\t    $popup = $compile(popupEl)($scope);\n\t    // Prevent jQuery cache memory leak (template is now redundant after linking)\n\t    popupEl.remove();\n\t\n\t    if (appendToBody) {\n\t      $document.find('body').append($popup);\n\t    } else {\n\t      $element.after($popup);\n\t    }\n\t\n\t    $scope.$on('$destroy', function() {\n\t      if ($scope.isOpen === true) {\n\t        if (!$rootScope.$$phase) {\n\t          $scope.$apply(function() {\n\t            $scope.isOpen = false;\n\t          });\n\t        }\n\t      }\n\t\n\t      $popup.remove();\n\t      $element.off('keydown', inputKeydownBind);\n\t      $document.off('click', documentClickBind);\n\t      if (scrollParentEl) {\n\t        scrollParentEl.off('scroll', positionPopup);\n\t      }\n\t      angular.element($window).off('resize', positionPopup);\n\t\n\t      //Clear all watch listeners on destroy\n\t      while (watchListeners.length) {\n\t        watchListeners.shift()();\n\t      }\n\t    });\n\t  };\n\t\n\t  $scope.getText = function(key) {\n\t    return $scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];\n\t  };\n\t\n\t  $scope.isDisabled = function(date) {\n\t    if (date === 'today') {\n\t      date = dateParser.fromTimezone(new Date(), timezone);\n\t    }\n\t\n\t    var dates = {};\n\t    angular.forEach(['minDate', 'maxDate'], function(key) {\n\t      if (!$scope.datepickerOptions[key]) {\n\t        dates[key] = null;\n\t      } else if (angular.isDate($scope.datepickerOptions[key])) {\n\t        dates[key] = dateParser.fromTimezone(new Date($scope.datepickerOptions[key]), timezone);\n\t      } else {\n\t        if ($datepickerPopupLiteralWarning) {\n\t          $log.warn('Literal date support has been deprecated, please switch to date object usage');\n\t        }\n\t\n\t        dates[key] = new Date(dateFilter($scope.datepickerOptions[key], 'medium'));\n\t      }\n\t    });\n\t\n\t    return $scope.datepickerOptions &&\n\t      dates.minDate && $scope.compare(date, dates.minDate) < 0 ||\n\t      dates.maxDate && $scope.compare(date, dates.maxDate) > 0;\n\t  };\n\t\n\t  $scope.compare = function(date1, date2) {\n\t    return new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());\n\t  };\n\t\n\t  // Inner change\n\t  $scope.dateSelection = function(dt) {\n\t    if (angular.isDefined(dt)) {\n\t      $scope.date = dt;\n\t    }\n\t    var date = $scope.date ? dateParser.filter($scope.date, dateFormat) : null; // Setting to NULL is necessary for form validators to function\n\t    $element.val(date);\n\t    ngModel.$setViewValue(date);\n\t\n\t    if (closeOnDateSelection) {\n\t      $scope.isOpen = false;\n\t      $element[0].focus();\n\t    }\n\t  };\n\t\n\t  $scope.keydown = function(evt) {\n\t    if (evt.which === 27) {\n\t      evt.stopPropagation();\n\t      $scope.isOpen = false;\n\t      $element[0].focus();\n\t    }\n\t  };\n\t\n\t  $scope.select = function(date, evt) {\n\t    evt.stopPropagation();\n\t\n\t    if (date === 'today') {\n\t      var today = new Date();\n\t      if (angular.isDate($scope.date)) {\n\t        date = new Date($scope.date);\n\t        date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());\n\t      } else {\n\t        date = new Date(today.setHours(0, 0, 0, 0));\n\t      }\n\t    }\n\t    $scope.dateSelection(date);\n\t  };\n\t\n\t  $scope.close = function(evt) {\n\t    evt.stopPropagation();\n\t\n\t    $scope.isOpen = false;\n\t    $element[0].focus();\n\t  };\n\t\n\t  $scope.disabled = angular.isDefined($attrs.disabled) || false;\n\t  if ($attrs.ngDisabled) {\n\t    watchListeners.push($scope.$parent.$watch($parse($attrs.ngDisabled), function(disabled) {\n\t      $scope.disabled = disabled;\n\t    }));\n\t  }\n\t\n\t  $scope.$watch('isOpen', function(value) {\n\t    if (value) {\n\t      if (!$scope.disabled) {\n\t        $timeout(function() {\n\t          positionPopup();\n\t\n\t          if (onOpenFocus) {\n\t            $scope.$broadcast('uib:datepicker.focus');\n\t          }\n\t\n\t          $document.on('click', documentClickBind);\n\t\n\t          var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;\n\t          if (appendToBody || $position.parsePlacement(placement)[2]) {\n\t            scrollParentEl = scrollParentEl || angular.element($position.scrollParent($element));\n\t            if (scrollParentEl) {\n\t              scrollParentEl.on('scroll', positionPopup);\n\t            }\n\t          } else {\n\t            scrollParentEl = null;\n\t          }\n\t\n\t          angular.element($window).on('resize', positionPopup);\n\t        }, 0, false);\n\t      } else {\n\t        $scope.isOpen = false;\n\t      }\n\t    } else {\n\t      $document.off('click', documentClickBind);\n\t      if (scrollParentEl) {\n\t        scrollParentEl.off('scroll', positionPopup);\n\t      }\n\t      angular.element($window).off('resize', positionPopup);\n\t    }\n\t  });\n\t\n\t  function cameltoDash(string) {\n\t    return string.replace(/([A-Z])/g, function($1) { return '-' + $1.toLowerCase(); });\n\t  }\n\t\n\t  function parseDateString(viewValue) {\n\t    var date = dateParser.parse(viewValue, dateFormat, $scope.date);\n\t    if (isNaN(date)) {\n\t      for (var i = 0; i < altInputFormats.length; i++) {\n\t        date = dateParser.parse(viewValue, altInputFormats[i], $scope.date);\n\t        if (!isNaN(date)) {\n\t          return date;\n\t        }\n\t      }\n\t    }\n\t    return date;\n\t  }\n\t\n\t  function parseDate(viewValue) {\n\t    if (angular.isNumber(viewValue)) {\n\t      // presumably timestamp to date object\n\t      viewValue = new Date(viewValue);\n\t    }\n\t\n\t    if (!viewValue) {\n\t      return null;\n\t    }\n\t\n\t    if (angular.isDate(viewValue) && !isNaN(viewValue)) {\n\t      return viewValue;\n\t    }\n\t\n\t    if (angular.isString(viewValue)) {\n\t      var date = parseDateString(viewValue);\n\t      if (!isNaN(date)) {\n\t        return dateParser.toTimezone(date, timezone);\n\t      }\n\t    }\n\t\n\t    return ngModel.$options && ngModel.$options.allowInvalid ? viewValue : undefined;\n\t  }\n\t\n\t  function validator(modelValue, viewValue) {\n\t    var value = modelValue || viewValue;\n\t\n\t    if (!$attrs.ngRequired && !value) {\n\t      return true;\n\t    }\n\t\n\t    if (angular.isNumber(value)) {\n\t      value = new Date(value);\n\t    }\n\t\n\t    if (!value) {\n\t      return true;\n\t    }\n\t\n\t    if (angular.isDate(value) && !isNaN(value)) {\n\t      return true;\n\t    }\n\t\n\t    if (angular.isString(value)) {\n\t      return !isNaN(parseDateString(viewValue));\n\t    }\n\t\n\t    return false;\n\t  }\n\t\n\t  function documentClickBind(event) {\n\t    if (!$scope.isOpen && $scope.disabled) {\n\t      return;\n\t    }\n\t\n\t    var popup = $popup[0];\n\t    var dpContainsTarget = $element[0].contains(event.target);\n\t    // The popup node may not be an element node\n\t    // In some browsers (IE) only element nodes have the 'contains' function\n\t    var popupContainsTarget = popup.contains !== undefined && popup.contains(event.target);\n\t    if ($scope.isOpen && !(dpContainsTarget || popupContainsTarget)) {\n\t      $scope.$apply(function() {\n\t        $scope.isOpen = false;\n\t      });\n\t    }\n\t  }\n\t\n\t  function inputKeydownBind(evt) {\n\t    if (evt.which === 27 && $scope.isOpen) {\n\t      evt.preventDefault();\n\t      evt.stopPropagation();\n\t      $scope.$apply(function() {\n\t        $scope.isOpen = false;\n\t      });\n\t      $element[0].focus();\n\t    } else if (evt.which === 40 && !$scope.isOpen) {\n\t      evt.preventDefault();\n\t      evt.stopPropagation();\n\t      $scope.$apply(function() {\n\t        $scope.isOpen = true;\n\t      });\n\t    }\n\t  }\n\t\n\t  function positionPopup() {\n\t    if ($scope.isOpen) {\n\t      var dpElement = angular.element($popup[0].querySelector('.uib-datepicker-popup'));\n\t      var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;\n\t      var position = $position.positionElements($element, dpElement, placement, appendToBody);\n\t      dpElement.css({top: position.top + 'px', left: position.left + 'px'});\n\t      if (dpElement.hasClass('uib-position-measure')) {\n\t        dpElement.removeClass('uib-position-measure');\n\t      }\n\t    }\n\t  }\n\t\n\t  $scope.$on('uib:datepicker.mode', function() {\n\t    $timeout(positionPopup, 0, false);\n\t  });\n\t}])\n\t\n\t.directive('uibDatepickerPopup', function() {\n\t  return {\n\t    require: ['ngModel', 'uibDatepickerPopup'],\n\t    controller: 'UibDatepickerPopupController',\n\t    scope: {\n\t      datepickerOptions: '=?',\n\t      isOpen: '=?',\n\t      currentText: '@',\n\t      clearText: '@',\n\t      closeText: '@'\n\t    },\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var ngModel = ctrls[0],\n\t        ctrl = ctrls[1];\n\t\n\t      ctrl.init(ngModel);\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibDatepickerPopupWrap', function() {\n\t  return {\n\t    replace: true,\n\t    transclude: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'uib/template/datepickerPopup/popup.html';\n\t    }\n\t  };\n\t});\n\t\n\tangular.module('ui.bootstrap.debounce', [])\n\t/**\n\t * A helper, internal service that debounces a function\n\t */\n\t  .factory('$$debounce', ['$timeout', function($timeout) {\n\t    return function(callback, debounceTime) {\n\t      var timeoutPromise;\n\t\n\t      return function() {\n\t        var self = this;\n\t        var args = Array.prototype.slice.call(arguments);\n\t        if (timeoutPromise) {\n\t          $timeout.cancel(timeoutPromise);\n\t        }\n\t\n\t        timeoutPromise = $timeout(function() {\n\t          callback.apply(self, args);\n\t        }, debounceTime);\n\t      };\n\t    };\n\t  }]);\n\t\n\tangular.module('ui.bootstrap.dropdown', ['ui.bootstrap.position'])\n\t\n\t.constant('uibDropdownConfig', {\n\t  appendToOpenClass: 'uib-dropdown-open',\n\t  openClass: 'open'\n\t})\n\t\n\t.service('uibDropdownService', ['$document', '$rootScope', function($document, $rootScope) {\n\t  var openScope = null;\n\t\n\t  this.open = function(dropdownScope, element) {\n\t    if (!openScope) {\n\t      $document.on('click', closeDropdown);\n\t      element.on('keydown', keybindFilter);\n\t    }\n\t\n\t    if (openScope && openScope !== dropdownScope) {\n\t      openScope.isOpen = false;\n\t    }\n\t\n\t    openScope = dropdownScope;\n\t  };\n\t\n\t  this.close = function(dropdownScope, element) {\n\t    if (openScope === dropdownScope) {\n\t      openScope = null;\n\t      $document.off('click', closeDropdown);\n\t      element.off('keydown', keybindFilter);\n\t    }\n\t  };\n\t\n\t  var closeDropdown = function(evt) {\n\t    // This method may still be called during the same mouse event that\n\t    // unbound this event handler. So check openScope before proceeding.\n\t    if (!openScope) { return; }\n\t\n\t    if (evt && openScope.getAutoClose() === 'disabled') { return; }\n\t\n\t    if (evt && evt.which === 3) { return; }\n\t\n\t    var toggleElement = openScope.getToggleElement();\n\t    if (evt && toggleElement && toggleElement[0].contains(evt.target)) {\n\t      return;\n\t    }\n\t\n\t    var dropdownElement = openScope.getDropdownElement();\n\t    if (evt && openScope.getAutoClose() === 'outsideClick' &&\n\t      dropdownElement && dropdownElement[0].contains(evt.target)) {\n\t      return;\n\t    }\n\t\n\t    openScope.isOpen = false;\n\t\n\t    if (!$rootScope.$$phase) {\n\t      openScope.$apply();\n\t    }\n\t  };\n\t\n\t  var keybindFilter = function(evt) {\n\t    if (evt.which === 27) {\n\t      evt.stopPropagation();\n\t      openScope.focusToggleElement();\n\t      closeDropdown();\n\t    } else if (openScope.isKeynavEnabled() && [38, 40].indexOf(evt.which) !== -1 && openScope.isOpen) {\n\t      evt.preventDefault();\n\t      evt.stopPropagation();\n\t      openScope.focusDropdownEntry(evt.which);\n\t    }\n\t  };\n\t}])\n\t\n\t.controller('UibDropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest) {\n\t  var self = this,\n\t    scope = $scope.$new(), // create a child scope so we are not polluting original one\n\t    templateScope,\n\t    appendToOpenClass = dropdownConfig.appendToOpenClass,\n\t    openClass = dropdownConfig.openClass,\n\t    getIsOpen,\n\t    setIsOpen = angular.noop,\n\t    toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,\n\t    appendToBody = false,\n\t    appendTo = null,\n\t    keynavEnabled = false,\n\t    selectedOption = null,\n\t    body = $document.find('body');\n\t\n\t  $element.addClass('dropdown');\n\t\n\t  this.init = function() {\n\t    if ($attrs.isOpen) {\n\t      getIsOpen = $parse($attrs.isOpen);\n\t      setIsOpen = getIsOpen.assign;\n\t\n\t      $scope.$watch(getIsOpen, function(value) {\n\t        scope.isOpen = !!value;\n\t      });\n\t    }\n\t\n\t    if (angular.isDefined($attrs.dropdownAppendTo)) {\n\t      var appendToEl = $parse($attrs.dropdownAppendTo)(scope);\n\t      if (appendToEl) {\n\t        appendTo = angular.element(appendToEl);\n\t      }\n\t    }\n\t\n\t    appendToBody = angular.isDefined($attrs.dropdownAppendToBody);\n\t    keynavEnabled = angular.isDefined($attrs.keyboardNav);\n\t\n\t    if (appendToBody && !appendTo) {\n\t      appendTo = body;\n\t    }\n\t\n\t    if (appendTo && self.dropdownMenu) {\n\t      appendTo.append(self.dropdownMenu);\n\t      $element.on('$destroy', function handleDestroyEvent() {\n\t        self.dropdownMenu.remove();\n\t      });\n\t    }\n\t  };\n\t\n\t  this.toggle = function(open) {\n\t    scope.isOpen = arguments.length ? !!open : !scope.isOpen;\n\t    if (angular.isFunction(setIsOpen)) {\n\t      setIsOpen(scope, scope.isOpen);\n\t    }\n\t\n\t    return scope.isOpen;\n\t  };\n\t\n\t  // Allow other directives to watch status\n\t  this.isOpen = function() {\n\t    return scope.isOpen;\n\t  };\n\t\n\t  scope.getToggleElement = function() {\n\t    return self.toggleElement;\n\t  };\n\t\n\t  scope.getAutoClose = function() {\n\t    return $attrs.autoClose || 'always'; //or 'outsideClick' or 'disabled'\n\t  };\n\t\n\t  scope.getElement = function() {\n\t    return $element;\n\t  };\n\t\n\t  scope.isKeynavEnabled = function() {\n\t    return keynavEnabled;\n\t  };\n\t\n\t  scope.focusDropdownEntry = function(keyCode) {\n\t    var elems = self.dropdownMenu ? //If append to body is used.\n\t      angular.element(self.dropdownMenu).find('a') :\n\t      $element.find('ul').eq(0).find('a');\n\t\n\t    switch (keyCode) {\n\t      case 40: {\n\t        if (!angular.isNumber(self.selectedOption)) {\n\t          self.selectedOption = 0;\n\t        } else {\n\t          self.selectedOption = self.selectedOption === elems.length - 1 ?\n\t            self.selectedOption :\n\t            self.selectedOption + 1;\n\t        }\n\t        break;\n\t      }\n\t      case 38: {\n\t        if (!angular.isNumber(self.selectedOption)) {\n\t          self.selectedOption = elems.length - 1;\n\t        } else {\n\t          self.selectedOption = self.selectedOption === 0 ?\n\t            0 : self.selectedOption - 1;\n\t        }\n\t        break;\n\t      }\n\t    }\n\t    elems[self.selectedOption].focus();\n\t  };\n\t\n\t  scope.getDropdownElement = function() {\n\t    return self.dropdownMenu;\n\t  };\n\t\n\t  scope.focusToggleElement = function() {\n\t    if (self.toggleElement) {\n\t      self.toggleElement[0].focus();\n\t    }\n\t  };\n\t\n\t  scope.$watch('isOpen', function(isOpen, wasOpen) {\n\t    if (appendTo && self.dropdownMenu) {\n\t      var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true),\n\t        css,\n\t        rightalign,\n\t        scrollbarWidth;\n\t\n\t      css = {\n\t        top: pos.top + 'px',\n\t        display: isOpen ? 'block' : 'none'\n\t      };\n\t\n\t      rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');\n\t      if (!rightalign) {\n\t        css.left = pos.left + 'px';\n\t        css.right = 'auto';\n\t      } else {\n\t        css.left = 'auto';\n\t        scrollbarWidth = $position.scrollbarWidth(true);\n\t        css.right = window.innerWidth - scrollbarWidth -\n\t          (pos.left + $element.prop('offsetWidth')) + 'px';\n\t      }\n\t\n\t      // Need to adjust our positioning to be relative to the appendTo container\n\t      // if it's not the body element\n\t      if (!appendToBody) {\n\t        var appendOffset = $position.offset(appendTo);\n\t\n\t        css.top = pos.top - appendOffset.top + 'px';\n\t\n\t        if (!rightalign) {\n\t          css.left = pos.left - appendOffset.left + 'px';\n\t        } else {\n\t          css.right = window.innerWidth -\n\t            (pos.left - appendOffset.left + $element.prop('offsetWidth')) + 'px';\n\t        }\n\t      }\n\t\n\t      self.dropdownMenu.css(css);\n\t    }\n\t\n\t    var openContainer = appendTo ? appendTo : $element;\n\t    var hasOpenClass = openContainer.hasClass(appendTo ? appendToOpenClass : openClass);\n\t\n\t    if (hasOpenClass === !isOpen) {\n\t      $animate[isOpen ? 'addClass' : 'removeClass'](openContainer, appendTo ? appendToOpenClass : openClass).then(function() {\n\t        if (angular.isDefined(isOpen) && isOpen !== wasOpen) {\n\t          toggleInvoker($scope, { open: !!isOpen });\n\t        }\n\t      });\n\t    }\n\t\n\t    if (isOpen) {\n\t      if (self.dropdownMenuTemplateUrl) {\n\t        $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {\n\t          templateScope = scope.$new();\n\t          $compile(tplContent.trim())(templateScope, function(dropdownElement) {\n\t            var newEl = dropdownElement;\n\t            self.dropdownMenu.replaceWith(newEl);\n\t            self.dropdownMenu = newEl;\n\t          });\n\t        });\n\t      }\n\t\n\t      scope.focusToggleElement();\n\t      uibDropdownService.open(scope, $element);\n\t    } else {\n\t      if (self.dropdownMenuTemplateUrl) {\n\t        if (templateScope) {\n\t          templateScope.$destroy();\n\t        }\n\t        var newEl = angular.element('<ul class=\"dropdown-menu\"></ul>');\n\t        self.dropdownMenu.replaceWith(newEl);\n\t        self.dropdownMenu = newEl;\n\t      }\n\t\n\t      uibDropdownService.close(scope, $element);\n\t      self.selectedOption = null;\n\t    }\n\t\n\t    if (angular.isFunction(setIsOpen)) {\n\t      setIsOpen($scope, isOpen);\n\t    }\n\t  });\n\t}])\n\t\n\t.directive('uibDropdown', function() {\n\t  return {\n\t    controller: 'UibDropdownController',\n\t    link: function(scope, element, attrs, dropdownCtrl) {\n\t      dropdownCtrl.init();\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibDropdownMenu', function() {\n\t  return {\n\t    restrict: 'A',\n\t    require: '?^uibDropdown',\n\t    link: function(scope, element, attrs, dropdownCtrl) {\n\t      if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {\n\t        return;\n\t      }\n\t\n\t      element.addClass('dropdown-menu');\n\t\n\t      var tplUrl = attrs.templateUrl;\n\t      if (tplUrl) {\n\t        dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;\n\t      }\n\t\n\t      if (!dropdownCtrl.dropdownMenu) {\n\t        dropdownCtrl.dropdownMenu = element;\n\t      }\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibDropdownToggle', function() {\n\t  return {\n\t    require: '?^uibDropdown',\n\t    link: function(scope, element, attrs, dropdownCtrl) {\n\t      if (!dropdownCtrl) {\n\t        return;\n\t      }\n\t\n\t      element.addClass('dropdown-toggle');\n\t\n\t      dropdownCtrl.toggleElement = element;\n\t\n\t      var toggleDropdown = function(event) {\n\t        event.preventDefault();\n\t\n\t        if (!element.hasClass('disabled') && !attrs.disabled) {\n\t          scope.$apply(function() {\n\t            dropdownCtrl.toggle();\n\t          });\n\t        }\n\t      };\n\t\n\t      element.bind('click', toggleDropdown);\n\t\n\t      // WAI-ARIA\n\t      element.attr({ 'aria-haspopup': true, 'aria-expanded': false });\n\t      scope.$watch(dropdownCtrl.isOpen, function(isOpen) {\n\t        element.attr('aria-expanded', !!isOpen);\n\t      });\n\t\n\t      scope.$on('$destroy', function() {\n\t        element.unbind('click', toggleDropdown);\n\t      });\n\t    }\n\t  };\n\t});\n\t\n\tangular.module('ui.bootstrap.stackedMap', [])\n\t/**\n\t * A helper, internal data structure that acts as a map but also allows getting / removing\n\t * elements in the LIFO order\n\t */\n\t  .factory('$$stackedMap', function() {\n\t    return {\n\t      createNew: function() {\n\t        var stack = [];\n\t\n\t        return {\n\t          add: function(key, value) {\n\t            stack.push({\n\t              key: key,\n\t              value: value\n\t            });\n\t          },\n\t          get: function(key) {\n\t            for (var i = 0; i < stack.length; i++) {\n\t              if (key === stack[i].key) {\n\t                return stack[i];\n\t              }\n\t            }\n\t          },\n\t          keys: function() {\n\t            var keys = [];\n\t            for (var i = 0; i < stack.length; i++) {\n\t              keys.push(stack[i].key);\n\t            }\n\t            return keys;\n\t          },\n\t          top: function() {\n\t            return stack[stack.length - 1];\n\t          },\n\t          remove: function(key) {\n\t            var idx = -1;\n\t            for (var i = 0; i < stack.length; i++) {\n\t              if (key === stack[i].key) {\n\t                idx = i;\n\t                break;\n\t              }\n\t            }\n\t            return stack.splice(idx, 1)[0];\n\t          },\n\t          removeTop: function() {\n\t            return stack.splice(stack.length - 1, 1)[0];\n\t          },\n\t          length: function() {\n\t            return stack.length;\n\t          }\n\t        };\n\t      }\n\t    };\n\t  });\n\tangular.module('ui.bootstrap.modal', ['ui.bootstrap.stackedMap', 'ui.bootstrap.position'])\n\t/**\n\t * A helper, internal data structure that stores all references attached to key\n\t */\n\t  .factory('$$multiMap', function() {\n\t    return {\n\t      createNew: function() {\n\t        var map = {};\n\t\n\t        return {\n\t          entries: function() {\n\t            return Object.keys(map).map(function(key) {\n\t              return {\n\t                key: key,\n\t                value: map[key]\n\t              };\n\t            });\n\t          },\n\t          get: function(key) {\n\t            return map[key];\n\t          },\n\t          hasKey: function(key) {\n\t            return !!map[key];\n\t          },\n\t          keys: function() {\n\t            return Object.keys(map);\n\t          },\n\t          put: function(key, value) {\n\t            if (!map[key]) {\n\t              map[key] = [];\n\t            }\n\t\n\t            map[key].push(value);\n\t          },\n\t          remove: function(key, value) {\n\t            var values = map[key];\n\t\n\t            if (!values) {\n\t              return;\n\t            }\n\t\n\t            var idx = values.indexOf(value);\n\t\n\t            if (idx !== -1) {\n\t              values.splice(idx, 1);\n\t            }\n\t\n\t            if (!values.length) {\n\t              delete map[key];\n\t            }\n\t          }\n\t        };\n\t      }\n\t    };\n\t  })\n\t\n\t/**\n\t * Pluggable resolve mechanism for the modal resolve resolution\n\t * Supports UI Router's $resolve service\n\t */\n\t  .provider('$uibResolve', function() {\n\t    var resolve = this;\n\t    this.resolver = null;\n\t\n\t    this.setResolver = function(resolver) {\n\t      this.resolver = resolver;\n\t    };\n\t\n\t    this.$get = ['$injector', '$q', function($injector, $q) {\n\t      var resolver = resolve.resolver ? $injector.get(resolve.resolver) : null;\n\t      return {\n\t        resolve: function(invocables, locals, parent, self) {\n\t          if (resolver) {\n\t            return resolver.resolve(invocables, locals, parent, self);\n\t          }\n\t\n\t          var promises = [];\n\t\n\t          angular.forEach(invocables, function(value) {\n\t            if (angular.isFunction(value) || angular.isArray(value)) {\n\t              promises.push($q.resolve($injector.invoke(value)));\n\t            } else if (angular.isString(value)) {\n\t              promises.push($q.resolve($injector.get(value)));\n\t            } else {\n\t              promises.push($q.resolve(value));\n\t            }\n\t          });\n\t\n\t          return $q.all(promises).then(function(resolves) {\n\t            var resolveObj = {};\n\t            var resolveIter = 0;\n\t            angular.forEach(invocables, function(value, key) {\n\t              resolveObj[key] = resolves[resolveIter++];\n\t            });\n\t\n\t            return resolveObj;\n\t          });\n\t        }\n\t      };\n\t    }];\n\t  })\n\t\n\t/**\n\t * A helper directive for the $modal service. It creates a backdrop element.\n\t */\n\t  .directive('uibModalBackdrop', ['$animate', '$injector', '$uibModalStack',\n\t  function($animate, $injector, $modalStack) {\n\t    return {\n\t      replace: true,\n\t      templateUrl: 'uib/template/modal/backdrop.html',\n\t      compile: function(tElement, tAttrs) {\n\t        tElement.addClass(tAttrs.backdropClass);\n\t        return linkFn;\n\t      }\n\t    };\n\t\n\t    function linkFn(scope, element, attrs) {\n\t      if (attrs.modalInClass) {\n\t        $animate.addClass(element, attrs.modalInClass);\n\t\n\t        scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n\t          var done = setIsAsync();\n\t          if (scope.modalOptions.animation) {\n\t            $animate.removeClass(element, attrs.modalInClass).then(done);\n\t          } else {\n\t            done();\n\t          }\n\t        });\n\t      }\n\t    }\n\t  }])\n\t\n\t  .directive('uibModalWindow', ['$uibModalStack', '$q', '$animateCss', '$document',\n\t  function($modalStack, $q, $animateCss, $document) {\n\t    return {\n\t      scope: {\n\t        index: '@'\n\t      },\n\t      replace: true,\n\t      transclude: true,\n\t      templateUrl: function(tElement, tAttrs) {\n\t        return tAttrs.templateUrl || 'uib/template/modal/window.html';\n\t      },\n\t      link: function(scope, element, attrs) {\n\t        element.addClass(attrs.windowClass || '');\n\t        element.addClass(attrs.windowTopClass || '');\n\t        scope.size = attrs.size;\n\t\n\t        scope.close = function(evt) {\n\t          var modal = $modalStack.getTop();\n\t          if (modal && modal.value.backdrop &&\n\t            modal.value.backdrop !== 'static' &&\n\t            evt.target === evt.currentTarget) {\n\t            evt.preventDefault();\n\t            evt.stopPropagation();\n\t            $modalStack.dismiss(modal.key, 'backdrop click');\n\t          }\n\t        };\n\t\n\t        // moved from template to fix issue #2280\n\t        element.on('click', scope.close);\n\t\n\t        // This property is only added to the scope for the purpose of detecting when this directive is rendered.\n\t        // We can detect that by using this property in the template associated with this directive and then use\n\t        // {@link Attribute#$observe} on it. For more details please see {@link TableColumnResize}.\n\t        scope.$isRendered = true;\n\t\n\t        // Deferred object that will be resolved when this modal is render.\n\t        var modalRenderDeferObj = $q.defer();\n\t        // Observe function will be called on next digest cycle after compilation, ensuring that the DOM is ready.\n\t        // In order to use this way of finding whether DOM is ready, we need to observe a scope property used in modal's template.\n\t        attrs.$observe('modalRender', function(value) {\n\t          if (value === 'true') {\n\t            modalRenderDeferObj.resolve();\n\t          }\n\t        });\n\t\n\t        modalRenderDeferObj.promise.then(function() {\n\t          var animationPromise = null;\n\t\n\t          if (attrs.modalInClass) {\n\t            animationPromise = $animateCss(element, {\n\t              addClass: attrs.modalInClass\n\t            }).start();\n\t\n\t            scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n\t              var done = setIsAsync();\n\t              $animateCss(element, {\n\t                removeClass: attrs.modalInClass\n\t              }).start().then(done);\n\t            });\n\t          }\n\t\n\t\n\t          $q.when(animationPromise).then(function() {\n\t            // Notify {@link $modalStack} that modal is rendered.\n\t            var modal = $modalStack.getTop();\n\t            if (modal) {\n\t              $modalStack.modalRendered(modal.key);\n\t            }\n\t\n\t            /**\n\t             * If something within the freshly-opened modal already has focus (perhaps via a\n\t             * directive that causes focus). then no need to try and focus anything.\n\t             */\n\t            if (!($document[0].activeElement && element[0].contains($document[0].activeElement))) {\n\t              var inputWithAutofocus = element[0].querySelector('[autofocus]');\n\t              /**\n\t               * Auto-focusing of a freshly-opened modal element causes any child elements\n\t               * with the autofocus attribute to lose focus. This is an issue on touch\n\t               * based devices which will show and then hide the onscreen keyboard.\n\t               * Attempts to refocus the autofocus element via JavaScript will not reopen\n\t               * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus\n\t               * the modal element if the modal does not contain an autofocus element.\n\t               */\n\t              if (inputWithAutofocus) {\n\t                inputWithAutofocus.focus();\n\t              } else {\n\t                element[0].focus();\n\t              }\n\t            }\n\t          });\n\t        });\n\t      }\n\t    };\n\t  }])\n\t\n\t  .directive('uibModalAnimationClass', function() {\n\t    return {\n\t      compile: function(tElement, tAttrs) {\n\t        if (tAttrs.modalAnimation) {\n\t          tElement.addClass(tAttrs.uibModalAnimationClass);\n\t        }\n\t      }\n\t    };\n\t  })\n\t\n\t  .directive('uibModalTransclude', function() {\n\t    return {\n\t      link: function(scope, element, attrs, controller, transclude) {\n\t        transclude(scope.$parent, function(clone) {\n\t          element.empty();\n\t          element.append(clone);\n\t        });\n\t      }\n\t    };\n\t  })\n\t\n\t  .factory('$uibModalStack', ['$animate', '$animateCss', '$document',\n\t    '$compile', '$rootScope', '$q', '$$multiMap', '$$stackedMap', '$uibPosition',\n\t    function($animate, $animateCss, $document, $compile, $rootScope, $q, $$multiMap, $$stackedMap, $uibPosition) {\n\t      var OPENED_MODAL_CLASS = 'modal-open';\n\t\n\t      var backdropDomEl, backdropScope;\n\t      var openedWindows = $$stackedMap.createNew();\n\t      var openedClasses = $$multiMap.createNew();\n\t      var $modalStack = {\n\t        NOW_CLOSING_EVENT: 'modal.stack.now-closing'\n\t      };\n\t      var topModalIndex = 0;\n\t      var previousTopOpenedModal = null;\n\t\n\t      //Modal focus behavior\n\t      var tabableSelector = 'a[href], area[href], input:not([disabled]), ' +\n\t        'button:not([disabled]),select:not([disabled]), textarea:not([disabled]), ' +\n\t        'iframe, object, embed, *[tabindex], *[contenteditable=true]';\n\t      var scrollbarPadding;\n\t\n\t      function isVisible(element) {\n\t        return !!(element.offsetWidth ||\n\t          element.offsetHeight ||\n\t          element.getClientRects().length);\n\t      }\n\t\n\t      function backdropIndex() {\n\t        var topBackdropIndex = -1;\n\t        var opened = openedWindows.keys();\n\t        for (var i = 0; i < opened.length; i++) {\n\t          if (openedWindows.get(opened[i]).value.backdrop) {\n\t            topBackdropIndex = i;\n\t          }\n\t        }\n\t\n\t        // If any backdrop exist, ensure that it's index is always\n\t        // right below the top modal\n\t        if (topBackdropIndex > -1 && topBackdropIndex < topModalIndex) {\n\t          topBackdropIndex = topModalIndex;\n\t        }\n\t        return topBackdropIndex;\n\t      }\n\t\n\t      $rootScope.$watch(backdropIndex, function(newBackdropIndex) {\n\t        if (backdropScope) {\n\t          backdropScope.index = newBackdropIndex;\n\t        }\n\t      });\n\t\n\t      function removeModalWindow(modalInstance, elementToReceiveFocus) {\n\t        var modalWindow = openedWindows.get(modalInstance).value;\n\t        var appendToElement = modalWindow.appendTo;\n\t\n\t        //clean up the stack\n\t        openedWindows.remove(modalInstance);\n\t        previousTopOpenedModal = openedWindows.top();\n\t        if (previousTopOpenedModal) {\n\t          topModalIndex = parseInt(previousTopOpenedModal.value.modalDomEl.attr('index'), 10);\n\t        }\n\t\n\t        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function() {\n\t          var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;\n\t          openedClasses.remove(modalBodyClass, modalInstance);\n\t          var areAnyOpen = openedClasses.hasKey(modalBodyClass);\n\t          appendToElement.toggleClass(modalBodyClass, areAnyOpen);\n\t          if (!areAnyOpen && scrollbarPadding && scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {\n\t            if (scrollbarPadding.originalRight) {\n\t              appendToElement.css({paddingRight: scrollbarPadding.originalRight + 'px'});\n\t            } else {\n\t              appendToElement.css({paddingRight: ''});\n\t            }\n\t            scrollbarPadding = null;\n\t          }\n\t          toggleTopWindowClass(true);\n\t        }, modalWindow.closedDeferred);\n\t        checkRemoveBackdrop();\n\t\n\t        //move focus to specified element if available, or else to body\n\t        if (elementToReceiveFocus && elementToReceiveFocus.focus) {\n\t          elementToReceiveFocus.focus();\n\t        } else if (appendToElement.focus) {\n\t          appendToElement.focus();\n\t        }\n\t      }\n\t\n\t      // Add or remove \"windowTopClass\" from the top window in the stack\n\t      function toggleTopWindowClass(toggleSwitch) {\n\t        var modalWindow;\n\t\n\t        if (openedWindows.length() > 0) {\n\t          modalWindow = openedWindows.top().value;\n\t          modalWindow.modalDomEl.toggleClass(modalWindow.windowTopClass || '', toggleSwitch);\n\t        }\n\t      }\n\t\n\t      function checkRemoveBackdrop() {\n\t        //remove backdrop if no longer needed\n\t        if (backdropDomEl && backdropIndex() === -1) {\n\t          var backdropScopeRef = backdropScope;\n\t          removeAfterAnimate(backdropDomEl, backdropScope, function() {\n\t            backdropScopeRef = null;\n\t          });\n\t          backdropDomEl = undefined;\n\t          backdropScope = undefined;\n\t        }\n\t      }\n\t\n\t      function removeAfterAnimate(domEl, scope, done, closedDeferred) {\n\t        var asyncDeferred;\n\t        var asyncPromise = null;\n\t        var setIsAsync = function() {\n\t          if (!asyncDeferred) {\n\t            asyncDeferred = $q.defer();\n\t            asyncPromise = asyncDeferred.promise;\n\t          }\n\t\n\t          return function asyncDone() {\n\t            asyncDeferred.resolve();\n\t          };\n\t        };\n\t        scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);\n\t\n\t        // Note that it's intentional that asyncPromise might be null.\n\t        // That's when setIsAsync has not been called during the\n\t        // NOW_CLOSING_EVENT broadcast.\n\t        return $q.when(asyncPromise).then(afterAnimating);\n\t\n\t        function afterAnimating() {\n\t          if (afterAnimating.done) {\n\t            return;\n\t          }\n\t          afterAnimating.done = true;\n\t\n\t          $animate.leave(domEl).then(function() {\n\t            domEl.remove();\n\t            if (closedDeferred) {\n\t              closedDeferred.resolve();\n\t            }\n\t          });\n\t\n\t          scope.$destroy();\n\t          if (done) {\n\t            done();\n\t          }\n\t        }\n\t      }\n\t\n\t      $document.on('keydown', keydownListener);\n\t\n\t      $rootScope.$on('$destroy', function() {\n\t        $document.off('keydown', keydownListener);\n\t      });\n\t\n\t      function keydownListener(evt) {\n\t        if (evt.isDefaultPrevented()) {\n\t          return evt;\n\t        }\n\t\n\t        var modal = openedWindows.top();\n\t        if (modal) {\n\t          switch (evt.which) {\n\t            case 27: {\n\t              if (modal.value.keyboard) {\n\t                evt.preventDefault();\n\t                $rootScope.$apply(function() {\n\t                  $modalStack.dismiss(modal.key, 'escape key press');\n\t                });\n\t              }\n\t              break;\n\t            }\n\t            case 9: {\n\t              var list = $modalStack.loadFocusElementList(modal);\n\t              var focusChanged = false;\n\t              if (evt.shiftKey) {\n\t                if ($modalStack.isFocusInFirstItem(evt, list) || $modalStack.isModalFocused(evt, modal)) {\n\t                  focusChanged = $modalStack.focusLastFocusableElement(list);\n\t                }\n\t              } else {\n\t                if ($modalStack.isFocusInLastItem(evt, list)) {\n\t                  focusChanged = $modalStack.focusFirstFocusableElement(list);\n\t                }\n\t              }\n\t\n\t              if (focusChanged) {\n\t                evt.preventDefault();\n\t                evt.stopPropagation();\n\t              }\n\t\n\t              break;\n\t            }\n\t          }\n\t        }\n\t      }\n\t\n\t      $modalStack.open = function(modalInstance, modal) {\n\t        var modalOpener = $document[0].activeElement,\n\t          modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;\n\t\n\t        toggleTopWindowClass(false);\n\t\n\t        // Store the current top first, to determine what index we ought to use\n\t        // for the current top modal\n\t        previousTopOpenedModal = openedWindows.top();\n\t\n\t        openedWindows.add(modalInstance, {\n\t          deferred: modal.deferred,\n\t          renderDeferred: modal.renderDeferred,\n\t          closedDeferred: modal.closedDeferred,\n\t          modalScope: modal.scope,\n\t          backdrop: modal.backdrop,\n\t          keyboard: modal.keyboard,\n\t          openedClass: modal.openedClass,\n\t          windowTopClass: modal.windowTopClass,\n\t          animation: modal.animation,\n\t          appendTo: modal.appendTo\n\t        });\n\t\n\t        openedClasses.put(modalBodyClass, modalInstance);\n\t\n\t        var appendToElement = modal.appendTo,\n\t            currBackdropIndex = backdropIndex();\n\t\n\t        if (!appendToElement.length) {\n\t          throw new Error('appendTo element not found. Make sure that the element passed is in DOM.');\n\t        }\n\t\n\t        if (currBackdropIndex >= 0 && !backdropDomEl) {\n\t          backdropScope = $rootScope.$new(true);\n\t          backdropScope.modalOptions = modal;\n\t          backdropScope.index = currBackdropIndex;\n\t          backdropDomEl = angular.element('<div uib-modal-backdrop=\"modal-backdrop\"></div>');\n\t          backdropDomEl.attr('backdrop-class', modal.backdropClass);\n\t          if (modal.animation) {\n\t            backdropDomEl.attr('modal-animation', 'true');\n\t          }\n\t          $compile(backdropDomEl)(backdropScope);\n\t          $animate.enter(backdropDomEl, appendToElement);\n\t          scrollbarPadding = $uibPosition.scrollbarPadding(appendToElement);\n\t          if (scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {\n\t            appendToElement.css({paddingRight: scrollbarPadding.right + 'px'});\n\t          }\n\t        }\n\t\n\t        // Set the top modal index based on the index of the previous top modal\n\t        topModalIndex = previousTopOpenedModal ? parseInt(previousTopOpenedModal.value.modalDomEl.attr('index'), 10) + 1 : 0;\n\t        var angularDomEl = angular.element('<div uib-modal-window=\"modal-window\"></div>');\n\t        angularDomEl.attr({\n\t          'template-url': modal.windowTemplateUrl,\n\t          'window-class': modal.windowClass,\n\t          'window-top-class': modal.windowTopClass,\n\t          'size': modal.size,\n\t          'index': topModalIndex,\n\t          'animate': 'animate'\n\t        }).html(modal.content);\n\t        if (modal.animation) {\n\t          angularDomEl.attr('modal-animation', 'true');\n\t        }\n\t\n\t        appendToElement.addClass(modalBodyClass);\n\t        $animate.enter($compile(angularDomEl)(modal.scope), appendToElement);\n\t\n\t        openedWindows.top().value.modalDomEl = angularDomEl;\n\t        openedWindows.top().value.modalOpener = modalOpener;\n\t      };\n\t\n\t      function broadcastClosing(modalWindow, resultOrReason, closing) {\n\t        return !modalWindow.value.modalScope.$broadcast('modal.closing', resultOrReason, closing).defaultPrevented;\n\t      }\n\t\n\t      $modalStack.close = function(modalInstance, result) {\n\t        var modalWindow = openedWindows.get(modalInstance);\n\t        if (modalWindow && broadcastClosing(modalWindow, result, true)) {\n\t          modalWindow.value.modalScope.$$uibDestructionScheduled = true;\n\t          modalWindow.value.deferred.resolve(result);\n\t          removeModalWindow(modalInstance, modalWindow.value.modalOpener);\n\t          return true;\n\t        }\n\t        return !modalWindow;\n\t      };\n\t\n\t      $modalStack.dismiss = function(modalInstance, reason) {\n\t        var modalWindow = openedWindows.get(modalInstance);\n\t        if (modalWindow && broadcastClosing(modalWindow, reason, false)) {\n\t          modalWindow.value.modalScope.$$uibDestructionScheduled = true;\n\t          modalWindow.value.deferred.reject(reason);\n\t          removeModalWindow(modalInstance, modalWindow.value.modalOpener);\n\t          return true;\n\t        }\n\t        return !modalWindow;\n\t      };\n\t\n\t      $modalStack.dismissAll = function(reason) {\n\t        var topModal = this.getTop();\n\t        while (topModal && this.dismiss(topModal.key, reason)) {\n\t          topModal = this.getTop();\n\t        }\n\t      };\n\t\n\t      $modalStack.getTop = function() {\n\t        return openedWindows.top();\n\t      };\n\t\n\t      $modalStack.modalRendered = function(modalInstance) {\n\t        var modalWindow = openedWindows.get(modalInstance);\n\t        if (modalWindow) {\n\t          modalWindow.value.renderDeferred.resolve();\n\t        }\n\t      };\n\t\n\t      $modalStack.focusFirstFocusableElement = function(list) {\n\t        if (list.length > 0) {\n\t          list[0].focus();\n\t          return true;\n\t        }\n\t        return false;\n\t      };\n\t\n\t      $modalStack.focusLastFocusableElement = function(list) {\n\t        if (list.length > 0) {\n\t          list[list.length - 1].focus();\n\t          return true;\n\t        }\n\t        return false;\n\t      };\n\t\n\t      $modalStack.isModalFocused = function(evt, modalWindow) {\n\t        if (evt && modalWindow) {\n\t          var modalDomEl = modalWindow.value.modalDomEl;\n\t          if (modalDomEl && modalDomEl.length) {\n\t            return (evt.target || evt.srcElement) === modalDomEl[0];\n\t          }\n\t        }\n\t        return false;\n\t      };\n\t\n\t      $modalStack.isFocusInFirstItem = function(evt, list) {\n\t        if (list.length > 0) {\n\t          return (evt.target || evt.srcElement) === list[0];\n\t        }\n\t        return false;\n\t      };\n\t\n\t      $modalStack.isFocusInLastItem = function(evt, list) {\n\t        if (list.length > 0) {\n\t          return (evt.target || evt.srcElement) === list[list.length - 1];\n\t        }\n\t        return false;\n\t      };\n\t\n\t      $modalStack.loadFocusElementList = function(modalWindow) {\n\t        if (modalWindow) {\n\t          var modalDomE1 = modalWindow.value.modalDomEl;\n\t          if (modalDomE1 && modalDomE1.length) {\n\t            var elements = modalDomE1[0].querySelectorAll(tabableSelector);\n\t            return elements ?\n\t              Array.prototype.filter.call(elements, function(element) {\n\t                return isVisible(element);\n\t              }) : elements;\n\t          }\n\t        }\n\t      };\n\t\n\t      return $modalStack;\n\t    }])\n\t\n\t  .provider('$uibModal', function() {\n\t    var $modalProvider = {\n\t      options: {\n\t        animation: true,\n\t        backdrop: true, //can also be false or 'static'\n\t        keyboard: true\n\t      },\n\t      $get: ['$rootScope', '$q', '$document', '$templateRequest', '$controller', '$uibResolve', '$uibModalStack',\n\t        function ($rootScope, $q, $document, $templateRequest, $controller, $uibResolve, $modalStack) {\n\t          var $modal = {};\n\t\n\t          function getTemplatePromise(options) {\n\t            return options.template ? $q.when(options.template) :\n\t              $templateRequest(angular.isFunction(options.templateUrl) ?\n\t                options.templateUrl() : options.templateUrl);\n\t          }\n\t\n\t          var promiseChain = null;\n\t          $modal.getPromiseChain = function() {\n\t            return promiseChain;\n\t          };\n\t\n\t          $modal.open = function(modalOptions) {\n\t            var modalResultDeferred = $q.defer();\n\t            var modalOpenedDeferred = $q.defer();\n\t            var modalClosedDeferred = $q.defer();\n\t            var modalRenderDeferred = $q.defer();\n\t\n\t            //prepare an instance of a modal to be injected into controllers and returned to a caller\n\t            var modalInstance = {\n\t              result: modalResultDeferred.promise,\n\t              opened: modalOpenedDeferred.promise,\n\t              closed: modalClosedDeferred.promise,\n\t              rendered: modalRenderDeferred.promise,\n\t              close: function (result) {\n\t                return $modalStack.close(modalInstance, result);\n\t              },\n\t              dismiss: function (reason) {\n\t                return $modalStack.dismiss(modalInstance, reason);\n\t              }\n\t            };\n\t\n\t            //merge and clean up options\n\t            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);\n\t            modalOptions.resolve = modalOptions.resolve || {};\n\t            modalOptions.appendTo = modalOptions.appendTo || $document.find('body').eq(0);\n\t\n\t            //verify options\n\t            if (!modalOptions.template && !modalOptions.templateUrl) {\n\t              throw new Error('One of template or templateUrl options is required.');\n\t            }\n\t\n\t            var templateAndResolvePromise =\n\t              $q.all([getTemplatePromise(modalOptions), $uibResolve.resolve(modalOptions.resolve, {}, null, null)]);\n\t\n\t            function resolveWithTemplate() {\n\t              return templateAndResolvePromise;\n\t            }\n\t\n\t            // Wait for the resolution of the existing promise chain.\n\t            // Then switch to our own combined promise dependency (regardless of how the previous modal fared).\n\t            // Then add to $modalStack and resolve opened.\n\t            // Finally clean up the chain variable if no subsequent modal has overwritten it.\n\t            var samePromise;\n\t            samePromise = promiseChain = $q.all([promiseChain])\n\t              .then(resolveWithTemplate, resolveWithTemplate)\n\t              .then(function resolveSuccess(tplAndVars) {\n\t                var providedScope = modalOptions.scope || $rootScope;\n\t\n\t                var modalScope = providedScope.$new();\n\t                modalScope.$close = modalInstance.close;\n\t                modalScope.$dismiss = modalInstance.dismiss;\n\t\n\t                modalScope.$on('$destroy', function() {\n\t                  if (!modalScope.$$uibDestructionScheduled) {\n\t                    modalScope.$dismiss('$uibUnscheduledDestruction');\n\t                  }\n\t                });\n\t\n\t                var ctrlInstance, ctrlInstantiate, ctrlLocals = {};\n\t\n\t                //controllers\n\t                if (modalOptions.controller) {\n\t                  ctrlLocals.$scope = modalScope;\n\t                  ctrlLocals.$scope.$resolve = {};\n\t                  ctrlLocals.$uibModalInstance = modalInstance;\n\t                  angular.forEach(tplAndVars[1], function(value, key) {\n\t                    ctrlLocals[key] = value;\n\t                    ctrlLocals.$scope.$resolve[key] = value;\n\t                  });\n\t\n\t                  // the third param will make the controller instantiate later,private api\n\t                  // @see https://github.com/angular/angular.js/blob/master/src/ng/controller.js#L126\n\t                  ctrlInstantiate = $controller(modalOptions.controller, ctrlLocals, true, modalOptions.controllerAs);\n\t                  if (modalOptions.controllerAs && modalOptions.bindToController) {\n\t                    ctrlInstance = ctrlInstantiate.instance;\n\t                    ctrlInstance.$close = modalScope.$close;\n\t                    ctrlInstance.$dismiss = modalScope.$dismiss;\n\t                    angular.extend(ctrlInstance, {\n\t                      $resolve: ctrlLocals.$scope.$resolve\n\t                    }, providedScope);\n\t                  }\n\t\n\t                  ctrlInstance = ctrlInstantiate();\n\t\n\t                  if (angular.isFunction(ctrlInstance.$onInit)) {\n\t                    ctrlInstance.$onInit();\n\t                  }\n\t                }\n\t\n\t                $modalStack.open(modalInstance, {\n\t                  scope: modalScope,\n\t                  deferred: modalResultDeferred,\n\t                  renderDeferred: modalRenderDeferred,\n\t                  closedDeferred: modalClosedDeferred,\n\t                  content: tplAndVars[0],\n\t                  animation: modalOptions.animation,\n\t                  backdrop: modalOptions.backdrop,\n\t                  keyboard: modalOptions.keyboard,\n\t                  backdropClass: modalOptions.backdropClass,\n\t                  windowTopClass: modalOptions.windowTopClass,\n\t                  windowClass: modalOptions.windowClass,\n\t                  windowTemplateUrl: modalOptions.windowTemplateUrl,\n\t                  size: modalOptions.size,\n\t                  openedClass: modalOptions.openedClass,\n\t                  appendTo: modalOptions.appendTo\n\t                });\n\t                modalOpenedDeferred.resolve(true);\n\t\n\t            }, function resolveError(reason) {\n\t              modalOpenedDeferred.reject(reason);\n\t              modalResultDeferred.reject(reason);\n\t            })['finally'](function() {\n\t              if (promiseChain === samePromise) {\n\t                promiseChain = null;\n\t              }\n\t            });\n\t\n\t            return modalInstance;\n\t          };\n\t\n\t          return $modal;\n\t        }\n\t      ]\n\t    };\n\t\n\t    return $modalProvider;\n\t  });\n\t\n\tangular.module('ui.bootstrap.paging', [])\n\t/**\n\t * Helper internal service for generating common controller code between the\n\t * pager and pagination components\n\t */\n\t.factory('uibPaging', ['$parse', function($parse) {\n\t  return {\n\t    create: function(ctrl, $scope, $attrs) {\n\t      ctrl.setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;\n\t      ctrl.ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl\n\t      ctrl._watchers = [];\n\t\n\t      ctrl.init = function(ngModelCtrl, config) {\n\t        ctrl.ngModelCtrl = ngModelCtrl;\n\t        ctrl.config = config;\n\t\n\t        ngModelCtrl.$render = function() {\n\t          ctrl.render();\n\t        };\n\t\n\t        if ($attrs.itemsPerPage) {\n\t          ctrl._watchers.push($scope.$parent.$watch($attrs.itemsPerPage, function(value) {\n\t            ctrl.itemsPerPage = parseInt(value, 10);\n\t            $scope.totalPages = ctrl.calculateTotalPages();\n\t            ctrl.updatePage();\n\t          }));\n\t        } else {\n\t          ctrl.itemsPerPage = config.itemsPerPage;\n\t        }\n\t\n\t        $scope.$watch('totalItems', function(newTotal, oldTotal) {\n\t          if (angular.isDefined(newTotal) || newTotal !== oldTotal) {\n\t            $scope.totalPages = ctrl.calculateTotalPages();\n\t            ctrl.updatePage();\n\t          }\n\t        });\n\t      };\n\t\n\t      ctrl.calculateTotalPages = function() {\n\t        var totalPages = ctrl.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / ctrl.itemsPerPage);\n\t        return Math.max(totalPages || 0, 1);\n\t      };\n\t\n\t      ctrl.render = function() {\n\t        $scope.page = parseInt(ctrl.ngModelCtrl.$viewValue, 10) || 1;\n\t      };\n\t\n\t      $scope.selectPage = function(page, evt) {\n\t        if (evt) {\n\t          evt.preventDefault();\n\t        }\n\t\n\t        var clickAllowed = !$scope.ngDisabled || !evt;\n\t        if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {\n\t          if (evt && evt.target) {\n\t            evt.target.blur();\n\t          }\n\t          ctrl.ngModelCtrl.$setViewValue(page);\n\t          ctrl.ngModelCtrl.$render();\n\t        }\n\t      };\n\t\n\t      $scope.getText = function(key) {\n\t        return $scope[key + 'Text'] || ctrl.config[key + 'Text'];\n\t      };\n\t\n\t      $scope.noPrevious = function() {\n\t        return $scope.page === 1;\n\t      };\n\t\n\t      $scope.noNext = function() {\n\t        return $scope.page === $scope.totalPages;\n\t      };\n\t\n\t      ctrl.updatePage = function() {\n\t        ctrl.setNumPages($scope.$parent, $scope.totalPages); // Readonly variable\n\t\n\t        if ($scope.page > $scope.totalPages) {\n\t          $scope.selectPage($scope.totalPages);\n\t        } else {\n\t          ctrl.ngModelCtrl.$render();\n\t        }\n\t      };\n\t\n\t      $scope.$on('$destroy', function() {\n\t        while (ctrl._watchers.length) {\n\t          ctrl._watchers.shift()();\n\t        }\n\t      });\n\t    }\n\t  };\n\t}]);\n\t\n\tangular.module('ui.bootstrap.pager', ['ui.bootstrap.paging'])\n\t\n\t.controller('UibPagerController', ['$scope', '$attrs', 'uibPaging', 'uibPagerConfig', function($scope, $attrs, uibPaging, uibPagerConfig) {\n\t  $scope.align = angular.isDefined($attrs.align) ? $scope.$parent.$eval($attrs.align) : uibPagerConfig.align;\n\t\n\t  uibPaging.create(this, $scope, $attrs);\n\t}])\n\t\n\t.constant('uibPagerConfig', {\n\t  itemsPerPage: 10,\n\t  previousText: ' Previous',\n\t  nextText: 'Next ',\n\t  align: true\n\t})\n\t\n\t.directive('uibPager', ['uibPagerConfig', function(uibPagerConfig) {\n\t  return {\n\t    scope: {\n\t      totalItems: '=',\n\t      previousText: '@',\n\t      nextText: '@',\n\t      ngDisabled: '='\n\t    },\n\t    require: ['uibPager', '?ngModel'],\n\t    controller: 'UibPagerController',\n\t    controllerAs: 'pager',\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'uib/template/pager/pager.html';\n\t    },\n\t    replace: true,\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      if (!ngModelCtrl) {\n\t        return; // do nothing if no ng-model\n\t      }\n\t\n\t      paginationCtrl.init(ngModelCtrl, uibPagerConfig);\n\t    }\n\t  };\n\t}]);\n\t\n\tangular.module('ui.bootstrap.pagination', ['ui.bootstrap.paging'])\n\t.controller('UibPaginationController', ['$scope', '$attrs', '$parse', 'uibPaging', 'uibPaginationConfig', function($scope, $attrs, $parse, uibPaging, uibPaginationConfig) {\n\t  var ctrl = this;\n\t  // Setup configuration parameters\n\t  var maxSize = angular.isDefined($attrs.maxSize) ? $scope.$parent.$eval($attrs.maxSize) : uibPaginationConfig.maxSize,\n\t    rotate = angular.isDefined($attrs.rotate) ? $scope.$parent.$eval($attrs.rotate) : uibPaginationConfig.rotate,\n\t    forceEllipses = angular.isDefined($attrs.forceEllipses) ? $scope.$parent.$eval($attrs.forceEllipses) : uibPaginationConfig.forceEllipses,\n\t    boundaryLinkNumbers = angular.isDefined($attrs.boundaryLinkNumbers) ? $scope.$parent.$eval($attrs.boundaryLinkNumbers) : uibPaginationConfig.boundaryLinkNumbers,\n\t    pageLabel = angular.isDefined($attrs.pageLabel) ? function(idx) { return $scope.$parent.$eval($attrs.pageLabel, {$page: idx}); } : angular.identity;\n\t  $scope.boundaryLinks = angular.isDefined($attrs.boundaryLinks) ? $scope.$parent.$eval($attrs.boundaryLinks) : uibPaginationConfig.boundaryLinks;\n\t  $scope.directionLinks = angular.isDefined($attrs.directionLinks) ? $scope.$parent.$eval($attrs.directionLinks) : uibPaginationConfig.directionLinks;\n\t\n\t  uibPaging.create(this, $scope, $attrs);\n\t\n\t  if ($attrs.maxSize) {\n\t    ctrl._watchers.push($scope.$parent.$watch($parse($attrs.maxSize), function(value) {\n\t      maxSize = parseInt(value, 10);\n\t      ctrl.render();\n\t    }));\n\t  }\n\t\n\t  // Create page object used in template\n\t  function makePage(number, text, isActive) {\n\t    return {\n\t      number: number,\n\t      text: text,\n\t      active: isActive\n\t    };\n\t  }\n\t\n\t  function getPages(currentPage, totalPages) {\n\t    var pages = [];\n\t\n\t    // Default page limits\n\t    var startPage = 1, endPage = totalPages;\n\t    var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;\n\t\n\t    // recompute if maxSize\n\t    if (isMaxSized) {\n\t      if (rotate) {\n\t        // Current page is displayed in the middle of the visible ones\n\t        startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1);\n\t        endPage = startPage + maxSize - 1;\n\t\n\t        // Adjust if limit is exceeded\n\t        if (endPage > totalPages) {\n\t          endPage = totalPages;\n\t          startPage = endPage - maxSize + 1;\n\t        }\n\t      } else {\n\t        // Visible pages are paginated with maxSize\n\t        startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1;\n\t\n\t        // Adjust last page if limit is exceeded\n\t        endPage = Math.min(startPage + maxSize - 1, totalPages);\n\t      }\n\t    }\n\t\n\t    // Add page number links\n\t    for (var number = startPage; number <= endPage; number++) {\n\t      var page = makePage(number, pageLabel(number), number === currentPage);\n\t      pages.push(page);\n\t    }\n\t\n\t    // Add links to move between page sets\n\t    if (isMaxSized && maxSize > 0 && (!rotate || forceEllipses || boundaryLinkNumbers)) {\n\t      if (startPage > 1) {\n\t        if (!boundaryLinkNumbers || startPage > 3) { //need ellipsis for all options unless range is too close to beginning\n\t        var previousPageSet = makePage(startPage - 1, '...', false);\n\t        pages.unshift(previousPageSet);\n\t      }\n\t        if (boundaryLinkNumbers) {\n\t          if (startPage === 3) { //need to replace ellipsis when the buttons would be sequential\n\t            var secondPageLink = makePage(2, '2', false);\n\t            pages.unshift(secondPageLink);\n\t          }\n\t          //add the first page\n\t          var firstPageLink = makePage(1, '1', false);\n\t          pages.unshift(firstPageLink);\n\t        }\n\t      }\n\t\n\t      if (endPage < totalPages) {\n\t        if (!boundaryLinkNumbers || endPage < totalPages - 2) { //need ellipsis for all options unless range is too close to end\n\t        var nextPageSet = makePage(endPage + 1, '...', false);\n\t        pages.push(nextPageSet);\n\t      }\n\t        if (boundaryLinkNumbers) {\n\t          if (endPage === totalPages - 2) { //need to replace ellipsis when the buttons would be sequential\n\t            var secondToLastPageLink = makePage(totalPages - 1, totalPages - 1, false);\n\t            pages.push(secondToLastPageLink);\n\t          }\n\t          //add the last page\n\t          var lastPageLink = makePage(totalPages, totalPages, false);\n\t          pages.push(lastPageLink);\n\t        }\n\t      }\n\t    }\n\t    return pages;\n\t  }\n\t\n\t  var originalRender = this.render;\n\t  this.render = function() {\n\t    originalRender();\n\t    if ($scope.page > 0 && $scope.page <= $scope.totalPages) {\n\t      $scope.pages = getPages($scope.page, $scope.totalPages);\n\t    }\n\t  };\n\t}])\n\t\n\t.constant('uibPaginationConfig', {\n\t  itemsPerPage: 10,\n\t  boundaryLinks: false,\n\t  boundaryLinkNumbers: false,\n\t  directionLinks: true,\n\t  firstText: 'First',\n\t  previousText: 'Previous',\n\t  nextText: 'Next',\n\t  lastText: 'Last',\n\t  rotate: true,\n\t  forceEllipses: false\n\t})\n\t\n\t.directive('uibPagination', ['$parse', 'uibPaginationConfig', function($parse, uibPaginationConfig) {\n\t  return {\n\t    scope: {\n\t      totalItems: '=',\n\t      firstText: '@',\n\t      previousText: '@',\n\t      nextText: '@',\n\t      lastText: '@',\n\t      ngDisabled:'='\n\t    },\n\t    require: ['uibPagination', '?ngModel'],\n\t    controller: 'UibPaginationController',\n\t    controllerAs: 'pagination',\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'uib/template/pagination/pagination.html';\n\t    },\n\t    replace: true,\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      if (!ngModelCtrl) {\n\t         return; // do nothing if no ng-model\n\t      }\n\t\n\t      paginationCtrl.init(ngModelCtrl, uibPaginationConfig);\n\t    }\n\t  };\n\t}]);\n\t\n\t/**\n\t * The following features are still outstanding: animation as a\n\t * function, placement as a function, inside, support for more triggers than\n\t * just mouse enter/leave, html tooltips, and selector delegation.\n\t */\n\tangular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.stackedMap'])\n\t\n\t/**\n\t * The $tooltip service creates tooltip- and popover-like directives as well as\n\t * houses global options for them.\n\t */\n\t.provider('$uibTooltip', function() {\n\t  // The default options tooltip and popover.\n\t  var defaultOptions = {\n\t    placement: 'top',\n\t    placementClassPrefix: '',\n\t    animation: true,\n\t    popupDelay: 0,\n\t    popupCloseDelay: 0,\n\t    useContentExp: false\n\t  };\n\t\n\t  // Default hide triggers for each show trigger\n\t  var triggerMap = {\n\t    'mouseenter': 'mouseleave',\n\t    'click': 'click',\n\t    'outsideClick': 'outsideClick',\n\t    'focus': 'blur',\n\t    'none': ''\n\t  };\n\t\n\t  // The options specified to the provider globally.\n\t  var globalOptions = {};\n\t\n\t  /**\n\t   * `options({})` allows global configuration of all tooltips in the\n\t   * application.\n\t   *\n\t   *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {\n\t   *     // place tooltips left instead of top by default\n\t   *     $tooltipProvider.options( { placement: 'left' } );\n\t   *   });\n\t   */\n\t\tthis.options = function(value) {\n\t\t\tangular.extend(globalOptions, value);\n\t\t};\n\t\n\t  /**\n\t   * This allows you to extend the set of trigger mappings available. E.g.:\n\t   *\n\t   *   $tooltipProvider.setTriggers( { 'openTrigger': 'closeTrigger' } );\n\t   */\n\t  this.setTriggers = function setTriggers(triggers) {\n\t    angular.extend(triggerMap, triggers);\n\t  };\n\t\n\t  /**\n\t   * This is a helper function for translating camel-case to snake_case.\n\t   */\n\t  function snake_case(name) {\n\t    var regexp = /[A-Z]/g;\n\t    var separator = '-';\n\t    return name.replace(regexp, function(letter, pos) {\n\t      return (pos ? separator : '') + letter.toLowerCase();\n\t    });\n\t  }\n\t\n\t  /**\n\t   * Returns the actual instance of the $tooltip service.\n\t   * TODO support multiple triggers\n\t   */\n\t  this.$get = ['$window', '$compile', '$timeout', '$document', '$uibPosition', '$interpolate', '$rootScope', '$parse', '$$stackedMap', function($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse, $$stackedMap) {\n\t    var openedTooltips = $$stackedMap.createNew();\n\t    $document.on('keypress', keypressListener);\n\t\n\t    $rootScope.$on('$destroy', function() {\n\t      $document.off('keypress', keypressListener);\n\t    });\n\t\n\t    function keypressListener(e) {\n\t      if (e.which === 27) {\n\t        var last = openedTooltips.top();\n\t        if (last) {\n\t          last.value.close();\n\t          openedTooltips.removeTop();\n\t          last = null;\n\t        }\n\t      }\n\t    }\n\t\n\t    return function $tooltip(ttType, prefix, defaultTriggerShow, options) {\n\t      options = angular.extend({}, defaultOptions, globalOptions, options);\n\t\n\t      /**\n\t       * Returns an object of show and hide triggers.\n\t       *\n\t       * If a trigger is supplied,\n\t       * it is used to show the tooltip; otherwise, it will use the `trigger`\n\t       * option passed to the `$tooltipProvider.options` method; else it will\n\t       * default to the trigger supplied to this directive factory.\n\t       *\n\t       * The hide trigger is based on the show trigger. If the `trigger` option\n\t       * was passed to the `$tooltipProvider.options` method, it will use the\n\t       * mapped trigger from `triggerMap` or the passed trigger if the map is\n\t       * undefined; otherwise, it uses the `triggerMap` value of the show\n\t       * trigger; else it will just use the show trigger.\n\t       */\n\t      function getTriggers(trigger) {\n\t        var show = (trigger || options.trigger || defaultTriggerShow).split(' ');\n\t        var hide = show.map(function(trigger) {\n\t          return triggerMap[trigger] || trigger;\n\t        });\n\t        return {\n\t          show: show,\n\t          hide: hide\n\t        };\n\t      }\n\t\n\t      var directiveName = snake_case(ttType);\n\t\n\t      var startSym = $interpolate.startSymbol();\n\t      var endSym = $interpolate.endSymbol();\n\t      var template =\n\t        '<div '+ directiveName + '-popup ' +\n\t          'uib-title=\"' + startSym + 'title' + endSym + '\" ' +\n\t          (options.useContentExp ?\n\t            'content-exp=\"contentExp()\" ' :\n\t            'content=\"' + startSym + 'content' + endSym + '\" ') +\n\t          'placement=\"' + startSym + 'placement' + endSym + '\" ' +\n\t          'popup-class=\"' + startSym + 'popupClass' + endSym + '\" ' +\n\t          'animation=\"animation\" ' +\n\t          'is-open=\"isOpen\" ' +\n\t          'origin-scope=\"origScope\" ' +\n\t          'class=\"uib-position-measure\"' +\n\t          '>' +\n\t        '</div>';\n\t\n\t      return {\n\t        compile: function(tElem, tAttrs) {\n\t          var tooltipLinker = $compile(template);\n\t\n\t          return function link(scope, element, attrs, tooltipCtrl) {\n\t            var tooltip;\n\t            var tooltipLinkedScope;\n\t            var transitionTimeout;\n\t            var showTimeout;\n\t            var hideTimeout;\n\t            var positionTimeout;\n\t            var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;\n\t            var triggers = getTriggers(undefined);\n\t            var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);\n\t            var ttScope = scope.$new(true);\n\t            var repositionScheduled = false;\n\t            var isOpenParse = angular.isDefined(attrs[prefix + 'IsOpen']) ? $parse(attrs[prefix + 'IsOpen']) : false;\n\t            var contentParse = options.useContentExp ? $parse(attrs[ttType]) : false;\n\t            var observers = [];\n\t            var lastPlacement;\n\t\n\t            var positionTooltip = function() {\n\t              // check if tooltip exists and is not empty\n\t              if (!tooltip || !tooltip.html()) { return; }\n\t\n\t              if (!positionTimeout) {\n\t                positionTimeout = $timeout(function() {\n\t                  var ttPosition = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);\n\t                  tooltip.css({ top: ttPosition.top + 'px', left: ttPosition.left + 'px' });\n\t\n\t                  if (!tooltip.hasClass(ttPosition.placement.split('-')[0])) {\n\t                    tooltip.removeClass(lastPlacement.split('-')[0]);\n\t                    tooltip.addClass(ttPosition.placement.split('-')[0]);\n\t                  }\n\t\n\t                  if (!tooltip.hasClass(options.placementClassPrefix + ttPosition.placement)) {\n\t                    tooltip.removeClass(options.placementClassPrefix + lastPlacement);\n\t                    tooltip.addClass(options.placementClassPrefix + ttPosition.placement);\n\t                  }\n\t\n\t                  // first time through tt element will have the\n\t                  // uib-position-measure class or if the placement\n\t                  // has changed we need to position the arrow.\n\t                  if (tooltip.hasClass('uib-position-measure')) {\n\t                    $position.positionArrow(tooltip, ttPosition.placement);\n\t                    tooltip.removeClass('uib-position-measure');\n\t                  } else if (lastPlacement !== ttPosition.placement) {\n\t                    $position.positionArrow(tooltip, ttPosition.placement);\n\t                  }\n\t                  lastPlacement = ttPosition.placement;\n\t\n\t                  positionTimeout = null;\n\t                }, 0, false);\n\t              }\n\t            };\n\t\n\t            // Set up the correct scope to allow transclusion later\n\t            ttScope.origScope = scope;\n\t\n\t            // By default, the tooltip is not open.\n\t            // TODO add ability to start tooltip opened\n\t            ttScope.isOpen = false;\n\t            openedTooltips.add(ttScope, {\n\t              close: hide\n\t            });\n\t\n\t            function toggleTooltipBind() {\n\t              if (!ttScope.isOpen) {\n\t                showTooltipBind();\n\t              } else {\n\t                hideTooltipBind();\n\t              }\n\t            }\n\t\n\t            // Show the tooltip with delay if specified, otherwise show it immediately\n\t            function showTooltipBind() {\n\t              if (hasEnableExp && !scope.$eval(attrs[prefix + 'Enable'])) {\n\t                return;\n\t              }\n\t\n\t              cancelHide();\n\t              prepareTooltip();\n\t\n\t              if (ttScope.popupDelay) {\n\t                // Do nothing if the tooltip was already scheduled to pop-up.\n\t                // This happens if show is triggered multiple times before any hide is triggered.\n\t                if (!showTimeout) {\n\t                  showTimeout = $timeout(show, ttScope.popupDelay, false);\n\t                }\n\t              } else {\n\t                show();\n\t              }\n\t            }\n\t\n\t            function hideTooltipBind() {\n\t              cancelShow();\n\t\n\t              if (ttScope.popupCloseDelay) {\n\t                if (!hideTimeout) {\n\t                  hideTimeout = $timeout(hide, ttScope.popupCloseDelay, false);\n\t                }\n\t              } else {\n\t                hide();\n\t              }\n\t            }\n\t\n\t            // Show the tooltip popup element.\n\t            function show() {\n\t              cancelShow();\n\t              cancelHide();\n\t\n\t              // Don't show empty tooltips.\n\t              if (!ttScope.content) {\n\t                return angular.noop;\n\t              }\n\t\n\t              createTooltip();\n\t\n\t              // And show the tooltip.\n\t              ttScope.$evalAsync(function() {\n\t                ttScope.isOpen = true;\n\t                assignIsOpen(true);\n\t                positionTooltip();\n\t              });\n\t            }\n\t\n\t            function cancelShow() {\n\t              if (showTimeout) {\n\t                $timeout.cancel(showTimeout);\n\t                showTimeout = null;\n\t              }\n\t\n\t              if (positionTimeout) {\n\t                $timeout.cancel(positionTimeout);\n\t                positionTimeout = null;\n\t              }\n\t            }\n\t\n\t            // Hide the tooltip popup element.\n\t            function hide() {\n\t              if (!ttScope) {\n\t                return;\n\t              }\n\t\n\t              // First things first: we don't show it anymore.\n\t              ttScope.$evalAsync(function() {\n\t                if (ttScope) {\n\t                  ttScope.isOpen = false;\n\t                  assignIsOpen(false);\n\t                  // And now we remove it from the DOM. However, if we have animation, we\n\t                  // need to wait for it to expire beforehand.\n\t                  // FIXME: this is a placeholder for a port of the transitions library.\n\t                  // The fade transition in TWBS is 150ms.\n\t                  if (ttScope.animation) {\n\t                    if (!transitionTimeout) {\n\t                      transitionTimeout = $timeout(removeTooltip, 150, false);\n\t                    }\n\t                  } else {\n\t                    removeTooltip();\n\t                  }\n\t                }\n\t              });\n\t            }\n\t\n\t            function cancelHide() {\n\t              if (hideTimeout) {\n\t                $timeout.cancel(hideTimeout);\n\t                hideTimeout = null;\n\t              }\n\t\n\t              if (transitionTimeout) {\n\t                $timeout.cancel(transitionTimeout);\n\t                transitionTimeout = null;\n\t              }\n\t            }\n\t\n\t            function createTooltip() {\n\t              // There can only be one tooltip element per directive shown at once.\n\t              if (tooltip) {\n\t                return;\n\t              }\n\t\n\t              tooltipLinkedScope = ttScope.$new();\n\t              tooltip = tooltipLinker(tooltipLinkedScope, function(tooltip) {\n\t                if (appendToBody) {\n\t                  $document.find('body').append(tooltip);\n\t                } else {\n\t                  element.after(tooltip);\n\t                }\n\t              });\n\t\n\t              prepObservers();\n\t            }\n\t\n\t            function removeTooltip() {\n\t              cancelShow();\n\t              cancelHide();\n\t              unregisterObservers();\n\t\n\t              if (tooltip) {\n\t                tooltip.remove();\n\t                tooltip = null;\n\t              }\n\t              if (tooltipLinkedScope) {\n\t                tooltipLinkedScope.$destroy();\n\t                tooltipLinkedScope = null;\n\t              }\n\t            }\n\t\n\t            /**\n\t             * Set the initial scope values. Once\n\t             * the tooltip is created, the observers\n\t             * will be added to keep things in sync.\n\t             */\n\t            function prepareTooltip() {\n\t              ttScope.title = attrs[prefix + 'Title'];\n\t              if (contentParse) {\n\t                ttScope.content = contentParse(scope);\n\t              } else {\n\t                ttScope.content = attrs[ttType];\n\t              }\n\t\n\t              ttScope.popupClass = attrs[prefix + 'Class'];\n\t              ttScope.placement = angular.isDefined(attrs[prefix + 'Placement']) ? attrs[prefix + 'Placement'] : options.placement;\n\t              var placement = $position.parsePlacement(ttScope.placement);\n\t              lastPlacement = placement[1] ? placement[0] + '-' + placement[1] : placement[0];\n\t\n\t              var delay = parseInt(attrs[prefix + 'PopupDelay'], 10);\n\t              var closeDelay = parseInt(attrs[prefix + 'PopupCloseDelay'], 10);\n\t              ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;\n\t              ttScope.popupCloseDelay = !isNaN(closeDelay) ? closeDelay : options.popupCloseDelay;\n\t            }\n\t\n\t            function assignIsOpen(isOpen) {\n\t              if (isOpenParse && angular.isFunction(isOpenParse.assign)) {\n\t                isOpenParse.assign(scope, isOpen);\n\t              }\n\t            }\n\t\n\t            ttScope.contentExp = function() {\n\t              return ttScope.content;\n\t            };\n\t\n\t            /**\n\t             * Observe the relevant attributes.\n\t             */\n\t            attrs.$observe('disabled', function(val) {\n\t              if (val) {\n\t                cancelShow();\n\t              }\n\t\n\t              if (val && ttScope.isOpen) {\n\t                hide();\n\t              }\n\t            });\n\t\n\t            if (isOpenParse) {\n\t              scope.$watch(isOpenParse, function(val) {\n\t                if (ttScope && !val === ttScope.isOpen) {\n\t                  toggleTooltipBind();\n\t                }\n\t              });\n\t            }\n\t\n\t            function prepObservers() {\n\t              observers.length = 0;\n\t\n\t              if (contentParse) {\n\t                observers.push(\n\t                  scope.$watch(contentParse, function(val) {\n\t                    ttScope.content = val;\n\t                    if (!val && ttScope.isOpen) {\n\t                      hide();\n\t                    }\n\t                  })\n\t                );\n\t\n\t                observers.push(\n\t                  tooltipLinkedScope.$watch(function() {\n\t                    if (!repositionScheduled) {\n\t                      repositionScheduled = true;\n\t                      tooltipLinkedScope.$$postDigest(function() {\n\t                        repositionScheduled = false;\n\t                        if (ttScope && ttScope.isOpen) {\n\t                          positionTooltip();\n\t                        }\n\t                      });\n\t                    }\n\t                  })\n\t                );\n\t              } else {\n\t                observers.push(\n\t                  attrs.$observe(ttType, function(val) {\n\t                    ttScope.content = val;\n\t                    if (!val && ttScope.isOpen) {\n\t                      hide();\n\t                    } else {\n\t                      positionTooltip();\n\t                    }\n\t                  })\n\t                );\n\t              }\n\t\n\t              observers.push(\n\t                attrs.$observe(prefix + 'Title', function(val) {\n\t                  ttScope.title = val;\n\t                  if (ttScope.isOpen) {\n\t                    positionTooltip();\n\t                  }\n\t                })\n\t              );\n\t\n\t              observers.push(\n\t                attrs.$observe(prefix + 'Placement', function(val) {\n\t                  ttScope.placement = val ? val : options.placement;\n\t                  if (ttScope.isOpen) {\n\t                    positionTooltip();\n\t                  }\n\t                })\n\t              );\n\t            }\n\t\n\t            function unregisterObservers() {\n\t              if (observers.length) {\n\t                angular.forEach(observers, function(observer) {\n\t                  observer();\n\t                });\n\t                observers.length = 0;\n\t              }\n\t            }\n\t\n\t            // hide tooltips/popovers for outsideClick trigger\n\t            function bodyHideTooltipBind(e) {\n\t              if (!ttScope || !ttScope.isOpen || !tooltip) {\n\t                return;\n\t              }\n\t              // make sure the tooltip/popover link or tool tooltip/popover itself were not clicked\n\t              if (!element[0].contains(e.target) && !tooltip[0].contains(e.target)) {\n\t                hideTooltipBind();\n\t              }\n\t            }\n\t\n\t            var unregisterTriggers = function() {\n\t              triggers.show.forEach(function(trigger) {\n\t                if (trigger === 'outsideClick') {\n\t                  element.off('click', toggleTooltipBind);\n\t                } else {\n\t                  element.off(trigger, showTooltipBind);\n\t                  element.off(trigger, toggleTooltipBind);\n\t                }\n\t              });\n\t              triggers.hide.forEach(function(trigger) {\n\t                if (trigger === 'outsideClick') {\n\t                  $document.off('click', bodyHideTooltipBind);\n\t                } else {\n\t                  element.off(trigger, hideTooltipBind);\n\t                }\n\t              });\n\t            };\n\t\n\t            function prepTriggers() {\n\t              var val = attrs[prefix + 'Trigger'];\n\t              unregisterTriggers();\n\t\n\t              triggers = getTriggers(val);\n\t\n\t              if (triggers.show !== 'none') {\n\t                triggers.show.forEach(function(trigger, idx) {\n\t                  if (trigger === 'outsideClick') {\n\t                    element.on('click', toggleTooltipBind);\n\t                    $document.on('click', bodyHideTooltipBind);\n\t                  } else if (trigger === triggers.hide[idx]) {\n\t                    element.on(trigger, toggleTooltipBind);\n\t                  } else if (trigger) {\n\t                    element.on(trigger, showTooltipBind);\n\t                    element.on(triggers.hide[idx], hideTooltipBind);\n\t                  }\n\t\n\t                  element.on('keypress', function(e) {\n\t                    if (e.which === 27) {\n\t                      hideTooltipBind();\n\t                    }\n\t                  });\n\t                });\n\t              }\n\t            }\n\t\n\t            prepTriggers();\n\t\n\t            var animation = scope.$eval(attrs[prefix + 'Animation']);\n\t            ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;\n\t\n\t            var appendToBodyVal;\n\t            var appendKey = prefix + 'AppendToBody';\n\t            if (appendKey in attrs && attrs[appendKey] === undefined) {\n\t              appendToBodyVal = true;\n\t            } else {\n\t              appendToBodyVal = scope.$eval(attrs[appendKey]);\n\t            }\n\t\n\t            appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;\n\t\n\t            // Make sure tooltip is destroyed and removed.\n\t            scope.$on('$destroy', function onDestroyTooltip() {\n\t              unregisterTriggers();\n\t              removeTooltip();\n\t              openedTooltips.remove(ttScope);\n\t              ttScope = null;\n\t            });\n\t          };\n\t        }\n\t      };\n\t    };\n\t  }];\n\t})\n\t\n\t// This is mostly ngInclude code but with a custom scope\n\t.directive('uibTooltipTemplateTransclude', [\n\t         '$animate', '$sce', '$compile', '$templateRequest',\n\tfunction ($animate, $sce, $compile, $templateRequest) {\n\t  return {\n\t    link: function(scope, elem, attrs) {\n\t      var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);\n\t\n\t      var changeCounter = 0,\n\t        currentScope,\n\t        previousElement,\n\t        currentElement;\n\t\n\t      var cleanupLastIncludeContent = function() {\n\t        if (previousElement) {\n\t          previousElement.remove();\n\t          previousElement = null;\n\t        }\n\t\n\t        if (currentScope) {\n\t          currentScope.$destroy();\n\t          currentScope = null;\n\t        }\n\t\n\t        if (currentElement) {\n\t          $animate.leave(currentElement).then(function() {\n\t            previousElement = null;\n\t          });\n\t          previousElement = currentElement;\n\t          currentElement = null;\n\t        }\n\t      };\n\t\n\t      scope.$watch($sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude), function(src) {\n\t        var thisChangeId = ++changeCounter;\n\t\n\t        if (src) {\n\t          //set the 2nd param to true to ignore the template request error so that the inner\n\t          //contents and scope can be cleaned up.\n\t          $templateRequest(src, true).then(function(response) {\n\t            if (thisChangeId !== changeCounter) { return; }\n\t            var newScope = origScope.$new();\n\t            var template = response;\n\t\n\t            var clone = $compile(template)(newScope, function(clone) {\n\t              cleanupLastIncludeContent();\n\t              $animate.enter(clone, elem);\n\t            });\n\t\n\t            currentScope = newScope;\n\t            currentElement = clone;\n\t\n\t            currentScope.$emit('$includeContentLoaded', src);\n\t          }, function() {\n\t            if (thisChangeId === changeCounter) {\n\t              cleanupLastIncludeContent();\n\t              scope.$emit('$includeContentError', src);\n\t            }\n\t          });\n\t          scope.$emit('$includeContentRequested', src);\n\t        } else {\n\t          cleanupLastIncludeContent();\n\t        }\n\t      });\n\t\n\t      scope.$on('$destroy', cleanupLastIncludeContent);\n\t    }\n\t  };\n\t}])\n\t\n\t/**\n\t * Note that it's intentional that these classes are *not* applied through $animate.\n\t * They must not be animated as they're expected to be present on the tooltip on\n\t * initialization.\n\t */\n\t.directive('uibTooltipClasses', ['$uibPosition', function($uibPosition) {\n\t  return {\n\t    restrict: 'A',\n\t    link: function(scope, element, attrs) {\n\t      // need to set the primary position so the\n\t      // arrow has space during position measure.\n\t      // tooltip.positionTooltip()\n\t      if (scope.placement) {\n\t        // // There are no top-left etc... classes\n\t        // // in TWBS, so we need the primary position.\n\t        var position = $uibPosition.parsePlacement(scope.placement);\n\t        element.addClass(position[0]);\n\t      }\n\t\n\t      if (scope.popupClass) {\n\t        element.addClass(scope.popupClass);\n\t      }\n\t\n\t      if (scope.animation()) {\n\t        element.addClass(attrs.tooltipAnimationClass);\n\t      }\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('uibTooltipPopup', function() {\n\t  return {\n\t    replace: true,\n\t    scope: { content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n\t    templateUrl: 'uib/template/tooltip/tooltip-popup.html'\n\t  };\n\t})\n\t\n\t.directive('uibTooltip', [ '$uibTooltip', function($uibTooltip) {\n\t  return $uibTooltip('uibTooltip', 'tooltip', 'mouseenter');\n\t}])\n\t\n\t.directive('uibTooltipTemplatePopup', function() {\n\t  return {\n\t    replace: true,\n\t    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',\n\t      originScope: '&' },\n\t    templateUrl: 'uib/template/tooltip/tooltip-template-popup.html'\n\t  };\n\t})\n\t\n\t.directive('uibTooltipTemplate', ['$uibTooltip', function($uibTooltip) {\n\t  return $uibTooltip('uibTooltipTemplate', 'tooltip', 'mouseenter', {\n\t    useContentExp: true\n\t  });\n\t}])\n\t\n\t.directive('uibTooltipHtmlPopup', function() {\n\t  return {\n\t    replace: true,\n\t    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n\t    templateUrl: 'uib/template/tooltip/tooltip-html-popup.html'\n\t  };\n\t})\n\t\n\t.directive('uibTooltipHtml', ['$uibTooltip', function($uibTooltip) {\n\t  return $uibTooltip('uibTooltipHtml', 'tooltip', 'mouseenter', {\n\t    useContentExp: true\n\t  });\n\t}]);\n\t\n\t/**\n\t * The following features are still outstanding: popup delay, animation as a\n\t * function, placement as a function, inside, support for more triggers than\n\t * just mouse enter/leave, and selector delegatation.\n\t */\n\tangular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip'])\n\t\n\t.directive('uibPopoverTemplatePopup', function() {\n\t  return {\n\t    replace: true,\n\t    scope: { uibTitle: '@', contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',\n\t      originScope: '&' },\n\t    templateUrl: 'uib/template/popover/popover-template.html'\n\t  };\n\t})\n\t\n\t.directive('uibPopoverTemplate', ['$uibTooltip', function($uibTooltip) {\n\t  return $uibTooltip('uibPopoverTemplate', 'popover', 'click', {\n\t    useContentExp: true\n\t  });\n\t}])\n\t\n\t.directive('uibPopoverHtmlPopup', function() {\n\t  return {\n\t    replace: true,\n\t    scope: { contentExp: '&', uibTitle: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n\t    templateUrl: 'uib/template/popover/popover-html.html'\n\t  };\n\t})\n\t\n\t.directive('uibPopoverHtml', ['$uibTooltip', function($uibTooltip) {\n\t  return $uibTooltip('uibPopoverHtml', 'popover', 'click', {\n\t    useContentExp: true\n\t  });\n\t}])\n\t\n\t.directive('uibPopoverPopup', function() {\n\t  return {\n\t    replace: true,\n\t    scope: { uibTitle: '@', content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n\t    templateUrl: 'uib/template/popover/popover.html'\n\t  };\n\t})\n\t\n\t.directive('uibPopover', ['$uibTooltip', function($uibTooltip) {\n\t  return $uibTooltip('uibPopover', 'popover', 'click');\n\t}]);\n\t\n\tangular.module('ui.bootstrap.progressbar', [])\n\t\n\t.constant('uibProgressConfig', {\n\t  animate: true,\n\t  max: 100\n\t})\n\t\n\t.controller('UibProgressController', ['$scope', '$attrs', 'uibProgressConfig', function($scope, $attrs, progressConfig) {\n\t  var self = this,\n\t      animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;\n\t\n\t  this.bars = [];\n\t  $scope.max = getMaxOrDefault();\n\t\n\t  this.addBar = function(bar, element, attrs) {\n\t    if (!animate) {\n\t      element.css({'transition': 'none'});\n\t    }\n\t\n\t    this.bars.push(bar);\n\t\n\t    bar.max = getMaxOrDefault();\n\t    bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';\n\t\n\t    bar.$watch('value', function(value) {\n\t      bar.recalculatePercentage();\n\t    });\n\t\n\t    bar.recalculatePercentage = function() {\n\t      var totalPercentage = self.bars.reduce(function(total, bar) {\n\t        bar.percent = +(100 * bar.value / bar.max).toFixed(2);\n\t        return total + bar.percent;\n\t      }, 0);\n\t\n\t      if (totalPercentage > 100) {\n\t        bar.percent -= totalPercentage - 100;\n\t      }\n\t    };\n\t\n\t    bar.$on('$destroy', function() {\n\t      element = null;\n\t      self.removeBar(bar);\n\t    });\n\t  };\n\t\n\t  this.removeBar = function(bar) {\n\t    this.bars.splice(this.bars.indexOf(bar), 1);\n\t    this.bars.forEach(function (bar) {\n\t      bar.recalculatePercentage();\n\t    });\n\t  };\n\t\n\t  //$attrs.$observe('maxParam', function(maxParam) {\n\t  $scope.$watch('maxParam', function(maxParam) {\n\t    self.bars.forEach(function(bar) {\n\t      bar.max = getMaxOrDefault();\n\t      bar.recalculatePercentage();\n\t    });\n\t  });\n\t\n\t  function getMaxOrDefault () {\n\t    return angular.isDefined($scope.maxParam) ? $scope.maxParam : progressConfig.max;\n\t  }\n\t}])\n\t\n\t.directive('uibProgress', function() {\n\t  return {\n\t    replace: true,\n\t    transclude: true,\n\t    controller: 'UibProgressController',\n\t    require: 'uibProgress',\n\t    scope: {\n\t      maxParam: '=?max'\n\t    },\n\t    templateUrl: 'uib/template/progressbar/progress.html'\n\t  };\n\t})\n\t\n\t.directive('uibBar', function() {\n\t  return {\n\t    replace: true,\n\t    transclude: true,\n\t    require: '^uibProgress',\n\t    scope: {\n\t      value: '=',\n\t      type: '@'\n\t    },\n\t    templateUrl: 'uib/template/progressbar/bar.html',\n\t    link: function(scope, element, attrs, progressCtrl) {\n\t      progressCtrl.addBar(scope, element, attrs);\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibProgressbar', function() {\n\t  return {\n\t    replace: true,\n\t    transclude: true,\n\t    controller: 'UibProgressController',\n\t    scope: {\n\t      value: '=',\n\t      maxParam: '=?max',\n\t      type: '@'\n\t    },\n\t    templateUrl: 'uib/template/progressbar/progressbar.html',\n\t    link: function(scope, element, attrs, progressCtrl) {\n\t      progressCtrl.addBar(scope, angular.element(element.children()[0]), {title: attrs.title});\n\t    }\n\t  };\n\t});\n\t\n\tangular.module('ui.bootstrap.rating', [])\n\t\n\t.constant('uibRatingConfig', {\n\t  max: 5,\n\t  stateOn: null,\n\t  stateOff: null,\n\t  enableReset: true,\n\t  titles : ['one', 'two', 'three', 'four', 'five']\n\t})\n\t\n\t.controller('UibRatingController', ['$scope', '$attrs', 'uibRatingConfig', function($scope, $attrs, ratingConfig) {\n\t  var ngModelCtrl = { $setViewValue: angular.noop },\n\t    self = this;\n\t\n\t  this.init = function(ngModelCtrl_) {\n\t    ngModelCtrl = ngModelCtrl_;\n\t    ngModelCtrl.$render = this.render;\n\t\n\t    ngModelCtrl.$formatters.push(function(value) {\n\t      if (angular.isNumber(value) && value << 0 !== value) {\n\t        value = Math.round(value);\n\t      }\n\t\n\t      return value;\n\t    });\n\t\n\t    this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;\n\t    this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;\n\t    this.enableReset = angular.isDefined($attrs.enableReset) ?\n\t      $scope.$parent.$eval($attrs.enableReset) : ratingConfig.enableReset;\n\t    var tmpTitles = angular.isDefined($attrs.titles) ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles;\n\t    this.titles = angular.isArray(tmpTitles) && tmpTitles.length > 0 ?\n\t      tmpTitles : ratingConfig.titles;\n\t\n\t    var ratingStates = angular.isDefined($attrs.ratingStates) ?\n\t      $scope.$parent.$eval($attrs.ratingStates) :\n\t      new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);\n\t    $scope.range = this.buildTemplateObjects(ratingStates);\n\t  };\n\t\n\t  this.buildTemplateObjects = function(states) {\n\t    for (var i = 0, n = states.length; i < n; i++) {\n\t      states[i] = angular.extend({ index: i }, { stateOn: this.stateOn, stateOff: this.stateOff, title: this.getTitle(i) }, states[i]);\n\t    }\n\t    return states;\n\t  };\n\t\n\t  this.getTitle = function(index) {\n\t    if (index >= this.titles.length) {\n\t      return index + 1;\n\t    }\n\t\n\t    return this.titles[index];\n\t  };\n\t\n\t  $scope.rate = function(value) {\n\t    if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {\n\t      var newViewValue = self.enableReset && ngModelCtrl.$viewValue === value ? 0 : value;\n\t      ngModelCtrl.$setViewValue(newViewValue);\n\t      ngModelCtrl.$render();\n\t    }\n\t  };\n\t\n\t  $scope.enter = function(value) {\n\t    if (!$scope.readonly) {\n\t      $scope.value = value;\n\t    }\n\t    $scope.onHover({value: value});\n\t  };\n\t\n\t  $scope.reset = function() {\n\t    $scope.value = ngModelCtrl.$viewValue;\n\t    $scope.onLeave();\n\t  };\n\t\n\t  $scope.onKeydown = function(evt) {\n\t    if (/(37|38|39|40)/.test(evt.which)) {\n\t      evt.preventDefault();\n\t      evt.stopPropagation();\n\t      $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));\n\t    }\n\t  };\n\t\n\t  this.render = function() {\n\t    $scope.value = ngModelCtrl.$viewValue;\n\t    $scope.title = self.getTitle($scope.value - 1);\n\t  };\n\t}])\n\t\n\t.directive('uibRating', function() {\n\t  return {\n\t    require: ['uibRating', 'ngModel'],\n\t    scope: {\n\t      readonly: '=?readOnly',\n\t      onHover: '&',\n\t      onLeave: '&'\n\t    },\n\t    controller: 'UibRatingController',\n\t    templateUrl: 'uib/template/rating/rating.html',\n\t    replace: true,\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t      ratingCtrl.init(ngModelCtrl);\n\t    }\n\t  };\n\t});\n\t\n\tangular.module('ui.bootstrap.tabs', [])\n\t\n\t.controller('UibTabsetController', ['$scope', function ($scope) {\n\t  var ctrl = this,\n\t    oldIndex;\n\t  ctrl.tabs = [];\n\t\n\t  ctrl.select = function(index, evt) {\n\t    if (!destroyed) {\n\t      var previousIndex = findTabIndex(oldIndex);\n\t      var previousSelected = ctrl.tabs[previousIndex];\n\t      if (previousSelected) {\n\t        previousSelected.tab.onDeselect({\n\t          $event: evt,\n\t          $selectedIndex: index\n\t        });\n\t        if (evt && evt.isDefaultPrevented()) {\n\t          return;\n\t        }\n\t        previousSelected.tab.active = false;\n\t      }\n\t\n\t      var selected = ctrl.tabs[index];\n\t      if (selected) {\n\t        selected.tab.onSelect({\n\t          $event: evt\n\t        });\n\t        selected.tab.active = true;\n\t        ctrl.active = selected.index;\n\t        oldIndex = selected.index;\n\t      } else if (!selected && angular.isDefined(oldIndex)) {\n\t        ctrl.active = null;\n\t        oldIndex = null;\n\t      }\n\t    }\n\t  };\n\t\n\t  ctrl.addTab = function addTab(tab) {\n\t    ctrl.tabs.push({\n\t      tab: tab,\n\t      index: tab.index\n\t    });\n\t    ctrl.tabs.sort(function(t1, t2) {\n\t      if (t1.index > t2.index) {\n\t        return 1;\n\t      }\n\t\n\t      if (t1.index < t2.index) {\n\t        return -1;\n\t      }\n\t\n\t      return 0;\n\t    });\n\t\n\t    if (tab.index === ctrl.active || !angular.isDefined(ctrl.active) && ctrl.tabs.length === 1) {\n\t      var newActiveIndex = findTabIndex(tab.index);\n\t      ctrl.select(newActiveIndex);\n\t    }\n\t  };\n\t\n\t  ctrl.removeTab = function removeTab(tab) {\n\t    var index;\n\t    for (var i = 0; i < ctrl.tabs.length; i++) {\n\t      if (ctrl.tabs[i].tab === tab) {\n\t        index = i;\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (ctrl.tabs[index].index === ctrl.active) {\n\t      var newActiveTabIndex = index === ctrl.tabs.length - 1 ?\n\t        index - 1 : index + 1 % ctrl.tabs.length;\n\t      ctrl.select(newActiveTabIndex);\n\t    }\n\t\n\t    ctrl.tabs.splice(index, 1);\n\t  };\n\t\n\t  $scope.$watch('tabset.active', function(val) {\n\t    if (angular.isDefined(val) && val !== oldIndex) {\n\t      ctrl.select(findTabIndex(val));\n\t    }\n\t  });\n\t\n\t  var destroyed;\n\t  $scope.$on('$destroy', function() {\n\t    destroyed = true;\n\t  });\n\t\n\t  function findTabIndex(index) {\n\t    for (var i = 0; i < ctrl.tabs.length; i++) {\n\t      if (ctrl.tabs[i].index === index) {\n\t        return i;\n\t      }\n\t    }\n\t  }\n\t}])\n\t\n\t.directive('uibTabset', function() {\n\t  return {\n\t    transclude: true,\n\t    replace: true,\n\t    scope: {},\n\t    bindToController: {\n\t      active: '=?',\n\t      type: '@'\n\t    },\n\t    controller: 'UibTabsetController',\n\t    controllerAs: 'tabset',\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'uib/template/tabs/tabset.html';\n\t    },\n\t    link: function(scope, element, attrs) {\n\t      scope.vertical = angular.isDefined(attrs.vertical) ?\n\t        scope.$parent.$eval(attrs.vertical) : false;\n\t      scope.justified = angular.isDefined(attrs.justified) ?\n\t        scope.$parent.$eval(attrs.justified) : false;\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibTab', ['$parse', function($parse) {\n\t  return {\n\t    require: '^uibTabset',\n\t    replace: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'uib/template/tabs/tab.html';\n\t    },\n\t    transclude: true,\n\t    scope: {\n\t      heading: '@',\n\t      index: '=?',\n\t      classes: '@?',\n\t      onSelect: '&select', //This callback is called in contentHeadingTransclude\n\t                          //once it inserts the tab's content into the dom\n\t      onDeselect: '&deselect'\n\t    },\n\t    controller: function() {\n\t      //Empty controller so other directives can require being 'under' a tab\n\t    },\n\t    controllerAs: 'tab',\n\t    link: function(scope, elm, attrs, tabsetCtrl, transclude) {\n\t      scope.disabled = false;\n\t      if (attrs.disable) {\n\t        scope.$parent.$watch($parse(attrs.disable), function(value) {\n\t          scope.disabled = !! value;\n\t        });\n\t      }\n\t\n\t      if (angular.isUndefined(attrs.index)) {\n\t        if (tabsetCtrl.tabs && tabsetCtrl.tabs.length) {\n\t          scope.index = Math.max.apply(null, tabsetCtrl.tabs.map(function(t) { return t.index; })) + 1;\n\t        } else {\n\t          scope.index = 0;\n\t        }\n\t      }\n\t\n\t      if (angular.isUndefined(attrs.classes)) {\n\t        scope.classes = '';\n\t      }\n\t\n\t      scope.select = function(evt) {\n\t        if (!scope.disabled) {\n\t          var index;\n\t          for (var i = 0; i < tabsetCtrl.tabs.length; i++) {\n\t            if (tabsetCtrl.tabs[i].tab === scope) {\n\t              index = i;\n\t              break;\n\t            }\n\t          }\n\t\n\t          tabsetCtrl.select(index, evt);\n\t        }\n\t      };\n\t\n\t      tabsetCtrl.addTab(scope);\n\t      scope.$on('$destroy', function() {\n\t        tabsetCtrl.removeTab(scope);\n\t      });\n\t\n\t      //We need to transclude later, once the content container is ready.\n\t      //when this link happens, we're inside a tab heading.\n\t      scope.$transcludeFn = transclude;\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('uibTabHeadingTransclude', function() {\n\t  return {\n\t    restrict: 'A',\n\t    require: '^uibTab',\n\t    link: function(scope, elm) {\n\t      scope.$watch('headingElement', function updateHeadingElement(heading) {\n\t        if (heading) {\n\t          elm.html('');\n\t          elm.append(heading);\n\t        }\n\t      });\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibTabContentTransclude', function() {\n\t  return {\n\t    restrict: 'A',\n\t    require: '^uibTabset',\n\t    link: function(scope, elm, attrs) {\n\t      var tab = scope.$eval(attrs.uibTabContentTransclude).tab;\n\t\n\t      //Now our tab is ready to be transcluded: both the tab heading area\n\t      //and the tab content area are loaded.  Transclude 'em both.\n\t      tab.$transcludeFn(tab.$parent, function(contents) {\n\t        angular.forEach(contents, function(node) {\n\t          if (isTabHeading(node)) {\n\t            //Let tabHeadingTransclude know.\n\t            tab.headingElement = node;\n\t          } else {\n\t            elm.append(node);\n\t          }\n\t        });\n\t      });\n\t    }\n\t  };\n\t\n\t  function isTabHeading(node) {\n\t    return node.tagName && (\n\t      node.hasAttribute('uib-tab-heading') ||\n\t      node.hasAttribute('data-uib-tab-heading') ||\n\t      node.hasAttribute('x-uib-tab-heading') ||\n\t      node.tagName.toLowerCase() === 'uib-tab-heading' ||\n\t      node.tagName.toLowerCase() === 'data-uib-tab-heading' ||\n\t      node.tagName.toLowerCase() === 'x-uib-tab-heading' ||\n\t      node.tagName.toLowerCase() === 'uib:tab-heading'\n\t    );\n\t  }\n\t});\n\t\n\tangular.module('ui.bootstrap.timepicker', [])\n\t\n\t.constant('uibTimepickerConfig', {\n\t  hourStep: 1,\n\t  minuteStep: 1,\n\t  secondStep: 1,\n\t  showMeridian: true,\n\t  showSeconds: false,\n\t  meridians: null,\n\t  readonlyInput: false,\n\t  mousewheel: true,\n\t  arrowkeys: true,\n\t  showSpinners: true,\n\t  templateUrl: 'uib/template/timepicker/timepicker.html'\n\t})\n\t\n\t.controller('UibTimepickerController', ['$scope', '$element', '$attrs', '$parse', '$log', '$locale', 'uibTimepickerConfig', function($scope, $element, $attrs, $parse, $log, $locale, timepickerConfig) {\n\t  var selected = new Date(),\n\t    watchers = [],\n\t    ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl\n\t    meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS,\n\t    padHours = angular.isDefined($attrs.padHours) ? $scope.$parent.$eval($attrs.padHours) : true;\n\t\n\t  $scope.tabindex = angular.isDefined($attrs.tabindex) ? $attrs.tabindex : 0;\n\t  $element.removeAttr('tabindex');\n\t\n\t  this.init = function(ngModelCtrl_, inputs) {\n\t    ngModelCtrl = ngModelCtrl_;\n\t    ngModelCtrl.$render = this.render;\n\t\n\t    ngModelCtrl.$formatters.unshift(function(modelValue) {\n\t      return modelValue ? new Date(modelValue) : null;\n\t    });\n\t\n\t    var hoursInputEl = inputs.eq(0),\n\t        minutesInputEl = inputs.eq(1),\n\t        secondsInputEl = inputs.eq(2);\n\t\n\t    var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;\n\t\n\t    if (mousewheel) {\n\t      this.setupMousewheelEvents(hoursInputEl, minutesInputEl, secondsInputEl);\n\t    }\n\t\n\t    var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;\n\t    if (arrowkeys) {\n\t      this.setupArrowkeyEvents(hoursInputEl, minutesInputEl, secondsInputEl);\n\t    }\n\t\n\t    $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;\n\t    this.setupInputEvents(hoursInputEl, minutesInputEl, secondsInputEl);\n\t  };\n\t\n\t  var hourStep = timepickerConfig.hourStep;\n\t  if ($attrs.hourStep) {\n\t    watchers.push($scope.$parent.$watch($parse($attrs.hourStep), function(value) {\n\t      hourStep = +value;\n\t    }));\n\t  }\n\t\n\t  var minuteStep = timepickerConfig.minuteStep;\n\t  if ($attrs.minuteStep) {\n\t    watchers.push($scope.$parent.$watch($parse($attrs.minuteStep), function(value) {\n\t      minuteStep = +value;\n\t    }));\n\t  }\n\t\n\t  var min;\n\t  watchers.push($scope.$parent.$watch($parse($attrs.min), function(value) {\n\t    var dt = new Date(value);\n\t    min = isNaN(dt) ? undefined : dt;\n\t  }));\n\t\n\t  var max;\n\t  watchers.push($scope.$parent.$watch($parse($attrs.max), function(value) {\n\t    var dt = new Date(value);\n\t    max = isNaN(dt) ? undefined : dt;\n\t  }));\n\t\n\t  var disabled = false;\n\t  if ($attrs.ngDisabled) {\n\t    watchers.push($scope.$parent.$watch($parse($attrs.ngDisabled), function(value) {\n\t      disabled = value;\n\t    }));\n\t  }\n\t\n\t  $scope.noIncrementHours = function() {\n\t    var incrementedSelected = addMinutes(selected, hourStep * 60);\n\t    return disabled || incrementedSelected > max ||\n\t      incrementedSelected < selected && incrementedSelected < min;\n\t  };\n\t\n\t  $scope.noDecrementHours = function() {\n\t    var decrementedSelected = addMinutes(selected, -hourStep * 60);\n\t    return disabled || decrementedSelected < min ||\n\t      decrementedSelected > selected && decrementedSelected > max;\n\t  };\n\t\n\t  $scope.noIncrementMinutes = function() {\n\t    var incrementedSelected = addMinutes(selected, minuteStep);\n\t    return disabled || incrementedSelected > max ||\n\t      incrementedSelected < selected && incrementedSelected < min;\n\t  };\n\t\n\t  $scope.noDecrementMinutes = function() {\n\t    var decrementedSelected = addMinutes(selected, -minuteStep);\n\t    return disabled || decrementedSelected < min ||\n\t      decrementedSelected > selected && decrementedSelected > max;\n\t  };\n\t\n\t  $scope.noIncrementSeconds = function() {\n\t    var incrementedSelected = addSeconds(selected, secondStep);\n\t    return disabled || incrementedSelected > max ||\n\t      incrementedSelected < selected && incrementedSelected < min;\n\t  };\n\t\n\t  $scope.noDecrementSeconds = function() {\n\t    var decrementedSelected = addSeconds(selected, -secondStep);\n\t    return disabled || decrementedSelected < min ||\n\t      decrementedSelected > selected && decrementedSelected > max;\n\t  };\n\t\n\t  $scope.noToggleMeridian = function() {\n\t    if (selected.getHours() < 12) {\n\t      return disabled || addMinutes(selected, 12 * 60) > max;\n\t    }\n\t\n\t    return disabled || addMinutes(selected, -12 * 60) < min;\n\t  };\n\t\n\t  var secondStep = timepickerConfig.secondStep;\n\t  if ($attrs.secondStep) {\n\t    watchers.push($scope.$parent.$watch($parse($attrs.secondStep), function(value) {\n\t      secondStep = +value;\n\t    }));\n\t  }\n\t\n\t  $scope.showSeconds = timepickerConfig.showSeconds;\n\t  if ($attrs.showSeconds) {\n\t    watchers.push($scope.$parent.$watch($parse($attrs.showSeconds), function(value) {\n\t      $scope.showSeconds = !!value;\n\t    }));\n\t  }\n\t\n\t  // 12H / 24H mode\n\t  $scope.showMeridian = timepickerConfig.showMeridian;\n\t  if ($attrs.showMeridian) {\n\t    watchers.push($scope.$parent.$watch($parse($attrs.showMeridian), function(value) {\n\t      $scope.showMeridian = !!value;\n\t\n\t      if (ngModelCtrl.$error.time) {\n\t        // Evaluate from template\n\t        var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();\n\t        if (angular.isDefined(hours) && angular.isDefined(minutes)) {\n\t          selected.setHours(hours);\n\t          refresh();\n\t        }\n\t      } else {\n\t        updateTemplate();\n\t      }\n\t    }));\n\t  }\n\t\n\t  // Get $scope.hours in 24H mode if valid\n\t  function getHoursFromTemplate() {\n\t    var hours = +$scope.hours;\n\t    var valid = $scope.showMeridian ? hours > 0 && hours < 13 :\n\t      hours >= 0 && hours < 24;\n\t    if (!valid || $scope.hours === '') {\n\t      return undefined;\n\t    }\n\t\n\t    if ($scope.showMeridian) {\n\t      if (hours === 12) {\n\t        hours = 0;\n\t      }\n\t      if ($scope.meridian === meridians[1]) {\n\t        hours = hours + 12;\n\t      }\n\t    }\n\t    return hours;\n\t  }\n\t\n\t  function getMinutesFromTemplate() {\n\t    var minutes = +$scope.minutes;\n\t    var valid = minutes >= 0 && minutes < 60;\n\t    if (!valid || $scope.minutes === '') {\n\t      return undefined;\n\t    }\n\t    return minutes;\n\t  }\n\t\n\t  function getSecondsFromTemplate() {\n\t    var seconds = +$scope.seconds;\n\t    return seconds >= 0 && seconds < 60 ? seconds : undefined;\n\t  }\n\t\n\t  function pad(value, noPad) {\n\t    if (value === null) {\n\t      return '';\n\t    }\n\t\n\t    return angular.isDefined(value) && value.toString().length < 2 && !noPad ?\n\t      '0' + value : value.toString();\n\t  }\n\t\n\t  // Respond on mousewheel spin\n\t  this.setupMousewheelEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {\n\t    var isScrollingUp = function(e) {\n\t      if (e.originalEvent) {\n\t        e = e.originalEvent;\n\t      }\n\t      //pick correct delta variable depending on event\n\t      var delta = e.wheelDelta ? e.wheelDelta : -e.deltaY;\n\t      return e.detail || delta > 0;\n\t    };\n\t\n\t    hoursInputEl.bind('mousewheel wheel', function(e) {\n\t      if (!disabled) {\n\t        $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());\n\t      }\n\t      e.preventDefault();\n\t    });\n\t\n\t    minutesInputEl.bind('mousewheel wheel', function(e) {\n\t      if (!disabled) {\n\t        $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());\n\t      }\n\t      e.preventDefault();\n\t    });\n\t\n\t     secondsInputEl.bind('mousewheel wheel', function(e) {\n\t      if (!disabled) {\n\t        $scope.$apply(isScrollingUp(e) ? $scope.incrementSeconds() : $scope.decrementSeconds());\n\t      }\n\t      e.preventDefault();\n\t    });\n\t  };\n\t\n\t  // Respond on up/down arrowkeys\n\t  this.setupArrowkeyEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {\n\t    hoursInputEl.bind('keydown', function(e) {\n\t      if (!disabled) {\n\t        if (e.which === 38) { // up\n\t          e.preventDefault();\n\t          $scope.incrementHours();\n\t          $scope.$apply();\n\t        } else if (e.which === 40) { // down\n\t          e.preventDefault();\n\t          $scope.decrementHours();\n\t          $scope.$apply();\n\t        }\n\t      }\n\t    });\n\t\n\t    minutesInputEl.bind('keydown', function(e) {\n\t      if (!disabled) {\n\t        if (e.which === 38) { // up\n\t          e.preventDefault();\n\t          $scope.incrementMinutes();\n\t          $scope.$apply();\n\t        } else if (e.which === 40) { // down\n\t          e.preventDefault();\n\t          $scope.decrementMinutes();\n\t          $scope.$apply();\n\t        }\n\t      }\n\t    });\n\t\n\t    secondsInputEl.bind('keydown', function(e) {\n\t      if (!disabled) {\n\t        if (e.which === 38) { // up\n\t          e.preventDefault();\n\t          $scope.incrementSeconds();\n\t          $scope.$apply();\n\t        } else if (e.which === 40) { // down\n\t          e.preventDefault();\n\t          $scope.decrementSeconds();\n\t          $scope.$apply();\n\t        }\n\t      }\n\t    });\n\t  };\n\t\n\t  this.setupInputEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {\n\t    if ($scope.readonlyInput) {\n\t      $scope.updateHours = angular.noop;\n\t      $scope.updateMinutes = angular.noop;\n\t      $scope.updateSeconds = angular.noop;\n\t      return;\n\t    }\n\t\n\t    var invalidate = function(invalidHours, invalidMinutes, invalidSeconds) {\n\t      ngModelCtrl.$setViewValue(null);\n\t      ngModelCtrl.$setValidity('time', false);\n\t      if (angular.isDefined(invalidHours)) {\n\t        $scope.invalidHours = invalidHours;\n\t      }\n\t\n\t      if (angular.isDefined(invalidMinutes)) {\n\t        $scope.invalidMinutes = invalidMinutes;\n\t      }\n\t\n\t      if (angular.isDefined(invalidSeconds)) {\n\t        $scope.invalidSeconds = invalidSeconds;\n\t      }\n\t    };\n\t\n\t    $scope.updateHours = function() {\n\t      var hours = getHoursFromTemplate(),\n\t        minutes = getMinutesFromTemplate();\n\t\n\t      ngModelCtrl.$setDirty();\n\t\n\t      if (angular.isDefined(hours) && angular.isDefined(minutes)) {\n\t        selected.setHours(hours);\n\t        selected.setMinutes(minutes);\n\t        if (selected < min || selected > max) {\n\t          invalidate(true);\n\t        } else {\n\t          refresh('h');\n\t        }\n\t      } else {\n\t        invalidate(true);\n\t      }\n\t    };\n\t\n\t    hoursInputEl.bind('blur', function(e) {\n\t      ngModelCtrl.$setTouched();\n\t      if (modelIsEmpty()) {\n\t        makeValid();\n\t      } else if ($scope.hours === null || $scope.hours === '') {\n\t        invalidate(true);\n\t      } else if (!$scope.invalidHours && $scope.hours < 10) {\n\t        $scope.$apply(function() {\n\t          $scope.hours = pad($scope.hours, !padHours);\n\t        });\n\t      }\n\t    });\n\t\n\t    $scope.updateMinutes = function() {\n\t      var minutes = getMinutesFromTemplate(),\n\t        hours = getHoursFromTemplate();\n\t\n\t      ngModelCtrl.$setDirty();\n\t\n\t      if (angular.isDefined(minutes) && angular.isDefined(hours)) {\n\t        selected.setHours(hours);\n\t        selected.setMinutes(minutes);\n\t        if (selected < min || selected > max) {\n\t          invalidate(undefined, true);\n\t        } else {\n\t          refresh('m');\n\t        }\n\t      } else {\n\t        invalidate(undefined, true);\n\t      }\n\t    };\n\t\n\t    minutesInputEl.bind('blur', function(e) {\n\t      ngModelCtrl.$setTouched();\n\t      if (modelIsEmpty()) {\n\t        makeValid();\n\t      } else if ($scope.minutes === null) {\n\t        invalidate(undefined, true);\n\t      } else if (!$scope.invalidMinutes && $scope.minutes < 10) {\n\t        $scope.$apply(function() {\n\t          $scope.minutes = pad($scope.minutes);\n\t        });\n\t      }\n\t    });\n\t\n\t    $scope.updateSeconds = function() {\n\t      var seconds = getSecondsFromTemplate();\n\t\n\t      ngModelCtrl.$setDirty();\n\t\n\t      if (angular.isDefined(seconds)) {\n\t        selected.setSeconds(seconds);\n\t        refresh('s');\n\t      } else {\n\t        invalidate(undefined, undefined, true);\n\t      }\n\t    };\n\t\n\t    secondsInputEl.bind('blur', function(e) {\n\t      if (modelIsEmpty()) {\n\t        makeValid();\n\t      } else if (!$scope.invalidSeconds && $scope.seconds < 10) {\n\t        $scope.$apply( function() {\n\t          $scope.seconds = pad($scope.seconds);\n\t        });\n\t      }\n\t    });\n\t\n\t  };\n\t\n\t  this.render = function() {\n\t    var date = ngModelCtrl.$viewValue;\n\t\n\t    if (isNaN(date)) {\n\t      ngModelCtrl.$setValidity('time', false);\n\t      $log.error('Timepicker directive: \"ng-model\" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');\n\t    } else {\n\t      if (date) {\n\t        selected = date;\n\t      }\n\t\n\t      if (selected < min || selected > max) {\n\t        ngModelCtrl.$setValidity('time', false);\n\t        $scope.invalidHours = true;\n\t        $scope.invalidMinutes = true;\n\t      } else {\n\t        makeValid();\n\t      }\n\t      updateTemplate();\n\t    }\n\t  };\n\t\n\t  // Call internally when we know that model is valid.\n\t  function refresh(keyboardChange) {\n\t    makeValid();\n\t    ngModelCtrl.$setViewValue(new Date(selected));\n\t    updateTemplate(keyboardChange);\n\t  }\n\t\n\t  function makeValid() {\n\t    ngModelCtrl.$setValidity('time', true);\n\t    $scope.invalidHours = false;\n\t    $scope.invalidMinutes = false;\n\t    $scope.invalidSeconds = false;\n\t  }\n\t\n\t  function updateTemplate(keyboardChange) {\n\t    if (!ngModelCtrl.$modelValue) {\n\t      $scope.hours = null;\n\t      $scope.minutes = null;\n\t      $scope.seconds = null;\n\t      $scope.meridian = meridians[0];\n\t    } else {\n\t      var hours = selected.getHours(),\n\t        minutes = selected.getMinutes(),\n\t        seconds = selected.getSeconds();\n\t\n\t      if ($scope.showMeridian) {\n\t        hours = hours === 0 || hours === 12 ? 12 : hours % 12; // Convert 24 to 12 hour system\n\t      }\n\t\n\t      $scope.hours = keyboardChange === 'h' ? hours : pad(hours, !padHours);\n\t      if (keyboardChange !== 'm') {\n\t        $scope.minutes = pad(minutes);\n\t      }\n\t      $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];\n\t\n\t      if (keyboardChange !== 's') {\n\t        $scope.seconds = pad(seconds);\n\t      }\n\t      $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];\n\t    }\n\t  }\n\t\n\t  function addSecondsToSelected(seconds) {\n\t    selected = addSeconds(selected, seconds);\n\t    refresh();\n\t  }\n\t\n\t  function addMinutes(selected, minutes) {\n\t    return addSeconds(selected, minutes*60);\n\t  }\n\t\n\t  function addSeconds(date, seconds) {\n\t    var dt = new Date(date.getTime() + seconds * 1000);\n\t    var newDate = new Date(date);\n\t    newDate.setHours(dt.getHours(), dt.getMinutes(), dt.getSeconds());\n\t    return newDate;\n\t  }\n\t\n\t  function modelIsEmpty() {\n\t    return ($scope.hours === null || $scope.hours === '') &&\n\t      ($scope.minutes === null || $scope.minutes === '') &&\n\t      (!$scope.showSeconds || $scope.showSeconds && ($scope.seconds === null || $scope.seconds === ''));\n\t  }\n\t\n\t  $scope.showSpinners = angular.isDefined($attrs.showSpinners) ?\n\t    $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners;\n\t\n\t  $scope.incrementHours = function() {\n\t    if (!$scope.noIncrementHours()) {\n\t      addSecondsToSelected(hourStep * 60 * 60);\n\t    }\n\t  };\n\t\n\t  $scope.decrementHours = function() {\n\t    if (!$scope.noDecrementHours()) {\n\t      addSecondsToSelected(-hourStep * 60 * 60);\n\t    }\n\t  };\n\t\n\t  $scope.incrementMinutes = function() {\n\t    if (!$scope.noIncrementMinutes()) {\n\t      addSecondsToSelected(minuteStep * 60);\n\t    }\n\t  };\n\t\n\t  $scope.decrementMinutes = function() {\n\t    if (!$scope.noDecrementMinutes()) {\n\t      addSecondsToSelected(-minuteStep * 60);\n\t    }\n\t  };\n\t\n\t  $scope.incrementSeconds = function() {\n\t    if (!$scope.noIncrementSeconds()) {\n\t      addSecondsToSelected(secondStep);\n\t    }\n\t  };\n\t\n\t  $scope.decrementSeconds = function() {\n\t    if (!$scope.noDecrementSeconds()) {\n\t      addSecondsToSelected(-secondStep);\n\t    }\n\t  };\n\t\n\t  $scope.toggleMeridian = function() {\n\t    var minutes = getMinutesFromTemplate(),\n\t        hours = getHoursFromTemplate();\n\t\n\t    if (!$scope.noToggleMeridian()) {\n\t      if (angular.isDefined(minutes) && angular.isDefined(hours)) {\n\t        addSecondsToSelected(12 * 60 * (selected.getHours() < 12 ? 60 : -60));\n\t      } else {\n\t        $scope.meridian = $scope.meridian === meridians[0] ? meridians[1] : meridians[0];\n\t      }\n\t    }\n\t  };\n\t\n\t  $scope.blur = function() {\n\t    ngModelCtrl.$setTouched();\n\t  };\n\t\n\t  $scope.$on('$destroy', function() {\n\t    while (watchers.length) {\n\t      watchers.shift()();\n\t    }\n\t  });\n\t}])\n\t\n\t.directive('uibTimepicker', ['uibTimepickerConfig', function(uibTimepickerConfig) {\n\t  return {\n\t    require: ['uibTimepicker', '?^ngModel'],\n\t    controller: 'UibTimepickerController',\n\t    controllerAs: 'timepicker',\n\t    replace: true,\n\t    scope: {},\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || uibTimepickerConfig.templateUrl;\n\t    },\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      if (ngModelCtrl) {\n\t        timepickerCtrl.init(ngModelCtrl, element.find('input'));\n\t      }\n\t    }\n\t  };\n\t}]);\n\t\n\tangular.module('ui.bootstrap.typeahead', ['ui.bootstrap.debounce', 'ui.bootstrap.position'])\n\t\n\t/**\n\t * A helper service that can parse typeahead's syntax (string provided by users)\n\t * Extracted to a separate service for ease of unit testing\n\t */\n\t  .factory('uibTypeaheadParser', ['$parse', function($parse) {\n\t    //                      00000111000000000000022200000000000000003333333333333330000000000044000\n\t    var TYPEAHEAD_REGEXP = /^\\s*([\\s\\S]+?)(?:\\s+as\\s+([\\s\\S]+?))?\\s+for\\s+(?:([\\$\\w][\\$\\w\\d]*))\\s+in\\s+([\\s\\S]+?)$/;\n\t    return {\n\t      parse: function(input) {\n\t        var match = input.match(TYPEAHEAD_REGEXP);\n\t        if (!match) {\n\t          throw new Error(\n\t            'Expected typeahead specification in form of \"_modelValue_ (as _label_)? for _item_ in _collection_\"' +\n\t              ' but got \"' + input + '\".');\n\t        }\n\t\n\t        return {\n\t          itemName: match[3],\n\t          source: $parse(match[4]),\n\t          viewMapper: $parse(match[2] || match[1]),\n\t          modelMapper: $parse(match[1])\n\t        };\n\t      }\n\t    };\n\t  }])\n\t\n\t  .controller('UibTypeaheadController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$$debounce', '$uibPosition', 'uibTypeaheadParser',\n\t    function(originalScope, element, attrs, $compile, $parse, $q, $timeout, $document, $window, $rootScope, $$debounce, $position, typeaheadParser) {\n\t    var HOT_KEYS = [9, 13, 27, 38, 40];\n\t    var eventDebounceTime = 200;\n\t    var modelCtrl, ngModelOptions;\n\t    //SUPPORTED ATTRIBUTES (OPTIONS)\n\t\n\t    //minimal no of characters that needs to be entered before typeahead kicks-in\n\t    var minLength = originalScope.$eval(attrs.typeaheadMinLength);\n\t    if (!minLength && minLength !== 0) {\n\t      minLength = 1;\n\t    }\n\t\n\t    originalScope.$watch(attrs.typeaheadMinLength, function (newVal) {\n\t        minLength = !newVal && newVal !== 0 ? 1 : newVal;\n\t    });\n\t\n\t    //minimal wait time after last character typed before typeahead kicks-in\n\t    var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;\n\t\n\t    //should it restrict model values to the ones selected from the popup only?\n\t    var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;\n\t    originalScope.$watch(attrs.typeaheadEditable, function (newVal) {\n\t      isEditable = newVal !== false;\n\t    });\n\t\n\t    //binding to a variable that indicates if matches are being retrieved asynchronously\n\t    var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;\n\t\n\t    //a function to determine if an event should cause selection\n\t    var isSelectEvent = attrs.typeaheadShouldSelect ? $parse(attrs.typeaheadShouldSelect) : function(scope, vals) {\n\t      var evt = vals.$event;\n\t      return evt.which === 13 || evt.which === 9;\n\t    };\n\t\n\t    //a callback executed when a match is selected\n\t    var onSelectCallback = $parse(attrs.typeaheadOnSelect);\n\t\n\t    //should it select highlighted popup value when losing focus?\n\t    var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;\n\t\n\t    //binding to a variable that indicates if there were no results after the query is completed\n\t    var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;\n\t\n\t    var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;\n\t\n\t    var appendToBody = attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;\n\t\n\t    var appendTo = attrs.typeaheadAppendTo ?\n\t      originalScope.$eval(attrs.typeaheadAppendTo) : null;\n\t\n\t    var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;\n\t\n\t    //If input matches an item of the list exactly, select it automatically\n\t    var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;\n\t\n\t    //binding to a variable that indicates if dropdown is open\n\t    var isOpenSetter = $parse(attrs.typeaheadIsOpen).assign || angular.noop;\n\t\n\t    var showHint = originalScope.$eval(attrs.typeaheadShowHint) || false;\n\t\n\t    //INTERNAL VARIABLES\n\t\n\t    //model setter executed upon match selection\n\t    var parsedModel = $parse(attrs.ngModel);\n\t    var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');\n\t    var $setModelValue = function(scope, newValue) {\n\t      if (angular.isFunction(parsedModel(originalScope)) &&\n\t        ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter) {\n\t        return invokeModelSetter(scope, {$$$p: newValue});\n\t      }\n\t\n\t      return parsedModel.assign(scope, newValue);\n\t    };\n\t\n\t    //expressions used by typeahead\n\t    var parserResult = typeaheadParser.parse(attrs.uibTypeahead);\n\t\n\t    var hasFocus;\n\t\n\t    //Used to avoid bug in iOS webview where iOS keyboard does not fire\n\t    //mousedown & mouseup events\n\t    //Issue #3699\n\t    var selected;\n\t\n\t    //create a child scope for the typeahead directive so we are not polluting original scope\n\t    //with typeahead-specific data (matches, query etc.)\n\t    var scope = originalScope.$new();\n\t    var offDestroy = originalScope.$on('$destroy', function() {\n\t      scope.$destroy();\n\t    });\n\t    scope.$on('$destroy', offDestroy);\n\t\n\t    // WAI-ARIA\n\t    var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);\n\t    element.attr({\n\t      'aria-autocomplete': 'list',\n\t      'aria-expanded': false,\n\t      'aria-owns': popupId\n\t    });\n\t\n\t    var inputsContainer, hintInputElem;\n\t    //add read-only input to show hint\n\t    if (showHint) {\n\t      inputsContainer = angular.element('<div></div>');\n\t      inputsContainer.css('position', 'relative');\n\t      element.after(inputsContainer);\n\t      hintInputElem = element.clone();\n\t      hintInputElem.attr('placeholder', '');\n\t      hintInputElem.attr('tabindex', '-1');\n\t      hintInputElem.val('');\n\t      hintInputElem.css({\n\t        'position': 'absolute',\n\t        'top': '0px',\n\t        'left': '0px',\n\t        'border-color': 'transparent',\n\t        'box-shadow': 'none',\n\t        'opacity': 1,\n\t        'background': 'none 0% 0% / auto repeat scroll padding-box border-box rgb(255, 255, 255)',\n\t        'color': '#999'\n\t      });\n\t      element.css({\n\t        'position': 'relative',\n\t        'vertical-align': 'top',\n\t        'background-color': 'transparent'\n\t      });\n\t      inputsContainer.append(hintInputElem);\n\t      hintInputElem.after(element);\n\t    }\n\t\n\t    //pop-up element used to display matches\n\t    var popUpEl = angular.element('<div uib-typeahead-popup></div>');\n\t    popUpEl.attr({\n\t      id: popupId,\n\t      matches: 'matches',\n\t      active: 'activeIdx',\n\t      select: 'select(activeIdx, evt)',\n\t      'move-in-progress': 'moveInProgress',\n\t      query: 'query',\n\t      position: 'position',\n\t      'assign-is-open': 'assignIsOpen(isOpen)',\n\t      debounce: 'debounceUpdate'\n\t    });\n\t    //custom item template\n\t    if (angular.isDefined(attrs.typeaheadTemplateUrl)) {\n\t      popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);\n\t    }\n\t\n\t    if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {\n\t      popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);\n\t    }\n\t\n\t    var resetHint = function() {\n\t      if (showHint) {\n\t        hintInputElem.val('');\n\t      }\n\t    };\n\t\n\t    var resetMatches = function() {\n\t      scope.matches = [];\n\t      scope.activeIdx = -1;\n\t      element.attr('aria-expanded', false);\n\t      resetHint();\n\t    };\n\t\n\t    var getMatchId = function(index) {\n\t      return popupId + '-option-' + index;\n\t    };\n\t\n\t    // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.\n\t    // This attribute is added or removed automatically when the `activeIdx` changes.\n\t    scope.$watch('activeIdx', function(index) {\n\t      if (index < 0) {\n\t        element.removeAttr('aria-activedescendant');\n\t      } else {\n\t        element.attr('aria-activedescendant', getMatchId(index));\n\t      }\n\t    });\n\t\n\t    var inputIsExactMatch = function(inputValue, index) {\n\t      if (scope.matches.length > index && inputValue) {\n\t        return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();\n\t      }\n\t\n\t      return false;\n\t    };\n\t\n\t    var getMatchesAsync = function(inputValue, evt) {\n\t      var locals = {$viewValue: inputValue};\n\t      isLoadingSetter(originalScope, true);\n\t      isNoResultsSetter(originalScope, false);\n\t      $q.when(parserResult.source(originalScope, locals)).then(function(matches) {\n\t        //it might happen that several async queries were in progress if a user were typing fast\n\t        //but we are interested only in responses that correspond to the current view value\n\t        var onCurrentRequest = inputValue === modelCtrl.$viewValue;\n\t        if (onCurrentRequest && hasFocus) {\n\t          if (matches && matches.length > 0) {\n\t            scope.activeIdx = focusFirst ? 0 : -1;\n\t            isNoResultsSetter(originalScope, false);\n\t            scope.matches.length = 0;\n\t\n\t            //transform labels\n\t            for (var i = 0; i < matches.length; i++) {\n\t              locals[parserResult.itemName] = matches[i];\n\t              scope.matches.push({\n\t                id: getMatchId(i),\n\t                label: parserResult.viewMapper(scope, locals),\n\t                model: matches[i]\n\t              });\n\t            }\n\t\n\t            scope.query = inputValue;\n\t            //position pop-up with matches - we need to re-calculate its position each time we are opening a window\n\t            //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page\n\t            //due to other elements being rendered\n\t            recalculatePosition();\n\t\n\t            element.attr('aria-expanded', true);\n\t\n\t            //Select the single remaining option if user input matches\n\t            if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {\n\t              if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {\n\t                $$debounce(function() {\n\t                  scope.select(0, evt);\n\t                }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);\n\t              } else {\n\t                scope.select(0, evt);\n\t              }\n\t            }\n\t\n\t            if (showHint) {\n\t              var firstLabel = scope.matches[0].label;\n\t              if (angular.isString(inputValue) &&\n\t                inputValue.length > 0 &&\n\t                firstLabel.slice(0, inputValue.length).toUpperCase() === inputValue.toUpperCase()) {\n\t                hintInputElem.val(inputValue + firstLabel.slice(inputValue.length));\n\t              } else {\n\t                hintInputElem.val('');\n\t              }\n\t            }\n\t          } else {\n\t            resetMatches();\n\t            isNoResultsSetter(originalScope, true);\n\t          }\n\t        }\n\t        if (onCurrentRequest) {\n\t          isLoadingSetter(originalScope, false);\n\t        }\n\t      }, function() {\n\t        resetMatches();\n\t        isLoadingSetter(originalScope, false);\n\t        isNoResultsSetter(originalScope, true);\n\t      });\n\t    };\n\t\n\t    // bind events only if appendToBody params exist - performance feature\n\t    if (appendToBody) {\n\t      angular.element($window).on('resize', fireRecalculating);\n\t      $document.find('body').on('scroll', fireRecalculating);\n\t    }\n\t\n\t    // Declare the debounced function outside recalculating for\n\t    // proper debouncing\n\t    var debouncedRecalculate = $$debounce(function() {\n\t      // if popup is visible\n\t      if (scope.matches.length) {\n\t        recalculatePosition();\n\t      }\n\t\n\t      scope.moveInProgress = false;\n\t    }, eventDebounceTime);\n\t\n\t    // Default progress type\n\t    scope.moveInProgress = false;\n\t\n\t    function fireRecalculating() {\n\t      if (!scope.moveInProgress) {\n\t        scope.moveInProgress = true;\n\t        scope.$digest();\n\t      }\n\t\n\t      debouncedRecalculate();\n\t    }\n\t\n\t    // recalculate actual position and set new values to scope\n\t    // after digest loop is popup in right position\n\t    function recalculatePosition() {\n\t      scope.position = appendToBody ? $position.offset(element) : $position.position(element);\n\t      scope.position.top += element.prop('offsetHeight');\n\t    }\n\t\n\t    //we need to propagate user's query so we can higlight matches\n\t    scope.query = undefined;\n\t\n\t    //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later\n\t    var timeoutPromise;\n\t\n\t    var scheduleSearchWithTimeout = function(inputValue) {\n\t      timeoutPromise = $timeout(function() {\n\t        getMatchesAsync(inputValue);\n\t      }, waitTime);\n\t    };\n\t\n\t    var cancelPreviousTimeout = function() {\n\t      if (timeoutPromise) {\n\t        $timeout.cancel(timeoutPromise);\n\t      }\n\t    };\n\t\n\t    resetMatches();\n\t\n\t    scope.assignIsOpen = function (isOpen) {\n\t      isOpenSetter(originalScope, isOpen);\n\t    };\n\t\n\t    scope.select = function(activeIdx, evt) {\n\t      //called from within the $digest() cycle\n\t      var locals = {};\n\t      var model, item;\n\t\n\t      selected = true;\n\t      locals[parserResult.itemName] = item = scope.matches[activeIdx].model;\n\t      model = parserResult.modelMapper(originalScope, locals);\n\t      $setModelValue(originalScope, model);\n\t      modelCtrl.$setValidity('editable', true);\n\t      modelCtrl.$setValidity('parse', true);\n\t\n\t      onSelectCallback(originalScope, {\n\t        $item: item,\n\t        $model: model,\n\t        $label: parserResult.viewMapper(originalScope, locals),\n\t        $event: evt\n\t      });\n\t\n\t      resetMatches();\n\t\n\t      //return focus to the input element if a match was selected via a mouse click event\n\t      // use timeout to avoid $rootScope:inprog error\n\t      if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {\n\t        $timeout(function() { element[0].focus(); }, 0, false);\n\t      }\n\t    };\n\t\n\t    //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)\n\t    element.on('keydown', function(evt) {\n\t      //typeahead is open and an \"interesting\" key was pressed\n\t      if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {\n\t        return;\n\t      }\n\t\n\t      var shouldSelect = isSelectEvent(originalScope, {$event: evt});\n\t\n\t      /**\n\t       * if there's nothing selected (i.e. focusFirst) and enter or tab is hit\n\t       * or\n\t       * shift + tab is pressed to bring focus to the previous element\n\t       * then clear the results\n\t       */\n\t      if (scope.activeIdx === -1 && shouldSelect || evt.which === 9 && !!evt.shiftKey) {\n\t        resetMatches();\n\t        scope.$digest();\n\t        return;\n\t      }\n\t\n\t      evt.preventDefault();\n\t      var target;\n\t      switch (evt.which) {\n\t        case 27: // escape\n\t          evt.stopPropagation();\n\t\n\t          resetMatches();\n\t          originalScope.$digest();\n\t          break;\n\t        case 38: // up arrow\n\t          scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;\n\t          scope.$digest();\n\t          target = popUpEl.find('li')[scope.activeIdx];\n\t          target.parentNode.scrollTop = target.offsetTop;\n\t          break;\n\t        case 40: // down arrow\n\t          scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;\n\t          scope.$digest();\n\t          target = popUpEl.find('li')[scope.activeIdx];\n\t          target.parentNode.scrollTop = target.offsetTop;\n\t          break;\n\t        default:\n\t          if (shouldSelect) {\n\t            scope.$apply(function() {\n\t              if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {\n\t                $$debounce(function() {\n\t                  scope.select(scope.activeIdx, evt);\n\t                }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);\n\t              } else {\n\t                scope.select(scope.activeIdx, evt);\n\t              }\n\t            });\n\t          }\n\t      }\n\t    });\n\t\n\t    element.bind('focus', function (evt) {\n\t      hasFocus = true;\n\t      if (minLength === 0 && !modelCtrl.$viewValue) {\n\t        $timeout(function() {\n\t          getMatchesAsync(modelCtrl.$viewValue, evt);\n\t        }, 0);\n\t      }\n\t    });\n\t\n\t    element.bind('blur', function(evt) {\n\t      if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {\n\t        selected = true;\n\t        scope.$apply(function() {\n\t          if (angular.isObject(scope.debounceUpdate) && angular.isNumber(scope.debounceUpdate.blur)) {\n\t            $$debounce(function() {\n\t              scope.select(scope.activeIdx, evt);\n\t            }, scope.debounceUpdate.blur);\n\t          } else {\n\t            scope.select(scope.activeIdx, evt);\n\t          }\n\t        });\n\t      }\n\t      if (!isEditable && modelCtrl.$error.editable) {\n\t        modelCtrl.$setViewValue();\n\t        // Reset validity as we are clearing\n\t        modelCtrl.$setValidity('editable', true);\n\t        modelCtrl.$setValidity('parse', true);\n\t        element.val('');\n\t      }\n\t      hasFocus = false;\n\t      selected = false;\n\t    });\n\t\n\t    // Keep reference to click handler to unbind it.\n\t    var dismissClickHandler = function(evt) {\n\t      // Issue #3973\n\t      // Firefox treats right click as a click on document\n\t      if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {\n\t        resetMatches();\n\t        if (!$rootScope.$$phase) {\n\t          originalScope.$digest();\n\t        }\n\t      }\n\t    };\n\t\n\t    $document.on('click', dismissClickHandler);\n\t\n\t    originalScope.$on('$destroy', function() {\n\t      $document.off('click', dismissClickHandler);\n\t      if (appendToBody || appendTo) {\n\t        $popup.remove();\n\t      }\n\t\n\t      if (appendToBody) {\n\t        angular.element($window).off('resize', fireRecalculating);\n\t        $document.find('body').off('scroll', fireRecalculating);\n\t      }\n\t      // Prevent jQuery cache memory leak\n\t      popUpEl.remove();\n\t\n\t      if (showHint) {\n\t          inputsContainer.remove();\n\t      }\n\t    });\n\t\n\t    var $popup = $compile(popUpEl)(scope);\n\t\n\t    if (appendToBody) {\n\t      $document.find('body').append($popup);\n\t    } else if (appendTo) {\n\t      angular.element(appendTo).eq(0).append($popup);\n\t    } else {\n\t      element.after($popup);\n\t    }\n\t\n\t    this.init = function(_modelCtrl, _ngModelOptions) {\n\t      modelCtrl = _modelCtrl;\n\t      ngModelOptions = _ngModelOptions;\n\t\n\t      scope.debounceUpdate = modelCtrl.$options && $parse(modelCtrl.$options.debounce)(originalScope);\n\t\n\t      //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM\n\t      //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue\n\t      modelCtrl.$parsers.unshift(function(inputValue) {\n\t        hasFocus = true;\n\t\n\t        if (minLength === 0 || inputValue && inputValue.length >= minLength) {\n\t          if (waitTime > 0) {\n\t            cancelPreviousTimeout();\n\t            scheduleSearchWithTimeout(inputValue);\n\t          } else {\n\t            getMatchesAsync(inputValue);\n\t          }\n\t        } else {\n\t          isLoadingSetter(originalScope, false);\n\t          cancelPreviousTimeout();\n\t          resetMatches();\n\t        }\n\t\n\t        if (isEditable) {\n\t          return inputValue;\n\t        }\n\t\n\t        if (!inputValue) {\n\t          // Reset in case user had typed something previously.\n\t          modelCtrl.$setValidity('editable', true);\n\t          return null;\n\t        }\n\t\n\t        modelCtrl.$setValidity('editable', false);\n\t        return undefined;\n\t      });\n\t\n\t      modelCtrl.$formatters.push(function(modelValue) {\n\t        var candidateViewValue, emptyViewValue;\n\t        var locals = {};\n\t\n\t        // The validity may be set to false via $parsers (see above) if\n\t        // the model is restricted to selected values. If the model\n\t        // is set manually it is considered to be valid.\n\t        if (!isEditable) {\n\t          modelCtrl.$setValidity('editable', true);\n\t        }\n\t\n\t        if (inputFormatter) {\n\t          locals.$model = modelValue;\n\t          return inputFormatter(originalScope, locals);\n\t        }\n\t\n\t        //it might happen that we don't have enough info to properly render input value\n\t        //we need to check for this situation and simply return model value if we can't apply custom formatting\n\t        locals[parserResult.itemName] = modelValue;\n\t        candidateViewValue = parserResult.viewMapper(originalScope, locals);\n\t        locals[parserResult.itemName] = undefined;\n\t        emptyViewValue = parserResult.viewMapper(originalScope, locals);\n\t\n\t        return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;\n\t      });\n\t    };\n\t  }])\n\t\n\t  .directive('uibTypeahead', function() {\n\t    return {\n\t      controller: 'UibTypeaheadController',\n\t      require: ['ngModel', '^?ngModelOptions', 'uibTypeahead'],\n\t      link: function(originalScope, element, attrs, ctrls) {\n\t        ctrls[2].init(ctrls[0], ctrls[1]);\n\t      }\n\t    };\n\t  })\n\t\n\t  .directive('uibTypeaheadPopup', ['$$debounce', function($$debounce) {\n\t    return {\n\t      scope: {\n\t        matches: '=',\n\t        query: '=',\n\t        active: '=',\n\t        position: '&',\n\t        moveInProgress: '=',\n\t        select: '&',\n\t        assignIsOpen: '&',\n\t        debounce: '&'\n\t      },\n\t      replace: true,\n\t      templateUrl: function(element, attrs) {\n\t        return attrs.popupTemplateUrl || 'uib/template/typeahead/typeahead-popup.html';\n\t      },\n\t      link: function(scope, element, attrs) {\n\t        scope.templateUrl = attrs.templateUrl;\n\t\n\t        scope.isOpen = function() {\n\t          var isDropdownOpen = scope.matches.length > 0;\n\t          scope.assignIsOpen({ isOpen: isDropdownOpen });\n\t          return isDropdownOpen;\n\t        };\n\t\n\t        scope.isActive = function(matchIdx) {\n\t          return scope.active === matchIdx;\n\t        };\n\t\n\t        scope.selectActive = function(matchIdx) {\n\t          scope.active = matchIdx;\n\t        };\n\t\n\t        scope.selectMatch = function(activeIdx, evt) {\n\t          var debounce = scope.debounce();\n\t          if (angular.isNumber(debounce) || angular.isObject(debounce)) {\n\t            $$debounce(function() {\n\t              scope.select({activeIdx: activeIdx, evt: evt});\n\t            }, angular.isNumber(debounce) ? debounce : debounce['default']);\n\t          } else {\n\t            scope.select({activeIdx: activeIdx, evt: evt});\n\t          }\n\t        };\n\t      }\n\t    };\n\t  }])\n\t\n\t  .directive('uibTypeaheadMatch', ['$templateRequest', '$compile', '$parse', function($templateRequest, $compile, $parse) {\n\t    return {\n\t      scope: {\n\t        index: '=',\n\t        match: '=',\n\t        query: '='\n\t      },\n\t      link: function(scope, element, attrs) {\n\t        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'uib/template/typeahead/typeahead-match.html';\n\t        $templateRequest(tplUrl).then(function(tplContent) {\n\t          var tplEl = angular.element(tplContent.trim());\n\t          element.replaceWith(tplEl);\n\t          $compile(tplEl)(scope);\n\t        });\n\t      }\n\t    };\n\t  }])\n\t\n\t  .filter('uibTypeaheadHighlight', ['$sce', '$injector', '$log', function($sce, $injector, $log) {\n\t    var isSanitizePresent;\n\t    isSanitizePresent = $injector.has('$sanitize');\n\t\n\t    function escapeRegexp(queryToEscape) {\n\t      // Regex: capture the whole query string and replace it with the string that will be used to match\n\t      // the results, for example if the capture is \"a\" the result will be \\a\n\t      return queryToEscape.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n\t    }\n\t\n\t    function containsHtml(matchItem) {\n\t      return /<.*>/g.test(matchItem);\n\t    }\n\t\n\t    return function(matchItem, query) {\n\t      if (!isSanitizePresent && containsHtml(matchItem)) {\n\t        $log.warn('Unsafe use of typeahead please use ngSanitize'); // Warn the user about the danger\n\t      }\n\t      matchItem = query ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem; // Replaces the capture string with a the same string inside of a \"strong\" tag\n\t      if (!isSanitizePresent) {\n\t        matchItem = $sce.trustAsHtml(matchItem); // If $sanitize is not present we pack the string in a $sce object for the ng-bind-html directive\n\t      }\n\t      return matchItem;\n\t    };\n\t  }]);\n\t\n\tangular.module(\"uib/template/accordion/accordion-group.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/accordion/accordion-group.html\",\n\t    \"<div class=\\\"panel\\\" ng-class=\\\"panelClass || 'panel-default'\\\">\\n\" +\n\t    \"  <div role=\\\"tab\\\" id=\\\"{{::headingId}}\\\" aria-selected=\\\"{{isOpen}}\\\" class=\\\"panel-heading\\\" ng-keypress=\\\"toggleOpen($event)\\\">\\n\" +\n\t    \"    <h4 class=\\\"panel-title\\\">\\n\" +\n\t    \"      <a role=\\\"button\\\" data-toggle=\\\"collapse\\\" href aria-expanded=\\\"{{isOpen}}\\\" aria-controls=\\\"{{::panelId}}\\\" tabindex=\\\"0\\\" class=\\\"accordion-toggle\\\" ng-click=\\\"toggleOpen()\\\" uib-accordion-transclude=\\\"heading\\\"><span uib-accordion-header ng-class=\\\"{'text-muted': isDisabled}\\\">{{heading}}</span></a>\\n\" +\n\t    \"    </h4>\\n\" +\n\t    \"  </div>\\n\" +\n\t    \"  <div id=\\\"{{::panelId}}\\\" aria-labelledby=\\\"{{::headingId}}\\\" aria-hidden=\\\"{{!isOpen}}\\\" role=\\\"tabpanel\\\" class=\\\"panel-collapse collapse\\\" uib-collapse=\\\"!isOpen\\\">\\n\" +\n\t    \"    <div class=\\\"panel-body\\\" ng-transclude></div>\\n\" +\n\t    \"  </div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/accordion/accordion.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/accordion/accordion.html\",\n\t    \"<div role=\\\"tablist\\\" class=\\\"panel-group\\\" ng-transclude></div>\");\n\t}]);\n\t\n\tangular.module(\"uib/template/alert/alert.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/alert/alert.html\",\n\t    \"<div class=\\\"alert\\\" ng-class=\\\"['alert-' + (type || 'warning'), closeable ? 'alert-dismissible' : null]\\\" role=\\\"alert\\\">\\n\" +\n\t    \"    <button ng-show=\\\"closeable\\\" type=\\\"button\\\" class=\\\"close\\\" ng-click=\\\"close({$event: $event})\\\">\\n\" +\n\t    \"        <span aria-hidden=\\\"true\\\">&times;</span>\\n\" +\n\t    \"        <span class=\\\"sr-only\\\">Close</span>\\n\" +\n\t    \"    </button>\\n\" +\n\t    \"    <div ng-transclude></div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/carousel/carousel.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/carousel/carousel.html\",\n\t    \"<div ng-mouseenter=\\\"pause()\\\" ng-mouseleave=\\\"play()\\\" class=\\\"carousel\\\" ng-swipe-right=\\\"prev()\\\" ng-swipe-left=\\\"next()\\\">\\n\" +\n\t    \"  <div class=\\\"carousel-inner\\\" ng-transclude></div>\\n\" +\n\t    \"  <a role=\\\"button\\\" href class=\\\"left carousel-control\\\" ng-click=\\\"prev()\\\" ng-class=\\\"{ disabled: isPrevDisabled() }\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n\t    \"    <span aria-hidden=\\\"true\\\" class=\\\"glyphicon glyphicon-chevron-left\\\"></span>\\n\" +\n\t    \"    <span class=\\\"sr-only\\\">previous</span>\\n\" +\n\t    \"  </a>\\n\" +\n\t    \"  <a role=\\\"button\\\" href class=\\\"right carousel-control\\\" ng-click=\\\"next()\\\" ng-class=\\\"{ disabled: isNextDisabled() }\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n\t    \"    <span aria-hidden=\\\"true\\\" class=\\\"glyphicon glyphicon-chevron-right\\\"></span>\\n\" +\n\t    \"    <span class=\\\"sr-only\\\">next</span>\\n\" +\n\t    \"  </a>\\n\" +\n\t    \"  <ol class=\\\"carousel-indicators\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n\t    \"    <li ng-repeat=\\\"slide in slides | orderBy:indexOfSlide track by $index\\\" ng-class=\\\"{ active: isActive(slide) }\\\" ng-click=\\\"select(slide)\\\">\\n\" +\n\t    \"      <span class=\\\"sr-only\\\">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if=\\\"isActive(slide)\\\">, currently active</span></span>\\n\" +\n\t    \"    </li>\\n\" +\n\t    \"  </ol>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/carousel/slide.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/carousel/slide.html\",\n\t    \"<div ng-class=\\\"{\\n\" +\n\t    \"    'active': active\\n\" +\n\t    \"  }\\\" class=\\\"item text-center\\\" ng-transclude></div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/datepicker/datepicker.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/datepicker/datepicker.html\",\n\t    \"<div class=\\\"uib-datepicker\\\" ng-switch=\\\"datepickerMode\\\" role=\\\"application\\\" ng-keydown=\\\"keydown($event)\\\">\\n\" +\n\t    \"  <uib-daypicker ng-switch-when=\\\"day\\\" tabindex=\\\"0\\\"></uib-daypicker>\\n\" +\n\t    \"  <uib-monthpicker ng-switch-when=\\\"month\\\" tabindex=\\\"0\\\"></uib-monthpicker>\\n\" +\n\t    \"  <uib-yearpicker ng-switch-when=\\\"year\\\" tabindex=\\\"0\\\"></uib-yearpicker>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/datepicker/day.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/datepicker/day.html\",\n\t    \"<table class=\\\"uib-daypicker\\\" role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n\t    \"  <thead>\\n\" +\n\t    \"    <tr>\\n\" +\n\t    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left uib-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\n\t    \"      <th colspan=\\\"{{::5 + showWeeks}}\\\"><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm uib-title\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\"><strong>{{title}}</strong></button></th>\\n\" +\n\t    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right uib-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"    <tr>\\n\" +\n\t    \"      <th ng-if=\\\"showWeeks\\\" class=\\\"text-center\\\"></th>\\n\" +\n\t    \"      <th ng-repeat=\\\"label in ::labels track by $index\\\" class=\\\"text-center\\\"><small aria-label=\\\"{{::label.full}}\\\">{{::label.abbr}}</small></th>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </thead>\\n\" +\n\t    \"  <tbody>\\n\" +\n\t    \"    <tr class=\\\"uib-weeks\\\" ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\n\t    \"      <td ng-if=\\\"showWeeks\\\" class=\\\"text-center h6\\\"><em>{{ weekNumbers[$index] }}</em></td>\\n\" +\n\t    \"      <td ng-repeat=\\\"dt in row\\\" class=\\\"uib-day text-center\\\" role=\\\"gridcell\\\"\\n\" +\n\t    \"        id=\\\"{{::dt.uid}}\\\"\\n\" +\n\t    \"        ng-class=\\\"::dt.customClass\\\">\\n\" +\n\t    \"        <button type=\\\"button\\\" class=\\\"btn btn-default btn-sm\\\"\\n\" +\n\t    \"          uib-is-class=\\\"\\n\" +\n\t    \"            'btn-info' for selectedDt,\\n\" +\n\t    \"            'active' for activeDt\\n\" +\n\t    \"            on dt\\\"\\n\" +\n\t    \"          ng-click=\\\"select(dt.date)\\\"\\n\" +\n\t    \"          ng-disabled=\\\"::dt.disabled\\\"\\n\" +\n\t    \"          tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-muted': dt.secondary, 'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\n\t    \"      </td>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </tbody>\\n\" +\n\t    \"</table>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/datepicker/month.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/datepicker/month.html\",\n\t    \"<table class=\\\"uib-monthpicker\\\" role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n\t    \"  <thead>\\n\" +\n\t    \"    <tr>\\n\" +\n\t    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left uib-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\n\t    \"      <th><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm uib-title\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\"><strong>{{title}}</strong></button></th>\\n\" +\n\t    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right uib-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </thead>\\n\" +\n\t    \"  <tbody>\\n\" +\n\t    \"    <tr class=\\\"uib-months\\\" ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\n\t    \"      <td ng-repeat=\\\"dt in row\\\" class=\\\"uib-month text-center\\\" role=\\\"gridcell\\\"\\n\" +\n\t    \"        id=\\\"{{::dt.uid}}\\\"\\n\" +\n\t    \"        ng-class=\\\"::dt.customClass\\\">\\n\" +\n\t    \"        <button type=\\\"button\\\" class=\\\"btn btn-default\\\"\\n\" +\n\t    \"          uib-is-class=\\\"\\n\" +\n\t    \"            'btn-info' for selectedDt,\\n\" +\n\t    \"            'active' for activeDt\\n\" +\n\t    \"            on dt\\\"\\n\" +\n\t    \"          ng-click=\\\"select(dt.date)\\\"\\n\" +\n\t    \"          ng-disabled=\\\"::dt.disabled\\\"\\n\" +\n\t    \"          tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\n\t    \"      </td>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </tbody>\\n\" +\n\t    \"</table>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/datepicker/year.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/datepicker/year.html\",\n\t    \"<table class=\\\"uib-yearpicker\\\" role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n\t    \"  <thead>\\n\" +\n\t    \"    <tr>\\n\" +\n\t    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left uib-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\n\t    \"      <th colspan=\\\"{{::columns - 2}}\\\"><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm uib-title\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\"><strong>{{title}}</strong></button></th>\\n\" +\n\t    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right uib-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </thead>\\n\" +\n\t    \"  <tbody>\\n\" +\n\t    \"    <tr class=\\\"uib-years\\\" ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\n\t    \"      <td ng-repeat=\\\"dt in row\\\" class=\\\"uib-year text-center\\\" role=\\\"gridcell\\\"\\n\" +\n\t    \"        id=\\\"{{::dt.uid}}\\\"\\n\" +\n\t    \"        ng-class=\\\"::dt.customClass\\\">\\n\" +\n\t    \"        <button type=\\\"button\\\" class=\\\"btn btn-default\\\"\\n\" +\n\t    \"          uib-is-class=\\\"\\n\" +\n\t    \"            'btn-info' for selectedDt,\\n\" +\n\t    \"            'active' for activeDt\\n\" +\n\t    \"            on dt\\\"\\n\" +\n\t    \"          ng-click=\\\"select(dt.date)\\\"\\n\" +\n\t    \"          ng-disabled=\\\"::dt.disabled\\\"\\n\" +\n\t    \"          tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\n\t    \"      </td>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </tbody>\\n\" +\n\t    \"</table>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/datepickerPopup/popup.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/datepickerPopup/popup.html\",\n\t    \"<div>\\n\" +\n\t    \"  <ul class=\\\"uib-datepicker-popup dropdown-menu uib-position-measure\\\" dropdown-nested ng-if=\\\"isOpen\\\" ng-keydown=\\\"keydown($event)\\\" ng-click=\\\"$event.stopPropagation()\\\">\\n\" +\n\t    \"    <li ng-transclude></li>\\n\" +\n\t    \"    <li ng-if=\\\"showButtonBar\\\" class=\\\"uib-button-bar\\\">\\n\" +\n\t    \"      <span class=\\\"btn-group pull-left\\\">\\n\" +\n\t    \"        <button type=\\\"button\\\" class=\\\"btn btn-sm btn-info uib-datepicker-current\\\" ng-click=\\\"select('today', $event)\\\" ng-disabled=\\\"isDisabled('today')\\\">{{ getText('current') }}</button>\\n\" +\n\t    \"        <button type=\\\"button\\\" class=\\\"btn btn-sm btn-danger uib-clear\\\" ng-click=\\\"select(null, $event)\\\">{{ getText('clear') }}</button>\\n\" +\n\t    \"      </span>\\n\" +\n\t    \"      <button type=\\\"button\\\" class=\\\"btn btn-sm btn-success pull-right uib-close\\\" ng-click=\\\"close($event)\\\">{{ getText('close') }}</button>\\n\" +\n\t    \"    </li>\\n\" +\n\t    \"  </ul>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/modal/backdrop.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/modal/backdrop.html\",\n\t    \"<div class=\\\"modal-backdrop\\\"\\n\" +\n\t    \"     uib-modal-animation-class=\\\"fade\\\"\\n\" +\n\t    \"     modal-in-class=\\\"in\\\"\\n\" +\n\t    \"     ng-style=\\\"{'z-index': 1040 + (index && 1 || 0) + index*10}\\\"\\n\" +\n\t    \"></div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/modal/window.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/modal/window.html\",\n\t    \"<div modal-render=\\\"{{$isRendered}}\\\" tabindex=\\\"-1\\\" role=\\\"dialog\\\" class=\\\"modal\\\"\\n\" +\n\t    \"    uib-modal-animation-class=\\\"fade\\\"\\n\" +\n\t    \"    modal-in-class=\\\"in\\\"\\n\" +\n\t    \"    ng-style=\\\"{'z-index': 1050 + index*10, display: 'block'}\\\">\\n\" +\n\t    \"    <div class=\\\"modal-dialog {{size ? 'modal-' + size : ''}}\\\"><div class=\\\"modal-content\\\" uib-modal-transclude></div></div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/pager/pager.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/pager/pager.html\",\n\t    \"<ul class=\\\"pager\\\">\\n\" +\n\t    \"  <li ng-class=\\\"{disabled: noPrevious()||ngDisabled, previous: align}\\\"><a href ng-click=\\\"selectPage(page - 1, $event)\\\">{{::getText('previous')}}</a></li>\\n\" +\n\t    \"  <li ng-class=\\\"{disabled: noNext()||ngDisabled, next: align}\\\"><a href ng-click=\\\"selectPage(page + 1, $event)\\\">{{::getText('next')}}</a></li>\\n\" +\n\t    \"</ul>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/pagination/pagination.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/pagination/pagination.html\",\n\t    \"<ul class=\\\"pagination\\\">\\n\" +\n\t    \"  <li ng-if=\\\"::boundaryLinks\\\" ng-class=\\\"{disabled: noPrevious()||ngDisabled}\\\" class=\\\"pagination-first\\\"><a href ng-click=\\\"selectPage(1, $event)\\\">{{::getText('first')}}</a></li>\\n\" +\n\t    \"  <li ng-if=\\\"::directionLinks\\\" ng-class=\\\"{disabled: noPrevious()||ngDisabled}\\\" class=\\\"pagination-prev\\\"><a href ng-click=\\\"selectPage(page - 1, $event)\\\">{{::getText('previous')}}</a></li>\\n\" +\n\t    \"  <li ng-repeat=\\\"page in pages track by $index\\\" ng-class=\\\"{active: page.active,disabled: ngDisabled&&!page.active}\\\" class=\\\"pagination-page\\\"><a href ng-click=\\\"selectPage(page.number, $event)\\\">{{page.text}}</a></li>\\n\" +\n\t    \"  <li ng-if=\\\"::directionLinks\\\" ng-class=\\\"{disabled: noNext()||ngDisabled}\\\" class=\\\"pagination-next\\\"><a href ng-click=\\\"selectPage(page + 1, $event)\\\">{{::getText('next')}}</a></li>\\n\" +\n\t    \"  <li ng-if=\\\"::boundaryLinks\\\" ng-class=\\\"{disabled: noNext()||ngDisabled}\\\" class=\\\"pagination-last\\\"><a href ng-click=\\\"selectPage(totalPages, $event)\\\">{{::getText('last')}}</a></li>\\n\" +\n\t    \"</ul>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/tooltip/tooltip-html-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/tooltip/tooltip-html-popup.html\",\n\t    \"<div class=\\\"tooltip\\\"\\n\" +\n\t    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n\t    \"  uib-tooltip-classes\\n\" +\n\t    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n\t    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n\t    \"  <div class=\\\"tooltip-inner\\\" ng-bind-html=\\\"contentExp()\\\"></div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/tooltip/tooltip-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/tooltip/tooltip-popup.html\",\n\t    \"<div class=\\\"tooltip\\\"\\n\" +\n\t    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n\t    \"  uib-tooltip-classes\\n\" +\n\t    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n\t    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n\t    \"  <div class=\\\"tooltip-inner\\\" ng-bind=\\\"content\\\"></div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/tooltip/tooltip-template-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/tooltip/tooltip-template-popup.html\",\n\t    \"<div class=\\\"tooltip\\\"\\n\" +\n\t    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n\t    \"  uib-tooltip-classes\\n\" +\n\t    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n\t    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n\t    \"  <div class=\\\"tooltip-inner\\\"\\n\" +\n\t    \"    uib-tooltip-template-transclude=\\\"contentExp()\\\"\\n\" +\n\t    \"    tooltip-template-transclude-scope=\\\"originScope()\\\"></div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/popover/popover-html.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/popover/popover-html.html\",\n\t    \"<div class=\\\"popover\\\"\\n\" +\n\t    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n\t    \"  uib-tooltip-classes\\n\" +\n\t    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n\t    \"  <div class=\\\"arrow\\\"></div>\\n\" +\n\t    \"\\n\" +\n\t    \"  <div class=\\\"popover-inner\\\">\\n\" +\n\t    \"      <h3 class=\\\"popover-title\\\" ng-bind=\\\"uibTitle\\\" ng-if=\\\"uibTitle\\\"></h3>\\n\" +\n\t    \"      <div class=\\\"popover-content\\\" ng-bind-html=\\\"contentExp()\\\"></div>\\n\" +\n\t    \"  </div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/popover/popover-template.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/popover/popover-template.html\",\n\t    \"<div class=\\\"popover\\\"\\n\" +\n\t    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n\t    \"  uib-tooltip-classes\\n\" +\n\t    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n\t    \"  <div class=\\\"arrow\\\"></div>\\n\" +\n\t    \"\\n\" +\n\t    \"  <div class=\\\"popover-inner\\\">\\n\" +\n\t    \"      <h3 class=\\\"popover-title\\\" ng-bind=\\\"uibTitle\\\" ng-if=\\\"uibTitle\\\"></h3>\\n\" +\n\t    \"      <div class=\\\"popover-content\\\"\\n\" +\n\t    \"        uib-tooltip-template-transclude=\\\"contentExp()\\\"\\n\" +\n\t    \"        tooltip-template-transclude-scope=\\\"originScope()\\\"></div>\\n\" +\n\t    \"  </div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/popover/popover.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/popover/popover.html\",\n\t    \"<div class=\\\"popover\\\"\\n\" +\n\t    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n\t    \"  uib-tooltip-classes\\n\" +\n\t    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n\t    \"  <div class=\\\"arrow\\\"></div>\\n\" +\n\t    \"\\n\" +\n\t    \"  <div class=\\\"popover-inner\\\">\\n\" +\n\t    \"      <h3 class=\\\"popover-title\\\" ng-bind=\\\"uibTitle\\\" ng-if=\\\"uibTitle\\\"></h3>\\n\" +\n\t    \"      <div class=\\\"popover-content\\\" ng-bind=\\\"content\\\"></div>\\n\" +\n\t    \"  </div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/progressbar/bar.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/progressbar/bar.html\",\n\t    \"<div class=\\\"progress-bar\\\" ng-class=\\\"type && 'progress-bar-' + type\\\" role=\\\"progressbar\\\" aria-valuenow=\\\"{{value}}\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{max}}\\\" ng-style=\\\"{width: (percent < 100 ? percent : 100) + '%'}\\\" aria-valuetext=\\\"{{percent | number:0}}%\\\" aria-labelledby=\\\"{{::title}}\\\" ng-transclude></div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/progressbar/progress.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/progressbar/progress.html\",\n\t    \"<div class=\\\"progress\\\" ng-transclude aria-labelledby=\\\"{{::title}}\\\"></div>\");\n\t}]);\n\t\n\tangular.module(\"uib/template/progressbar/progressbar.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/progressbar/progressbar.html\",\n\t    \"<div class=\\\"progress\\\">\\n\" +\n\t    \"  <div class=\\\"progress-bar\\\" ng-class=\\\"type && 'progress-bar-' + type\\\" role=\\\"progressbar\\\" aria-valuenow=\\\"{{value}}\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{max}}\\\" ng-style=\\\"{width: (percent < 100 ? percent : 100) + '%'}\\\" aria-valuetext=\\\"{{percent | number:0}}%\\\" aria-labelledby=\\\"{{::title}}\\\" ng-transclude></div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/rating/rating.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/rating/rating.html\",\n\t    \"<span ng-mouseleave=\\\"reset()\\\" ng-keydown=\\\"onKeydown($event)\\\" tabindex=\\\"0\\\" role=\\\"slider\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{range.length}}\\\" aria-valuenow=\\\"{{value}}\\\" aria-valuetext=\\\"{{title}}\\\">\\n\" +\n\t    \"    <span ng-repeat-start=\\\"r in range track by $index\\\" class=\\\"sr-only\\\">({{ $index < value ? '*' : ' ' }})</span>\\n\" +\n\t    \"    <i ng-repeat-end ng-mouseenter=\\\"enter($index + 1)\\\" ng-click=\\\"rate($index + 1)\\\" class=\\\"glyphicon\\\" ng-class=\\\"$index < value && (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\\\" ng-attr-title=\\\"{{r.title}}\\\"></i>\\n\" +\n\t    \"</span>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/tabs/tab.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/tabs/tab.html\",\n\t    \"<li ng-class=\\\"[{active: active, disabled: disabled}, classes]\\\" class=\\\"uib-tab nav-item\\\">\\n\" +\n\t    \"  <a href ng-click=\\\"select($event)\\\" class=\\\"nav-link\\\" uib-tab-heading-transclude>{{heading}}</a>\\n\" +\n\t    \"</li>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/tabs/tabset.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/tabs/tabset.html\",\n\t    \"<div>\\n\" +\n\t    \"  <ul class=\\\"nav nav-{{tabset.type || 'tabs'}}\\\" ng-class=\\\"{'nav-stacked': vertical, 'nav-justified': justified}\\\" ng-transclude></ul>\\n\" +\n\t    \"  <div class=\\\"tab-content\\\">\\n\" +\n\t    \"    <div class=\\\"tab-pane\\\"\\n\" +\n\t    \"         ng-repeat=\\\"tab in tabset.tabs\\\"\\n\" +\n\t    \"         ng-class=\\\"{active: tabset.active === tab.index}\\\"\\n\" +\n\t    \"         uib-tab-content-transclude=\\\"tab\\\">\\n\" +\n\t    \"    </div>\\n\" +\n\t    \"  </div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/timepicker/timepicker.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/timepicker/timepicker.html\",\n\t    \"<table class=\\\"uib-timepicker\\\">\\n\" +\n\t    \"  <tbody>\\n\" +\n\t    \"    <tr class=\\\"text-center\\\" ng-show=\\\"::showSpinners\\\">\\n\" +\n\t    \"      <td class=\\\"uib-increment hours\\\"><a ng-click=\\\"incrementHours()\\\" ng-class=\\\"{disabled: noIncrementHours()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noIncrementHours()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-up\\\"></span></a></td>\\n\" +\n\t    \"      <td>&nbsp;</td>\\n\" +\n\t    \"      <td class=\\\"uib-increment minutes\\\"><a ng-click=\\\"incrementMinutes()\\\" ng-class=\\\"{disabled: noIncrementMinutes()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noIncrementMinutes()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-up\\\"></span></a></td>\\n\" +\n\t    \"      <td ng-show=\\\"showSeconds\\\">&nbsp;</td>\\n\" +\n\t    \"      <td ng-show=\\\"showSeconds\\\" class=\\\"uib-increment seconds\\\"><a ng-click=\\\"incrementSeconds()\\\" ng-class=\\\"{disabled: noIncrementSeconds()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noIncrementSeconds()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-up\\\"></span></a></td>\\n\" +\n\t    \"      <td ng-show=\\\"showMeridian\\\"></td>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"    <tr>\\n\" +\n\t    \"      <td class=\\\"form-group uib-time hours\\\" ng-class=\\\"{'has-error': invalidHours}\\\">\\n\" +\n\t    \"        <input type=\\\"text\\\" placeholder=\\\"HH\\\" ng-model=\\\"hours\\\" ng-change=\\\"updateHours()\\\" class=\\\"form-control text-center\\\" ng-readonly=\\\"::readonlyInput\\\" maxlength=\\\"2\\\" tabindex=\\\"{{::tabindex}}\\\" ng-disabled=\\\"noIncrementHours()\\\" ng-blur=\\\"blur()\\\">\\n\" +\n\t    \"      </td>\\n\" +\n\t    \"      <td class=\\\"uib-separator\\\">:</td>\\n\" +\n\t    \"      <td class=\\\"form-group uib-time minutes\\\" ng-class=\\\"{'has-error': invalidMinutes}\\\">\\n\" +\n\t    \"        <input type=\\\"text\\\" placeholder=\\\"MM\\\" ng-model=\\\"minutes\\\" ng-change=\\\"updateMinutes()\\\" class=\\\"form-control text-center\\\" ng-readonly=\\\"::readonlyInput\\\" maxlength=\\\"2\\\" tabindex=\\\"{{::tabindex}}\\\" ng-disabled=\\\"noIncrementMinutes()\\\" ng-blur=\\\"blur()\\\">\\n\" +\n\t    \"      </td>\\n\" +\n\t    \"      <td ng-show=\\\"showSeconds\\\" class=\\\"uib-separator\\\">:</td>\\n\" +\n\t    \"      <td class=\\\"form-group uib-time seconds\\\" ng-class=\\\"{'has-error': invalidSeconds}\\\" ng-show=\\\"showSeconds\\\">\\n\" +\n\t    \"        <input type=\\\"text\\\" placeholder=\\\"SS\\\" ng-model=\\\"seconds\\\" ng-change=\\\"updateSeconds()\\\" class=\\\"form-control text-center\\\" ng-readonly=\\\"readonlyInput\\\" maxlength=\\\"2\\\" tabindex=\\\"{{::tabindex}}\\\" ng-disabled=\\\"noIncrementSeconds()\\\" ng-blur=\\\"blur()\\\">\\n\" +\n\t    \"      </td>\\n\" +\n\t    \"      <td ng-show=\\\"showMeridian\\\" class=\\\"uib-time am-pm\\\"><button type=\\\"button\\\" ng-class=\\\"{disabled: noToggleMeridian()}\\\" class=\\\"btn btn-default text-center\\\" ng-click=\\\"toggleMeridian()\\\" ng-disabled=\\\"noToggleMeridian()\\\" tabindex=\\\"{{::tabindex}}\\\">{{meridian}}</button></td>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"    <tr class=\\\"text-center\\\" ng-show=\\\"::showSpinners\\\">\\n\" +\n\t    \"      <td class=\\\"uib-decrement hours\\\"><a ng-click=\\\"decrementHours()\\\" ng-class=\\\"{disabled: noDecrementHours()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noDecrementHours()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-down\\\"></span></a></td>\\n\" +\n\t    \"      <td>&nbsp;</td>\\n\" +\n\t    \"      <td class=\\\"uib-decrement minutes\\\"><a ng-click=\\\"decrementMinutes()\\\" ng-class=\\\"{disabled: noDecrementMinutes()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noDecrementMinutes()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-down\\\"></span></a></td>\\n\" +\n\t    \"      <td ng-show=\\\"showSeconds\\\">&nbsp;</td>\\n\" +\n\t    \"      <td ng-show=\\\"showSeconds\\\" class=\\\"uib-decrement seconds\\\"><a ng-click=\\\"decrementSeconds()\\\" ng-class=\\\"{disabled: noDecrementSeconds()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noDecrementSeconds()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-down\\\"></span></a></td>\\n\" +\n\t    \"      <td ng-show=\\\"showMeridian\\\"></td>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </tbody>\\n\" +\n\t    \"</table>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/typeahead/typeahead-match.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/typeahead/typeahead-match.html\",\n\t    \"<a href\\n\" +\n\t    \"   tabindex=\\\"-1\\\"\\n\" +\n\t    \"   ng-bind-html=\\\"match.label | uibTypeaheadHighlight:query\\\"\\n\" +\n\t    \"   ng-attr-title=\\\"{{match.label}}\\\"></a>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/typeahead/typeahead-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/typeahead/typeahead-popup.html\",\n\t    \"<ul class=\\\"dropdown-menu\\\" ng-show=\\\"isOpen() && !moveInProgress\\\" ng-style=\\\"{top: position().top+'px', left: position().left+'px'}\\\" role=\\\"listbox\\\" aria-hidden=\\\"{{!isOpen()}}\\\">\\n\" +\n\t    \"    <li ng-repeat=\\\"match in matches track by $index\\\" ng-class=\\\"{active: isActive($index) }\\\" ng-mouseenter=\\\"selectActive($index)\\\" ng-click=\\\"selectMatch($index, $event)\\\" role=\\\"option\\\" id=\\\"{{::match.id}}\\\">\\n\" +\n\t    \"        <div uib-typeahead-match index=\\\"$index\\\" match=\\\"match\\\" query=\\\"query\\\" template-url=\\\"templateUrl\\\"></div>\\n\" +\n\t    \"    </li>\\n\" +\n\t    \"</ul>\\n\" +\n\t    \"\");\n\t}]);\n\tangular.module('ui.bootstrap.carousel').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibCarouselCss && angular.element(document).find('head').prepend('<style type=\"text/css\">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>'); angular.$$uibCarouselCss = true; });\n\tangular.module('ui.bootstrap.datepicker').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibDatepickerCss && angular.element(document).find('head').prepend('<style type=\"text/css\">.uib-datepicker .uib-title{width:100%;}.uib-day button,.uib-month button,.uib-year button{min-width:100%;}.uib-left,.uib-right{width:100%}</style>'); angular.$$uibDatepickerCss = true; });\n\tangular.module('ui.bootstrap.position').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibPositionCss && angular.element(document).find('head').prepend('<style type=\"text/css\">.uib-position-measure{display:block !important;visibility:hidden !important;position:absolute !important;top:-9999px !important;left:-9999px !important;}.uib-position-scrollbar-measure{position:absolute !important;top:-9999px !important;width:50px !important;height:50px !important;overflow:scroll !important;}.uib-position-body-scrollbar-measure{overflow:scroll !important;}</style>'); angular.$$uibPositionCss = true; });\n\tangular.module('ui.bootstrap.datepickerPopup').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibDatepickerpopupCss && angular.element(document).find('head').prepend('<style type=\"text/css\">.uib-datepicker-popup.dropdown-menu{display:block;float:none;margin:0;}.uib-button-bar{padding:10px 9px 2px;}</style>'); angular.$$uibDatepickerpopupCss = true; });\n\tangular.module('ui.bootstrap.tooltip').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibTooltipCss && angular.element(document).find('head').prepend('<style type=\"text/css\">[uib-tooltip-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-bottom > .tooltip-arrow,[uib-popover-popup].popover.top-left > .arrow,[uib-popover-popup].popover.top-right > .arrow,[uib-popover-popup].popover.bottom-left > .arrow,[uib-popover-popup].popover.bottom-right > .arrow,[uib-popover-popup].popover.left-top > .arrow,[uib-popover-popup].popover.left-bottom > .arrow,[uib-popover-popup].popover.right-top > .arrow,[uib-popover-popup].popover.right-bottom > .arrow,[uib-popover-html-popup].popover.top-left > .arrow,[uib-popover-html-popup].popover.top-right > .arrow,[uib-popover-html-popup].popover.bottom-left > .arrow,[uib-popover-html-popup].popover.bottom-right > .arrow,[uib-popover-html-popup].popover.left-top > .arrow,[uib-popover-html-popup].popover.left-bottom > .arrow,[uib-popover-html-popup].popover.right-top > .arrow,[uib-popover-html-popup].popover.right-bottom > .arrow,[uib-popover-template-popup].popover.top-left > .arrow,[uib-popover-template-popup].popover.top-right > .arrow,[uib-popover-template-popup].popover.bottom-left > .arrow,[uib-popover-template-popup].popover.bottom-right > .arrow,[uib-popover-template-popup].popover.left-top > .arrow,[uib-popover-template-popup].popover.left-bottom > .arrow,[uib-popover-template-popup].popover.right-top > .arrow,[uib-popover-template-popup].popover.right-bottom > .arrow{top:auto;bottom:auto;left:auto;right:auto;margin:0;}[uib-popover-popup].popover,[uib-popover-html-popup].popover,[uib-popover-template-popup].popover{display:block !important;}</style>'); angular.$$uibTooltipCss = true; });\n\tangular.module('ui.bootstrap.timepicker').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibTimepickerCss && angular.element(document).find('head').prepend('<style type=\"text/css\">.uib-time input{width:50px;}</style>'); angular.$$uibTimepickerCss = true; });\n\tangular.module('ui.bootstrap.typeahead').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibTypeaheadCss && angular.element(document).find('head').prepend('<style type=\"text/css\">[uib-typeahead-popup].dropdown-menu{display:block;}</style>'); angular.$$uibTypeaheadCss = true; });\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\texports.default = routes;\n\tfunction routes($stateProvider) {\n\t\t$stateProvider.state('weather', {\n\t\t\turl: '/',\n\t\t\ttemplate: __webpack_require__(10),\n\t\t\tcontroller: 'WeatherCtrl',\n\t\t\tcontrollerAs: 'weather'\n\t\t});\n\t}\n\t\n\troutes.$inject = ['$stateProvider'];\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div> {{weather.forecast.query.results.channel.item.forecast}} </div> <p>Select a tab by setting active binding to true:</p> <p> <button type=button class=\\\"btn btn-default btn-sm\\\" ng-click=\\\"active = 1\\\">Select second tab</button> <button type=button class=\\\"btn btn-default btn-sm\\\" ng-click=\\\"active = 2\\\">Select third tab</button> </p> <hr/> <uib-tabset active=active> <uib-tab index=0 heading=\\\"Static title\\\">Static content</uib-tab> <uib-tab index=\\\"$index + 1\\\" ng-repeat=\\\"tab in weather.tabs\\\" heading={{tab.title}} disable=tab.disabled> {{tab.content}} </uib-tab> </uib-tabset> <hr/>\";\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar WeatherCtrl = function WeatherCtrl(apiservice) {\n\t\tvar _this = this;\n\t\n\t\t_classCallCheck(this, WeatherCtrl);\n\t\n\t\tthis.tabs = [{ title: 'Dynamic Title 1', content: 'Dynamic content 1' }, { title: 'Dynamic Title 2', content: 'Dynamic content 2', disabled: true }];\n\t\tthis.woeid = '9807';\n\t\tapiservice.getWeather(this.woeid).then(function (result) {\n\t\t\treturn _this.forecast = result.data;\n\t\t});\n\t};\n\t\n\texports.default = WeatherCtrl;\n\t\n\t\n\tWeatherCtrl.$inject = ['apiservice'];\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar apiservice = function () {\n\t\tfunction apiservice($http) {\n\t\t\t_classCallCheck(this, apiservice);\n\t\n\t\t\tthis.$http = $http;\n\t\n\t\t\tthis.GEOCODE_ENDPOINT = \"http://where.yahooapis.com/geocode\";\n\t\t\tthis.YAHOO_GEO_APP_ID = \"v6wFWp30\";\n\t\t\tthis.APP_ID = \"&appid=\" + this.YAHOO_GEO_APP_ID;\n\t\t\tthis.LOCATION = \"?location=\";\n\t\t\tthis.FLAGS = \"&flags=J&gflags=R\";\n\t\n\t\t\t//http://query.yahooapis.com/v1/public/yql?q=select item from weather.forecast where location=\"48907\"&format=json\n\t\t\t//select * from weather.forecast where woeid in (select woeid from geo.places(1) location=\"48907\"&format=json)\n\t\t\t//https://query.yahooapis.com/v1/public/yql?q=select\n\t\t\tthis.FORECAST_ENDPOINT = \"http://query.yahooapis.com/v1/public/yql?q=\";\n\t\t\tthis.FORECAST_YQL_OPEN = \"select * from weather.forecast where woeid='\";\n\t\t\tthis.FORECAST_YQL_CLOSE = \"'&format=json\";\n\t\t}\n\t\n\t\t_createClass(apiservice, [{\n\t\t\tkey: \"getWeather\",\n\t\t\tvalue: function getWeather(woeid) {\n\t\t\t\tthis.woeid = woeid;\n\t\t\t\tthis.url = this.FORECAST_ENDPOINT + this.FORECAST_YQL_OPEN + this.woeid + this.FORECAST_YQL_CLOSE;\n\t\t\t\treturn this.$http.get(this.url);\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn apiservice;\n\t}();\n\t\n\texports.default = _angular2.default.module('services.apiservice', []).service('apiservice', apiservice).name;\n\t\n\t\n\tapiservice.$inject = ['$http'];\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = routing;\n\tfunction routing($urlRouterProvider, $locationProvider) {\n\t  $locationProvider.html5Mode(true);\n\t  $urlRouterProvider.otherwise('/');\n\t}\n\t\n\trouting.$inject = ['$urlRouterProvider', '$locationProvider'];\n\n/***/ }\n]);\n\n\n/** WEBPACK FOOTER **\n ** app.js\n **/","import angular from 'angular';\r\nimport uirouter from 'angular-ui-router';\r\n\r\nimport weather from './weather';\r\nimport routing from './index.config';\r\n\r\nangular.module('appNomin', [uirouter,weather])\r\n\t.config(routing);\n\n\n/** WEBPACK FOOTER **\n ** ./app/index.js\n **/","/**\n * State-based routing for AngularJS\n * @version v0.3.1\n * @link http://angular-ui.github.com/\n * @license MIT License, http://www.opensource.org/licenses/MIT\n */\n\n/* commonjs package manager support (eg componentjs) */\nif (typeof module !== \"undefined\" && typeof exports !== \"undefined\" && module.exports === exports){\n  module.exports = 'ui.router';\n}\n\n(function (window, angular, undefined) {\n/*jshint globalstrict:true*/\n/*global angular:false*/\n'use strict';\n\nvar isDefined = angular.isDefined,\n    isFunction = angular.isFunction,\n    isString = angular.isString,\n    isObject = angular.isObject,\n    isArray = angular.isArray,\n    forEach = angular.forEach,\n    extend = angular.extend,\n    copy = angular.copy,\n    toJson = angular.toJson;\n\nfunction inherit(parent, extra) {\n  return extend(new (extend(function() {}, { prototype: parent }))(), extra);\n}\n\nfunction merge(dst) {\n  forEach(arguments, function(obj) {\n    if (obj !== dst) {\n      forEach(obj, function(value, key) {\n        if (!dst.hasOwnProperty(key)) dst[key] = value;\n      });\n    }\n  });\n  return dst;\n}\n\n/**\n * Finds the common ancestor path between two states.\n *\n * @param {Object} first The first state.\n * @param {Object} second The second state.\n * @return {Array} Returns an array of state names in descending order, not including the root.\n */\nfunction ancestors(first, second) {\n  var path = [];\n\n  for (var n in first.path) {\n    if (first.path[n] !== second.path[n]) break;\n    path.push(first.path[n]);\n  }\n  return path;\n}\n\n/**\n * IE8-safe wrapper for `Object.keys()`.\n *\n * @param {Object} object A JavaScript object.\n * @return {Array} Returns the keys of the object as an array.\n */\nfunction objectKeys(object) {\n  if (Object.keys) {\n    return Object.keys(object);\n  }\n  var result = [];\n\n  forEach(object, function(val, key) {\n    result.push(key);\n  });\n  return result;\n}\n\n/**\n * IE8-safe wrapper for `Array.prototype.indexOf()`.\n *\n * @param {Array} array A JavaScript array.\n * @param {*} value A value to search the array for.\n * @return {Number} Returns the array index value of `value`, or `-1` if not present.\n */\nfunction indexOf(array, value) {\n  if (Array.prototype.indexOf) {\n    return array.indexOf(value, Number(arguments[2]) || 0);\n  }\n  var len = array.length >>> 0, from = Number(arguments[2]) || 0;\n  from = (from < 0) ? Math.ceil(from) : Math.floor(from);\n\n  if (from < 0) from += len;\n\n  for (; from < len; from++) {\n    if (from in array && array[from] === value) return from;\n  }\n  return -1;\n}\n\n/**\n * Merges a set of parameters with all parameters inherited between the common parents of the\n * current state and a given destination state.\n *\n * @param {Object} currentParams The value of the current state parameters ($stateParams).\n * @param {Object} newParams The set of parameters which will be composited with inherited params.\n * @param {Object} $current Internal definition of object representing the current state.\n * @param {Object} $to Internal definition of object representing state to transition to.\n */\nfunction inheritParams(currentParams, newParams, $current, $to) {\n  var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n\n  for (var i in parents) {\n    if (!parents[i] || !parents[i].params) continue;\n    parentParams = objectKeys(parents[i].params);\n    if (!parentParams.length) continue;\n\n    for (var j in parentParams) {\n      if (indexOf(inheritList, parentParams[j]) >= 0) continue;\n      inheritList.push(parentParams[j]);\n      inherited[parentParams[j]] = currentParams[parentParams[j]];\n    }\n  }\n  return extend({}, inherited, newParams);\n}\n\n/**\n * Performs a non-strict comparison of the subset of two objects, defined by a list of keys.\n *\n * @param {Object} a The first object.\n * @param {Object} b The second object.\n * @param {Array} keys The list of keys within each object to compare. If the list is empty or not specified,\n *                     it defaults to the list of keys in `a`.\n * @return {Boolean} Returns `true` if the keys match, otherwise `false`.\n */\nfunction equalForKeys(a, b, keys) {\n  if (!keys) {\n    keys = [];\n    for (var n in a) keys.push(n); // Used instead of Object.keys() for IE8 compatibility\n  }\n\n  for (var i=0; i<keys.length; i++) {\n    var k = keys[i];\n    if (a[k] != b[k]) return false; // Not '===', values aren't necessarily normalized\n  }\n  return true;\n}\n\n/**\n * Returns the subset of an object, based on a list of keys.\n *\n * @param {Array} keys\n * @param {Object} values\n * @return {Boolean} Returns a subset of `values`.\n */\nfunction filterByKeys(keys, values) {\n  var filtered = {};\n\n  forEach(keys, function (name) {\n    filtered[name] = values[name];\n  });\n  return filtered;\n}\n\n// like _.indexBy\n// when you know that your index values will be unique, or you want last-one-in to win\nfunction indexBy(array, propName) {\n  var result = {};\n  forEach(array, function(item) {\n    result[item[propName]] = item;\n  });\n  return result;\n}\n\n// extracted from underscore.js\n// Return a copy of the object only containing the whitelisted properties.\nfunction pick(obj) {\n  var copy = {};\n  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n  forEach(keys, function(key) {\n    if (key in obj) copy[key] = obj[key];\n  });\n  return copy;\n}\n\n// extracted from underscore.js\n// Return a copy of the object omitting the blacklisted properties.\nfunction omit(obj) {\n  var copy = {};\n  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n  for (var key in obj) {\n    if (indexOf(keys, key) == -1) copy[key] = obj[key];\n  }\n  return copy;\n}\n\nfunction pluck(collection, key) {\n  var result = isArray(collection) ? [] : {};\n\n  forEach(collection, function(val, i) {\n    result[i] = isFunction(key) ? key(val) : val[key];\n  });\n  return result;\n}\n\nfunction filter(collection, callback) {\n  var array = isArray(collection);\n  var result = array ? [] : {};\n  forEach(collection, function(val, i) {\n    if (callback(val, i)) {\n      result[array ? result.length : i] = val;\n    }\n  });\n  return result;\n}\n\nfunction map(collection, callback) {\n  var result = isArray(collection) ? [] : {};\n\n  forEach(collection, function(val, i) {\n    result[i] = callback(val, i);\n  });\n  return result;\n}\n\n/**\n * @ngdoc overview\n * @name ui.router.util\n *\n * @description\n * # ui.router.util sub-module\n *\n * This module is a dependency of other sub-modules. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n *\n */\nangular.module('ui.router.util', ['ng']);\n\n/**\n * @ngdoc overview\n * @name ui.router.router\n * \n * @requires ui.router.util\n *\n * @description\n * # ui.router.router sub-module\n *\n * This module is a dependency of other sub-modules. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n */\nangular.module('ui.router.router', ['ui.router.util']);\n\n/**\n * @ngdoc overview\n * @name ui.router.state\n * \n * @requires ui.router.router\n * @requires ui.router.util\n *\n * @description\n * # ui.router.state sub-module\n *\n * This module is a dependency of the main ui.router module. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n * \n */\nangular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);\n\n/**\n * @ngdoc overview\n * @name ui.router\n *\n * @requires ui.router.state\n *\n * @description\n * # ui.router\n * \n * ## The main module for ui.router \n * There are several sub-modules included with the ui.router module, however only this module is needed\n * as a dependency within your angular app. The other modules are for organization purposes. \n *\n * The modules are:\n * * ui.router - the main \"umbrella\" module\n * * ui.router.router - \n * \n * *You'll need to include **only** this module as the dependency within your angular app.*\n * \n * <pre>\n * <!doctype html>\n * <html ng-app=\"myApp\">\n * <head>\n *   <script src=\"js/angular.js\"></script>\n *   <!-- Include the ui-router script -->\n *   <script src=\"js/angular-ui-router.min.js\"></script>\n *   <script>\n *     // ...and add 'ui.router' as a dependency\n *     var myApp = angular.module('myApp', ['ui.router']);\n *   </script>\n * </head>\n * <body>\n * </body>\n * </html>\n * </pre>\n */\nangular.module('ui.router', ['ui.router.state']);\n\nangular.module('ui.router.compat', ['ui.router']);\n\n/**\n * @ngdoc object\n * @name ui.router.util.$resolve\n *\n * @requires $q\n * @requires $injector\n *\n * @description\n * Manages resolution of (acyclic) graphs of promises.\n */\n$Resolve.$inject = ['$q', '$injector'];\nfunction $Resolve(  $q,    $injector) {\n  \n  var VISIT_IN_PROGRESS = 1,\n      VISIT_DONE = 2,\n      NOTHING = {},\n      NO_DEPENDENCIES = [],\n      NO_LOCALS = NOTHING,\n      NO_PARENT = extend($q.when(NOTHING), { $$promises: NOTHING, $$values: NOTHING });\n  \n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$resolve#study\n   * @methodOf ui.router.util.$resolve\n   *\n   * @description\n   * Studies a set of invocables that are likely to be used multiple times.\n   * <pre>\n   * $resolve.study(invocables)(locals, parent, self)\n   * </pre>\n   * is equivalent to\n   * <pre>\n   * $resolve.resolve(invocables, locals, parent, self)\n   * </pre>\n   * but the former is more efficient (in fact `resolve` just calls `study` \n   * internally).\n   *\n   * @param {object} invocables Invocable objects\n   * @return {function} a function to pass in locals, parent and self\n   */\n  this.study = function (invocables) {\n    if (!isObject(invocables)) throw new Error(\"'invocables' must be an object\");\n    var invocableKeys = objectKeys(invocables || {});\n    \n    // Perform a topological sort of invocables to build an ordered plan\n    var plan = [], cycle = [], visited = {};\n    function visit(value, key) {\n      if (visited[key] === VISIT_DONE) return;\n      \n      cycle.push(key);\n      if (visited[key] === VISIT_IN_PROGRESS) {\n        cycle.splice(0, indexOf(cycle, key));\n        throw new Error(\"Cyclic dependency: \" + cycle.join(\" -> \"));\n      }\n      visited[key] = VISIT_IN_PROGRESS;\n      \n      if (isString(value)) {\n        plan.push(key, [ function() { return $injector.get(value); }], NO_DEPENDENCIES);\n      } else {\n        var params = $injector.annotate(value);\n        forEach(params, function (param) {\n          if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);\n        });\n        plan.push(key, value, params);\n      }\n      \n      cycle.pop();\n      visited[key] = VISIT_DONE;\n    }\n    forEach(invocables, visit);\n    invocables = cycle = visited = null; // plan is all that's required\n    \n    function isResolve(value) {\n      return isObject(value) && value.then && value.$$promises;\n    }\n    \n    return function (locals, parent, self) {\n      if (isResolve(locals) && self === undefined) {\n        self = parent; parent = locals; locals = null;\n      }\n      if (!locals) locals = NO_LOCALS;\n      else if (!isObject(locals)) {\n        throw new Error(\"'locals' must be an object\");\n      }       \n      if (!parent) parent = NO_PARENT;\n      else if (!isResolve(parent)) {\n        throw new Error(\"'parent' must be a promise returned by $resolve.resolve()\");\n      }\n      \n      // To complete the overall resolution, we have to wait for the parent\n      // promise and for the promise for each invokable in our plan.\n      var resolution = $q.defer(),\n          result = resolution.promise,\n          promises = result.$$promises = {},\n          values = extend({}, locals),\n          wait = 1 + plan.length/3,\n          merged = false;\n          \n      function done() {\n        // Merge parent values we haven't got yet and publish our own $$values\n        if (!--wait) {\n          if (!merged) merge(values, parent.$$values); \n          result.$$values = values;\n          result.$$promises = result.$$promises || true; // keep for isResolve()\n          delete result.$$inheritedValues;\n          resolution.resolve(values);\n        }\n      }\n      \n      function fail(reason) {\n        result.$$failure = reason;\n        resolution.reject(reason);\n      }\n\n      // Short-circuit if parent has already failed\n      if (isDefined(parent.$$failure)) {\n        fail(parent.$$failure);\n        return result;\n      }\n      \n      if (parent.$$inheritedValues) {\n        merge(values, omit(parent.$$inheritedValues, invocableKeys));\n      }\n\n      // Merge parent values if the parent has already resolved, or merge\n      // parent promises and wait if the parent resolve is still in progress.\n      extend(promises, parent.$$promises);\n      if (parent.$$values) {\n        merged = merge(values, omit(parent.$$values, invocableKeys));\n        result.$$inheritedValues = omit(parent.$$values, invocableKeys);\n        done();\n      } else {\n        if (parent.$$inheritedValues) {\n          result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);\n        }        \n        parent.then(done, fail);\n      }\n      \n      // Process each invocable in the plan, but ignore any where a local of the same name exists.\n      for (var i=0, ii=plan.length; i<ii; i+=3) {\n        if (locals.hasOwnProperty(plan[i])) done();\n        else invoke(plan[i], plan[i+1], plan[i+2]);\n      }\n      \n      function invoke(key, invocable, params) {\n        // Create a deferred for this invocation. Failures will propagate to the resolution as well.\n        var invocation = $q.defer(), waitParams = 0;\n        function onfailure(reason) {\n          invocation.reject(reason);\n          fail(reason);\n        }\n        // Wait for any parameter that we have a promise for (either from parent or from this\n        // resolve; in that case study() will have made sure it's ordered before us in the plan).\n        forEach(params, function (dep) {\n          if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {\n            waitParams++;\n            promises[dep].then(function (result) {\n              values[dep] = result;\n              if (!(--waitParams)) proceed();\n            }, onfailure);\n          }\n        });\n        if (!waitParams) proceed();\n        function proceed() {\n          if (isDefined(result.$$failure)) return;\n          try {\n            invocation.resolve($injector.invoke(invocable, self, values));\n            invocation.promise.then(function (result) {\n              values[key] = result;\n              done();\n            }, onfailure);\n          } catch (e) {\n            onfailure(e);\n          }\n        }\n        // Publish promise synchronously; invocations further down in the plan may depend on it.\n        promises[key] = invocation.promise;\n      }\n      \n      return result;\n    };\n  };\n  \n  /**\n   * @ngdoc function\n   * @name ui.router.util.$resolve#resolve\n   * @methodOf ui.router.util.$resolve\n   *\n   * @description\n   * Resolves a set of invocables. An invocable is a function to be invoked via \n   * `$injector.invoke()`, and can have an arbitrary number of dependencies. \n   * An invocable can either return a value directly,\n   * or a `$q` promise. If a promise is returned it will be resolved and the \n   * resulting value will be used instead. Dependencies of invocables are resolved \n   * (in this order of precedence)\n   *\n   * - from the specified `locals`\n   * - from another invocable that is part of this `$resolve` call\n   * - from an invocable that is inherited from a `parent` call to `$resolve` \n   *   (or recursively\n   * - from any ancestor `$resolve` of that parent).\n   *\n   * The return value of `$resolve` is a promise for an object that contains \n   * (in this order of precedence)\n   *\n   * - any `locals` (if specified)\n   * - the resolved return values of all injectables\n   * - any values inherited from a `parent` call to `$resolve` (if specified)\n   *\n   * The promise will resolve after the `parent` promise (if any) and all promises \n   * returned by injectables have been resolved. If any invocable \n   * (or `$injector.invoke`) throws an exception, or if a promise returned by an \n   * invocable is rejected, the `$resolve` promise is immediately rejected with the \n   * same error. A rejection of a `parent` promise (if specified) will likewise be \n   * propagated immediately. Once the `$resolve` promise has been rejected, no \n   * further invocables will be called.\n   * \n   * Cyclic dependencies between invocables are not permitted and will cause `$resolve`\n   * to throw an error. As a special case, an injectable can depend on a parameter \n   * with the same name as the injectable, which will be fulfilled from the `parent` \n   * injectable of the same name. This allows inherited values to be decorated. \n   * Note that in this case any other injectable in the same `$resolve` with the same\n   * dependency would see the decorated value, not the inherited value.\n   *\n   * Note that missing dependencies -- unlike cyclic dependencies -- will cause an \n   * (asynchronous) rejection of the `$resolve` promise rather than a (synchronous) \n   * exception.\n   *\n   * Invocables are invoked eagerly as soon as all dependencies are available. \n   * This is true even for dependencies inherited from a `parent` call to `$resolve`.\n   *\n   * As a special case, an invocable can be a string, in which case it is taken to \n   * be a service name to be passed to `$injector.get()`. This is supported primarily \n   * for backwards-compatibility with the `resolve` property of `$routeProvider` \n   * routes.\n   *\n   * @param {object} invocables functions to invoke or \n   * `$injector` services to fetch.\n   * @param {object} locals  values to make available to the injectables\n   * @param {object} parent  a promise returned by another call to `$resolve`.\n   * @param {object} self  the `this` for the invoked methods\n   * @return {object} Promise for an object that contains the resolved return value\n   * of all invocables, as well as any inherited and local values.\n   */\n  this.resolve = function (invocables, locals, parent, self) {\n    return this.study(invocables)(locals, parent, self);\n  };\n}\n\nangular.module('ui.router.util').service('$resolve', $Resolve);\n\n\n/**\n * @ngdoc object\n * @name ui.router.util.$templateFactory\n *\n * @requires $http\n * @requires $templateCache\n * @requires $injector\n *\n * @description\n * Service. Manages loading of templates.\n */\n$TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];\nfunction $TemplateFactory(  $http,   $templateCache,   $injector) {\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromConfig\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template from a configuration object. \n   *\n   * @param {object} config Configuration object for which to load a template. \n   * The following properties are search in the specified order, and the first one \n   * that is defined is used to create the template:\n   *\n   * @param {string|object} config.template html string template or function to \n   * load via {@link ui.router.util.$templateFactory#fromString fromString}.\n   * @param {string|object} config.templateUrl url to load or a function returning \n   * the url to load via {@link ui.router.util.$templateFactory#fromUrl fromUrl}.\n   * @param {Function} config.templateProvider function to invoke via \n   * {@link ui.router.util.$templateFactory#fromProvider fromProvider}.\n   * @param {object} params  Parameters to pass to the template function.\n   * @param {object} locals Locals to pass to `invoke` if the template is loaded \n   * via a `templateProvider`. Defaults to `{ params: params }`.\n   *\n   * @return {string|object}  The template html as a string, or a promise for \n   * that string,or `null` if no template is configured.\n   */\n  this.fromConfig = function (config, params, locals) {\n    return (\n      isDefined(config.template) ? this.fromString(config.template, params) :\n      isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) :\n      isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) :\n      null\n    );\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromString\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template from a string or a function returning a string.\n   *\n   * @param {string|object} template html template as a string or function that \n   * returns an html template as a string.\n   * @param {object} params Parameters to pass to the template function.\n   *\n   * @return {string|object} The template html as a string, or a promise for that \n   * string.\n   */\n  this.fromString = function (template, params) {\n    return isFunction(template) ? template(params) : template;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromUrl\n   * @methodOf ui.router.util.$templateFactory\n   * \n   * @description\n   * Loads a template from the a URL via `$http` and `$templateCache`.\n   *\n   * @param {string|Function} url url of the template to load, or a function \n   * that returns a url.\n   * @param {Object} params Parameters to pass to the url function.\n   * @return {string|Promise.<string>} The template html as a string, or a promise \n   * for that string.\n   */\n  this.fromUrl = function (url, params) {\n    if (isFunction(url)) url = url(params);\n    if (url == null) return null;\n    else return $http\n        .get(url, { cache: $templateCache, headers: { Accept: 'text/html' }})\n        .then(function(response) { return response.data; });\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromProvider\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template by invoking an injectable provider function.\n   *\n   * @param {Function} provider Function to invoke via `$injector.invoke`\n   * @param {Object} params Parameters for the template.\n   * @param {Object} locals Locals to pass to `invoke`. Defaults to \n   * `{ params: params }`.\n   * @return {string|Promise.<string>} The template html as a string, or a promise \n   * for that string.\n   */\n  this.fromProvider = function (provider, params, locals) {\n    return $injector.invoke(provider, null, locals || { params: params });\n  };\n}\n\nangular.module('ui.router.util').service('$templateFactory', $TemplateFactory);\n\nvar $$UMFP; // reference to $UrlMatcherFactoryProvider\n\n/**\n * @ngdoc object\n * @name ui.router.util.type:UrlMatcher\n *\n * @description\n * Matches URLs against patterns and extracts named parameters from the path or the search\n * part of the URL. A URL pattern consists of a path pattern, optionally followed by '?' and a list\n * of search parameters. Multiple search parameter names are separated by '&'. Search parameters\n * do not influence whether or not a URL is matched, but their values are passed through into\n * the matched parameters returned by {@link ui.router.util.type:UrlMatcher#methods_exec exec}.\n *\n * Path parameter placeholders can be specified using simple colon/catch-all syntax or curly brace\n * syntax, which optionally allows a regular expression for the parameter to be specified:\n *\n * * `':'` name - colon placeholder\n * * `'*'` name - catch-all placeholder\n * * `'{' name '}'` - curly placeholder\n * * `'{' name ':' regexp|type '}'` - curly placeholder with regexp or type name. Should the\n *   regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n *\n * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n * must be unique within the pattern (across both path and search parameters). For colon\n * placeholders or curly placeholders without an explicit regexp, a path parameter matches any\n * number of characters other than '/'. For catch-all placeholders the path parameter matches\n * any number of characters.\n *\n * Examples:\n *\n * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n * * `'/user/{id:[^/]*}'` - Same as the previous example.\n * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n *   parameter consists of 1 to 8 hex digits.\n * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n *   path into the parameter 'path'.\n * * `'/files/*path'` - ditto.\n * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n *   in the built-in  `date` Type matches `2014-11-12`) and provides a Date object in $stateParams.start\n *\n * @param {string} pattern  The pattern to compile into a matcher.\n * @param {Object} config  A configuration object hash:\n * @param {Object=} parentMatcher Used to concatenate the pattern/config onto\n *   an existing UrlMatcher\n *\n * * `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n * * `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n *\n * @property {string} prefix  A static prefix of this pattern. The matcher guarantees that any\n *   URL matching this matcher (i.e. any string for which {@link ui.router.util.type:UrlMatcher#methods_exec exec()} returns\n *   non-null) will start with this prefix.\n *\n * @property {string} source  The pattern that was passed into the constructor\n *\n * @property {string} sourcePath  The path portion of the source property\n *\n * @property {string} sourceSearch  The search portion of the source property\n *\n * @property {string} regex  The constructed regex that will be used to match against the url when\n *   it is time to determine which url will match.\n *\n * @returns {Object}  New `UrlMatcher` object\n */\nfunction UrlMatcher(pattern, config, parentMatcher) {\n  config = extend({ params: {} }, isObject(config) ? config : {});\n\n  // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n  //   '*' name\n  //   ':' name\n  //   '{' name '}'\n  //   '{' name ':' regexp '}'\n  // The regular expression is somewhat complicated due to the need to allow curly braces\n  // inside the regular expression. The placeholder regexp breaks down as follows:\n  //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n  //    \\{([\\w\\[\\]]+)(?:\\:\\s*( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n  //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n  //    [^{}\\\\]+                       - anything other than curly braces or backslash\n  //    \\\\.                            - a backslash escape\n  //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n  var placeholder       = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n      searchPlaceholder = /([:]?)([\\w\\[\\].-]+)|\\{([\\w\\[\\].-]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n      compiled = '^', last = 0, m,\n      segments = this.segments = [],\n      parentParams = parentMatcher ? parentMatcher.params : {},\n      params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),\n      paramNames = [];\n\n  function addParameter(id, type, config, location) {\n    paramNames.push(id);\n    if (parentParams[id]) return parentParams[id];\n    if (!/^\\w+([-.]+\\w+)*(?:\\[\\])?$/.test(id)) throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n    if (params[id]) throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n    params[id] = new $$UMFP.Param(id, type, config, location);\n    return params[id];\n  }\n\n  function quoteRegExp(string, pattern, squash, optional) {\n    var surroundPattern = ['',''], result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n    if (!pattern) return result;\n    switch(squash) {\n      case false: surroundPattern = ['(', ')' + (optional ? \"?\" : \"\")]; break;\n      case true:\n        result = result.replace(/\\/$/, '');\n        surroundPattern = ['(?:\\/(', ')|\\/)?'];\n      break;\n      default:    surroundPattern = ['(' + squash + \"|\", ')?']; break;\n    }\n    return result + surroundPattern[0] + pattern + surroundPattern[1];\n  }\n\n  this.source = pattern;\n\n  // Split into static segments separated by path parameter placeholders.\n  // The number of segments is always 1 more than the number of parameters.\n  function matchDetails(m, isSearch) {\n    var id, regexp, segment, type, cfg, arrayMode;\n    id          = m[2] || m[3]; // IE[78] returns '' for unmatched groups instead of null\n    cfg         = config.params[id];\n    segment     = pattern.substring(last, m.index);\n    regexp      = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);\n\n    if (regexp) {\n      type      = $$UMFP.type(regexp) || inherit($$UMFP.type(\"string\"), { pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined) });\n    }\n\n    return {\n      id: id, regexp: regexp, segment: segment, type: type, cfg: cfg\n    };\n  }\n\n  var p, param, segment;\n  while ((m = placeholder.exec(pattern))) {\n    p = matchDetails(m, false);\n    if (p.segment.indexOf('?') >= 0) break; // we're into the search part\n\n    param = addParameter(p.id, p.type, p.cfg, \"path\");\n    compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);\n    segments.push(p.segment);\n    last = placeholder.lastIndex;\n  }\n  segment = pattern.substring(last);\n\n  // Find any search parameter names and remove them from the last segment\n  var i = segment.indexOf('?');\n\n  if (i >= 0) {\n    var search = this.sourceSearch = segment.substring(i);\n    segment = segment.substring(0, i);\n    this.sourcePath = pattern.substring(0, last + i);\n\n    if (search.length > 0) {\n      last = 0;\n      while ((m = searchPlaceholder.exec(search))) {\n        p = matchDetails(m, true);\n        param = addParameter(p.id, p.type, p.cfg, \"search\");\n        last = placeholder.lastIndex;\n        // check if ?&\n      }\n    }\n  } else {\n    this.sourcePath = pattern;\n    this.sourceSearch = '';\n  }\n\n  compiled += quoteRegExp(segment) + (config.strict === false ? '\\/?' : '') + '$';\n  segments.push(segment);\n\n  this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);\n  this.prefix = segments[0];\n  this.$$paramNames = paramNames;\n}\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#concat\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Returns a new matcher for a pattern constructed by appending the path part and adding the\n * search parameters of the specified pattern to this pattern. The current pattern is not\n * modified. This can be understood as creating a pattern for URLs that are relative to (or\n * suffixes of) the current pattern.\n *\n * @example\n * The following two matchers are equivalent:\n * <pre>\n * new UrlMatcher('/user/{id}?q').concat('/details?date');\n * new UrlMatcher('/user/{id}/details?q&date');\n * </pre>\n *\n * @param {string} pattern  The pattern to append.\n * @param {Object} config  An object hash of the configuration for the matcher.\n * @returns {UrlMatcher}  A matcher for the concatenated pattern.\n */\nUrlMatcher.prototype.concat = function (pattern, config) {\n  // Because order of search parameters is irrelevant, we can add our own search\n  // parameters to the end of the new pattern. Parse the new pattern by itself\n  // and then join the bits together, but it's much easier to do this on a string level.\n  var defaultConfig = {\n    caseInsensitive: $$UMFP.caseInsensitive(),\n    strict: $$UMFP.strictMode(),\n    squash: $$UMFP.defaultSquashPolicy()\n  };\n  return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);\n};\n\nUrlMatcher.prototype.toString = function () {\n  return this.source;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#exec\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Tests the specified path against this matcher, and returns an object containing the captured\n * parameter values, or null if the path does not match. The returned object contains the values\n * of any search parameters that are mentioned in the pattern, but their value may be null if\n * they are not present in `searchParams`. This means that search parameters are always treated\n * as optional.\n *\n * @example\n * <pre>\n * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n *   x: '1', q: 'hello'\n * });\n * // returns { id: 'bob', q: 'hello', r: null }\n * </pre>\n *\n * @param {string} path  The URL path to match, e.g. `$location.path()`.\n * @param {Object} searchParams  URL search parameters, e.g. `$location.search()`.\n * @returns {Object}  The captured parameter values.\n */\nUrlMatcher.prototype.exec = function (path, searchParams) {\n  var m = this.regexp.exec(path);\n  if (!m) return null;\n  searchParams = searchParams || {};\n\n  var paramNames = this.parameters(), nTotal = paramNames.length,\n    nPath = this.segments.length - 1,\n    values = {}, i, j, cfg, paramName;\n\n  if (nPath !== m.length - 1) throw new Error(\"Unbalanced capture group in route '\" + this.source + \"'\");\n\n  function decodePathArray(string) {\n    function reverseString(str) { return str.split(\"\").reverse().join(\"\"); }\n    function unquoteDashes(str) { return str.replace(/\\\\-/g, \"-\"); }\n\n    var split = reverseString(string).split(/-(?!\\\\)/);\n    var allReversed = map(split, reverseString);\n    return map(allReversed, unquoteDashes).reverse();\n  }\n\n  var param, paramVal;\n  for (i = 0; i < nPath; i++) {\n    paramName = paramNames[i];\n    param = this.params[paramName];\n    paramVal = m[i+1];\n    // if the param value matches a pre-replace pair, replace the value before decoding.\n    for (j = 0; j < param.replace.length; j++) {\n      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\n    }\n    if (paramVal && param.array === true) paramVal = decodePathArray(paramVal);\n    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);\n    values[paramName] = param.value(paramVal);\n  }\n  for (/**/; i < nTotal; i++) {\n    paramName = paramNames[i];\n    values[paramName] = this.params[paramName].value(searchParams[paramName]);\n    param = this.params[paramName];\n    paramVal = searchParams[paramName];\n    for (j = 0; j < param.replace.length; j++) {\n      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\n    }\n    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);\n    values[paramName] = param.value(paramVal);\n  }\n\n  return values;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#parameters\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Returns the names of all path and search parameters of this pattern in an unspecified order.\n *\n * @returns {Array.<string>}  An array of parameter names. Must be treated as read-only. If the\n *    pattern has no parameters, an empty array is returned.\n */\nUrlMatcher.prototype.parameters = function (param) {\n  if (!isDefined(param)) return this.$$paramNames;\n  return this.params[param] || null;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#validates\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Checks an object hash of parameters to validate their correctness according to the parameter\n * types of this `UrlMatcher`.\n *\n * @param {Object} params The object hash of parameters to validate.\n * @returns {boolean} Returns `true` if `params` validates, otherwise `false`.\n */\nUrlMatcher.prototype.validates = function (params) {\n  return this.params.$$validates(params);\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#format\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Creates a URL that matches this pattern by substituting the specified values\n * for the path and search parameters. Null values for path parameters are\n * treated as empty strings.\n *\n * @example\n * <pre>\n * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n * // returns '/user/bob?q=yes'\n * </pre>\n *\n * @param {Object} values  the values to substitute for the parameters in this pattern.\n * @returns {string}  the formatted URL (path and optionally search part).\n */\nUrlMatcher.prototype.format = function (values) {\n  values = values || {};\n  var segments = this.segments, params = this.parameters(), paramset = this.params;\n  if (!this.validates(values)) return null;\n\n  var i, search = false, nPath = segments.length - 1, nTotal = params.length, result = segments[0];\n\n  function encodeDashes(str) { // Replace dashes with encoded \"\\-\"\n    return encodeURIComponent(str).replace(/-/g, function(c) { return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase(); });\n  }\n\n  for (i = 0; i < nTotal; i++) {\n    var isPathParam = i < nPath;\n    var name = params[i], param = paramset[name], value = param.value(values[name]);\n    var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);\n    var squash = isDefaultValue ? param.squash : false;\n    var encoded = param.type.encode(value);\n\n    if (isPathParam) {\n      var nextSegment = segments[i + 1];\n      var isFinalPathParam = i + 1 === nPath;\n\n      if (squash === false) {\n        if (encoded != null) {\n          if (isArray(encoded)) {\n            result += map(encoded, encodeDashes).join(\"-\");\n          } else {\n            result += encodeURIComponent(encoded);\n          }\n        }\n        result += nextSegment;\n      } else if (squash === true) {\n        var capture = result.match(/\\/$/) ? /\\/?(.*)/ : /(.*)/;\n        result += nextSegment.match(capture)[1];\n      } else if (isString(squash)) {\n        result += squash + nextSegment;\n      }\n\n      if (isFinalPathParam && param.squash === true && result.slice(-1) === '/') result = result.slice(0, -1);\n    } else {\n      if (encoded == null || (isDefaultValue && squash !== false)) continue;\n      if (!isArray(encoded)) encoded = [ encoded ];\n      if (encoded.length === 0) continue;\n      encoded = map(encoded, encodeURIComponent).join('&' + name + '=');\n      result += (search ? '&' : '?') + (name + '=' + encoded);\n      search = true;\n    }\n  }\n\n  return result;\n};\n\n/**\n * @ngdoc object\n * @name ui.router.util.type:Type\n *\n * @description\n * Implements an interface to define custom parameter types that can be decoded from and encoded to\n * string parameters matched in a URL. Used by {@link ui.router.util.type:UrlMatcher `UrlMatcher`}\n * objects when matching or formatting URLs, or comparing or validating parameter values.\n *\n * See {@link ui.router.util.$urlMatcherFactory#methods_type `$urlMatcherFactory#type()`} for more\n * information on registering custom types.\n *\n * @param {Object} config  A configuration object which contains the custom type definition.  The object's\n *        properties will override the default methods and/or pattern in `Type`'s public interface.\n * @example\n * <pre>\n * {\n *   decode: function(val) { return parseInt(val, 10); },\n *   encode: function(val) { return val && val.toString(); },\n *   equals: function(a, b) { return this.is(a) && a === b; },\n *   is: function(val) { return angular.isNumber(val) isFinite(val) && val % 1 === 0; },\n *   pattern: /\\d+/\n * }\n * </pre>\n *\n * @property {RegExp} pattern The regular expression pattern used to match values of this type when\n *           coming from a substring of a URL.\n *\n * @returns {Object}  Returns a new `Type` object.\n */\nfunction Type(config) {\n  extend(this, config);\n}\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#is\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Detects whether a value is of a particular type. Accepts a native (decoded) value\n * and determines whether it matches the current `Type` object.\n *\n * @param {*} val  The value to check.\n * @param {string} key  Optional. If the type check is happening in the context of a specific\n *        {@link ui.router.util.type:UrlMatcher `UrlMatcher`} object, this is the name of the\n *        parameter in which `val` is stored. Can be used for meta-programming of `Type` objects.\n * @returns {Boolean}  Returns `true` if the value matches the type, otherwise `false`.\n */\nType.prototype.is = function(val, key) {\n  return true;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#encode\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Encodes a custom/native type value to a string that can be embedded in a URL. Note that the\n * return value does *not* need to be URL-safe (i.e. passed through `encodeURIComponent()`), it\n * only needs to be a representation of `val` that has been coerced to a string.\n *\n * @param {*} val  The value to encode.\n * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n *        meta-programming of `Type` objects.\n * @returns {string}  Returns a string representation of `val` that can be encoded in a URL.\n */\nType.prototype.encode = function(val, key) {\n  return val;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#decode\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Converts a parameter value (from URL string or transition param) to a custom/native value.\n *\n * @param {string} val  The URL parameter value to decode.\n * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n *        meta-programming of `Type` objects.\n * @returns {*}  Returns a custom representation of the URL parameter value.\n */\nType.prototype.decode = function(val, key) {\n  return val;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#equals\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Determines whether two decoded values are equivalent.\n *\n * @param {*} a  A value to compare against.\n * @param {*} b  A value to compare against.\n * @returns {Boolean}  Returns `true` if the values are equivalent/equal, otherwise `false`.\n */\nType.prototype.equals = function(a, b) {\n  return a == b;\n};\n\nType.prototype.$subPattern = function() {\n  var sub = this.pattern.toString();\n  return sub.substr(1, sub.length - 2);\n};\n\nType.prototype.pattern = /.*/;\n\nType.prototype.toString = function() { return \"{Type:\" + this.name + \"}\"; };\n\n/** Given an encoded string, or a decoded object, returns a decoded object */\nType.prototype.$normalize = function(val) {\n  return this.is(val) ? val : this.decode(val);\n};\n\n/*\n * Wraps an existing custom Type as an array of Type, depending on 'mode'.\n * e.g.:\n * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n * - url: \"/path?queryParam=1&queryParam=2\n * - $stateParams.queryParam will be [1, 2]\n * if `mode` is \"auto\", then\n * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n */\nType.prototype.$asArray = function(mode, isSearch) {\n  if (!mode) return this;\n  if (mode === \"auto\" && !isSearch) throw new Error(\"'auto' array mode is for query parameters only\");\n\n  function ArrayType(type, mode) {\n    function bindTo(type, callbackName) {\n      return function() {\n        return type[callbackName].apply(type, arguments);\n      };\n    }\n\n    // Wrap non-array value as array\n    function arrayWrap(val) { return isArray(val) ? val : (isDefined(val) ? [ val ] : []); }\n    // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n    function arrayUnwrap(val) {\n      switch(val.length) {\n        case 0: return undefined;\n        case 1: return mode === \"auto\" ? val[0] : val;\n        default: return val;\n      }\n    }\n    function falsey(val) { return !val; }\n\n    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n    function arrayHandler(callback, allTruthyMode) {\n      return function handleArray(val) {\n        if (isArray(val) && val.length === 0) return val;\n        val = arrayWrap(val);\n        var result = map(val, callback);\n        if (allTruthyMode === true)\n          return filter(result, falsey).length === 0;\n        return arrayUnwrap(result);\n      };\n    }\n\n    // Wraps type (.equals) functions to operate on each value of an array\n    function arrayEqualsHandler(callback) {\n      return function handleArray(val1, val2) {\n        var left = arrayWrap(val1), right = arrayWrap(val2);\n        if (left.length !== right.length) return false;\n        for (var i = 0; i < left.length; i++) {\n          if (!callback(left[i], right[i])) return false;\n        }\n        return true;\n      };\n    }\n\n    this.encode = arrayHandler(bindTo(type, 'encode'));\n    this.decode = arrayHandler(bindTo(type, 'decode'));\n    this.is     = arrayHandler(bindTo(type, 'is'), true);\n    this.equals = arrayEqualsHandler(bindTo(type, 'equals'));\n    this.pattern = type.pattern;\n    this.$normalize = arrayHandler(bindTo(type, '$normalize'));\n    this.name = type.name;\n    this.$arrayMode = mode;\n  }\n\n  return new ArrayType(this, mode);\n};\n\n\n\n/**\n * @ngdoc object\n * @name ui.router.util.$urlMatcherFactory\n *\n * @description\n * Factory for {@link ui.router.util.type:UrlMatcher `UrlMatcher`} instances. The factory\n * is also available to providers under the name `$urlMatcherFactoryProvider`.\n */\nfunction $UrlMatcherFactory() {\n  $$UMFP = this;\n\n  var isCaseInsensitive = false, isStrictMode = true, defaultSquashPolicy = false;\n\n  // Use tildes to pre-encode slashes.\n  // If the slashes are simply URLEncoded, the browser can choose to pre-decode them,\n  // and bidirectional encoding/decoding fails.\n  // Tilde was chosen because it's not a RFC 3986 section 2.2 Reserved Character\n  function valToString(val) { return val != null ? val.toString().replace(/~/g, \"~~\").replace(/\\//g, \"~2F\") : val; }\n  function valFromString(val) { return val != null ? val.toString().replace(/~2F/g, \"/\").replace(/~~/g, \"~\") : val; }\n\n  var $types = {}, enqueue = true, typeQueue = [], injector, defaultTypes = {\n    \"string\": {\n      encode: valToString,\n      decode: valFromString,\n      // TODO: in 1.0, make string .is() return false if value is undefined/null by default.\n      // In 0.2.x, string params are optional by default for backwards compat\n      is: function(val) { return val == null || !isDefined(val) || typeof val === \"string\"; },\n      pattern: /[^/]*/\n    },\n    \"int\": {\n      encode: valToString,\n      decode: function(val) { return parseInt(val, 10); },\n      is: function(val) { return isDefined(val) && this.decode(val.toString()) === val; },\n      pattern: /\\d+/\n    },\n    \"bool\": {\n      encode: function(val) { return val ? 1 : 0; },\n      decode: function(val) { return parseInt(val, 10) !== 0; },\n      is: function(val) { return val === true || val === false; },\n      pattern: /0|1/\n    },\n    \"date\": {\n      encode: function (val) {\n        if (!this.is(val))\n          return undefined;\n        return [ val.getFullYear(),\n          ('0' + (val.getMonth() + 1)).slice(-2),\n          ('0' + val.getDate()).slice(-2)\n        ].join(\"-\");\n      },\n      decode: function (val) {\n        if (this.is(val)) return val;\n        var match = this.capture.exec(val);\n        return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\n      },\n      is: function(val) { return val instanceof Date && !isNaN(val.valueOf()); },\n      equals: function (a, b) { return this.is(a) && this.is(b) && a.toISOString() === b.toISOString(); },\n      pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\n      capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/\n    },\n    \"json\": {\n      encode: angular.toJson,\n      decode: angular.fromJson,\n      is: angular.isObject,\n      equals: angular.equals,\n      pattern: /[^/]*/\n    },\n    \"any\": { // does not encode/decode\n      encode: angular.identity,\n      decode: angular.identity,\n      equals: angular.equals,\n      pattern: /.*/\n    }\n  };\n\n  function getDefaultConfig() {\n    return {\n      strict: isStrictMode,\n      caseInsensitive: isCaseInsensitive\n    };\n  }\n\n  function isInjectable(value) {\n    return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));\n  }\n\n  /**\n   * [Internal] Get the default value of a parameter, which may be an injectable function.\n   */\n  $UrlMatcherFactory.$$getDefaultValue = function(config) {\n    if (!isInjectable(config.value)) return config.value;\n    if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n    return injector.invoke(config.value);\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#caseInsensitive\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Defines whether URL matching should be case sensitive (the default behavior), or not.\n   *\n   * @param {boolean} value `false` to match URL in a case sensitive manner; otherwise `true`;\n   * @returns {boolean} the current value of caseInsensitive\n   */\n  this.caseInsensitive = function(value) {\n    if (isDefined(value))\n      isCaseInsensitive = value;\n    return isCaseInsensitive;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#strictMode\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Defines whether URLs should match trailing slashes, or not (the default behavior).\n   *\n   * @param {boolean=} value `false` to match trailing slashes in URLs, otherwise `true`.\n   * @returns {boolean} the current value of strictMode\n   */\n  this.strictMode = function(value) {\n    if (isDefined(value))\n      isStrictMode = value;\n    return isStrictMode;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#defaultSquashPolicy\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Sets the default behavior when generating or matching URLs with default parameter values.\n   *\n   * @param {string} value A string that defines the default parameter URL squashing behavior.\n   *    `nosquash`: When generating an href with a default parameter value, do not squash the parameter value from the URL\n   *    `slash`: When generating an href with a default parameter value, squash (remove) the parameter value, and, if the\n   *             parameter is surrounded by slashes, squash (remove) one slash from the URL\n   *    any other string, e.g. \"~\": When generating an href with a default parameter value, squash (remove)\n   *             the parameter value from the URL and replace it with this string.\n   */\n  this.defaultSquashPolicy = function(value) {\n    if (!isDefined(value)) return defaultSquashPolicy;\n    if (value !== true && value !== false && !isString(value))\n      throw new Error(\"Invalid squash policy: \" + value + \". Valid policies: false, true, arbitrary-string\");\n    defaultSquashPolicy = value;\n    return value;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#compile\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Creates a {@link ui.router.util.type:UrlMatcher `UrlMatcher`} for the specified pattern.\n   *\n   * @param {string} pattern  The URL pattern.\n   * @param {Object} config  The config object hash.\n   * @returns {UrlMatcher}  The UrlMatcher.\n   */\n  this.compile = function (pattern, config) {\n    return new UrlMatcher(pattern, extend(getDefaultConfig(), config));\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#isMatcher\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Returns true if the specified object is a `UrlMatcher`, or false otherwise.\n   *\n   * @param {Object} object  The object to perform the type check against.\n   * @returns {Boolean}  Returns `true` if the object matches the `UrlMatcher` interface, by\n   *          implementing all the same methods.\n   */\n  this.isMatcher = function (o) {\n    if (!isObject(o)) return false;\n    var result = true;\n\n    forEach(UrlMatcher.prototype, function(val, name) {\n      if (isFunction(val)) {\n        result = result && (isDefined(o[name]) && isFunction(o[name]));\n      }\n    });\n    return result;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#type\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Registers a custom {@link ui.router.util.type:Type `Type`} object that can be used to\n   * generate URLs with typed parameters.\n   *\n   * @param {string} name  The type name.\n   * @param {Object|Function} definition   The type definition. See\n   *        {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n   * @param {Object|Function} definitionFn (optional) A function that is injected before the app\n   *        runtime starts.  The result of this function is merged into the existing `definition`.\n   *        See {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n   *\n   * @returns {Object}  Returns `$urlMatcherFactoryProvider`.\n   *\n   * @example\n   * This is a simple example of a custom type that encodes and decodes items from an\n   * array, using the array index as the URL-encoded value:\n   *\n   * <pre>\n   * var list = ['John', 'Paul', 'George', 'Ringo'];\n   *\n   * $urlMatcherFactoryProvider.type('listItem', {\n   *   encode: function(item) {\n   *     // Represent the list item in the URL using its corresponding index\n   *     return list.indexOf(item);\n   *   },\n   *   decode: function(item) {\n   *     // Look up the list item by index\n   *     return list[parseInt(item, 10)];\n   *   },\n   *   is: function(item) {\n   *     // Ensure the item is valid by checking to see that it appears\n   *     // in the list\n   *     return list.indexOf(item) > -1;\n   *   }\n   * });\n   *\n   * $stateProvider.state('list', {\n   *   url: \"/list/{item:listItem}\",\n   *   controller: function($scope, $stateParams) {\n   *     console.log($stateParams.item);\n   *   }\n   * });\n   *\n   * // ...\n   *\n   * // Changes URL to '/list/3', logs \"Ringo\" to the console\n   * $state.go('list', { item: \"Ringo\" });\n   * </pre>\n   *\n   * This is a more complex example of a type that relies on dependency injection to\n   * interact with services, and uses the parameter name from the URL to infer how to\n   * handle encoding and decoding parameter values:\n   *\n   * <pre>\n   * // Defines a custom type that gets a value from a service,\n   * // where each service gets different types of values from\n   * // a backend API:\n   * $urlMatcherFactoryProvider.type('dbObject', {}, function(Users, Posts) {\n   *\n   *   // Matches up services to URL parameter names\n   *   var services = {\n   *     user: Users,\n   *     post: Posts\n   *   };\n   *\n   *   return {\n   *     encode: function(object) {\n   *       // Represent the object in the URL using its unique ID\n   *       return object.id;\n   *     },\n   *     decode: function(value, key) {\n   *       // Look up the object by ID, using the parameter\n   *       // name (key) to call the correct service\n   *       return services[key].findById(value);\n   *     },\n   *     is: function(object, key) {\n   *       // Check that object is a valid dbObject\n   *       return angular.isObject(object) && object.id && services[key];\n   *     }\n   *     equals: function(a, b) {\n   *       // Check the equality of decoded objects by comparing\n   *       // their unique IDs\n   *       return a.id === b.id;\n   *     }\n   *   };\n   * });\n   *\n   * // In a config() block, you can then attach URLs with\n   * // type-annotated parameters:\n   * $stateProvider.state('users', {\n   *   url: \"/users\",\n   *   // ...\n   * }).state('users.item', {\n   *   url: \"/{user:dbObject}\",\n   *   controller: function($scope, $stateParams) {\n   *     // $stateParams.user will now be an object returned from\n   *     // the Users service\n   *   },\n   *   // ...\n   * });\n   * </pre>\n   */\n  this.type = function (name, definition, definitionFn) {\n    if (!isDefined(definition)) return $types[name];\n    if ($types.hasOwnProperty(name)) throw new Error(\"A type named '\" + name + \"' has already been defined.\");\n\n    $types[name] = new Type(extend({ name: name }, definition));\n    if (definitionFn) {\n      typeQueue.push({ name: name, def: definitionFn });\n      if (!enqueue) flushTypeQueue();\n    }\n    return this;\n  };\n\n  // `flushTypeQueue()` waits until `$urlMatcherFactory` is injected before invoking the queued `definitionFn`s\n  function flushTypeQueue() {\n    while(typeQueue.length) {\n      var type = typeQueue.shift();\n      if (type.pattern) throw new Error(\"You cannot override a type's .pattern at runtime.\");\n      angular.extend($types[type.name], injector.invoke(type.def));\n    }\n  }\n\n  // Register default types. Store them in the prototype of $types.\n  forEach(defaultTypes, function(type, name) { $types[name] = new Type(extend({name: name}, type)); });\n  $types = inherit($types, {});\n\n  /* No need to document $get, since it returns this */\n  this.$get = ['$injector', function ($injector) {\n    injector = $injector;\n    enqueue = false;\n    flushTypeQueue();\n\n    forEach(defaultTypes, function(type, name) {\n      if (!$types[name]) $types[name] = new Type(type);\n    });\n    return this;\n  }];\n\n  this.Param = function Param(id, type, config, location) {\n    var self = this;\n    config = unwrapShorthand(config);\n    type = getType(config, type, location);\n    var arrayMode = getArrayMode();\n    type = arrayMode ? type.$asArray(arrayMode, location === \"search\") : type;\n    if (type.name === \"string\" && !arrayMode && location === \"path\" && config.value === undefined)\n      config.value = \"\"; // for 0.2.x; in 0.3.0+ do not automatically default to \"\"\n    var isOptional = config.value !== undefined;\n    var squash = getSquashPolicy(config, isOptional);\n    var replace = getReplace(config, arrayMode, isOptional, squash);\n\n    function unwrapShorthand(config) {\n      var keys = isObject(config) ? objectKeys(config) : [];\n      var isShorthand = indexOf(keys, \"value\") === -1 && indexOf(keys, \"type\") === -1 &&\n                        indexOf(keys, \"squash\") === -1 && indexOf(keys, \"array\") === -1;\n      if (isShorthand) config = { value: config };\n      config.$$fn = isInjectable(config.value) ? config.value : function () { return config.value; };\n      return config;\n    }\n\n    function getType(config, urlType, location) {\n      if (config.type && urlType) throw new Error(\"Param '\"+id+\"' has two type configurations.\");\n      if (urlType) return urlType;\n      if (!config.type) return (location === \"config\" ? $types.any : $types.string);\n\n      if (angular.isString(config.type))\n        return $types[config.type];\n      if (config.type instanceof Type)\n        return config.type;\n      return new Type(config.type);\n    }\n\n    // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n    function getArrayMode() {\n      var arrayDefaults = { array: (location === \"search\" ? \"auto\" : false) };\n      var arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n      return extend(arrayDefaults, arrayParamNomenclature, config).array;\n    }\n\n    /**\n     * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n     */\n    function getSquashPolicy(config, isOptional) {\n      var squash = config.squash;\n      if (!isOptional || squash === false) return false;\n      if (!isDefined(squash) || squash == null) return defaultSquashPolicy;\n      if (squash === true || isString(squash)) return squash;\n      throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n    }\n\n    function getReplace(config, arrayMode, isOptional, squash) {\n      var replace, configuredKeys, defaultPolicy = [\n        { from: \"\",   to: (isOptional || arrayMode ? undefined : \"\") },\n        { from: null, to: (isOptional || arrayMode ? undefined : \"\") }\n      ];\n      replace = isArray(config.replace) ? config.replace : [];\n      if (isString(squash))\n        replace.push({ from: squash, to: undefined });\n      configuredKeys = map(replace, function(item) { return item.from; } );\n      return filter(defaultPolicy, function(item) { return indexOf(configuredKeys, item.from) === -1; }).concat(replace);\n    }\n\n    /**\n     * [Internal] Get the default value of a parameter, which may be an injectable function.\n     */\n    function $$getDefaultValue() {\n      if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n      var defaultValue = injector.invoke(config.$$fn);\n      if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue))\n        throw new Error(\"Default value (\" + defaultValue + \") for parameter '\" + self.id + \"' is not an instance of Type (\" + self.type.name + \")\");\n      return defaultValue;\n    }\n\n    /**\n     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n     * default value, which may be the result of an injectable function.\n     */\n    function $value(value) {\n      function hasReplaceVal(val) { return function(obj) { return obj.from === val; }; }\n      function $replace(value) {\n        var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) { return obj.to; });\n        return replacement.length ? replacement[0] : value;\n      }\n      value = $replace(value);\n      return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);\n    }\n\n    function toString() { return \"{Param:\" + id + \" \" + type + \" squash: '\" + squash + \"' optional: \" + isOptional + \"}\"; }\n\n    extend(this, {\n      id: id,\n      type: type,\n      location: location,\n      array: arrayMode,\n      squash: squash,\n      replace: replace,\n      isOptional: isOptional,\n      value: $value,\n      dynamic: undefined,\n      config: config,\n      toString: toString\n    });\n  };\n\n  function ParamSet(params) {\n    extend(this, params || {});\n  }\n\n  ParamSet.prototype = {\n    $$new: function() {\n      return inherit(this, extend(new ParamSet(), { $$parent: this}));\n    },\n    $$keys: function () {\n      var keys = [], chain = [], parent = this,\n        ignore = objectKeys(ParamSet.prototype);\n      while (parent) { chain.push(parent); parent = parent.$$parent; }\n      chain.reverse();\n      forEach(chain, function(paramset) {\n        forEach(objectKeys(paramset), function(key) {\n            if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1) keys.push(key);\n        });\n      });\n      return keys;\n    },\n    $$values: function(paramValues) {\n      var values = {}, self = this;\n      forEach(self.$$keys(), function(key) {\n        values[key] = self[key].value(paramValues && paramValues[key]);\n      });\n      return values;\n    },\n    $$equals: function(paramValues1, paramValues2) {\n      var equal = true, self = this;\n      forEach(self.$$keys(), function(key) {\n        var left = paramValues1 && paramValues1[key], right = paramValues2 && paramValues2[key];\n        if (!self[key].type.equals(left, right)) equal = false;\n      });\n      return equal;\n    },\n    $$validates: function $$validate(paramValues) {\n      var keys = this.$$keys(), i, param, rawVal, normalized, encoded;\n      for (i = 0; i < keys.length; i++) {\n        param = this[keys[i]];\n        rawVal = paramValues[keys[i]];\n        if ((rawVal === undefined || rawVal === null) && param.isOptional)\n          break; // There was no parameter value, but the param is optional\n        normalized = param.type.$normalize(rawVal);\n        if (!param.type.is(normalized))\n          return false; // The value was not of the correct Type, and could not be decoded to the correct Type\n        encoded = param.type.encode(normalized);\n        if (angular.isString(encoded) && !param.type.pattern.exec(encoded))\n          return false; // The value was of the correct type, but when encoded, did not match the Type's regexp\n      }\n      return true;\n    },\n    $$parent: undefined\n  };\n\n  this.ParamSet = ParamSet;\n}\n\n// Register as a provider so it's available to other providers\nangular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);\nangular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) { }]);\n\n/**\n * @ngdoc object\n * @name ui.router.router.$urlRouterProvider\n *\n * @requires ui.router.util.$urlMatcherFactoryProvider\n * @requires $locationProvider\n *\n * @description\n * `$urlRouterProvider` has the responsibility of watching `$location`. \n * When `$location` changes it runs through a list of rules one by one until a \n * match is found. `$urlRouterProvider` is used behind the scenes anytime you specify \n * a url in a state configuration. All urls are compiled into a UrlMatcher object.\n *\n * There are several methods on `$urlRouterProvider` that make it useful to use directly\n * in your module config.\n */\n$UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];\nfunction $UrlRouterProvider(   $locationProvider,   $urlMatcherFactory) {\n  var rules = [], otherwise = null, interceptDeferred = false, listener;\n\n  // Returns a string that is a prefix of all strings matching the RegExp\n  function regExpPrefix(re) {\n    var prefix = /^\\^((?:\\\\[^a-zA-Z0-9]|[^\\\\\\[\\]\\^$*+?.()|{}]+)*)/.exec(re.source);\n    return (prefix != null) ? prefix[1].replace(/\\\\(.)/g, \"$1\") : '';\n  }\n\n  // Interpolates matched values into a String.replace()-style pattern\n  function interpolate(pattern, match) {\n    return pattern.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n      return match[what === '$' ? 0 : Number(what)];\n    });\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#rule\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Defines rules that are used by `$urlRouterProvider` to find matches for\n   * specific URLs.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   // Here's an example of how you might allow case insensitive urls\n   *   $urlRouterProvider.rule(function ($injector, $location) {\n   *     var path = $location.path(),\n   *         normalized = path.toLowerCase();\n   *\n   *     if (path !== normalized) {\n   *       return normalized;\n   *     }\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {function} rule Handler function that takes `$injector` and `$location`\n   * services as arguments. You can use them to return a valid path as a string.\n   *\n   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n   */\n  this.rule = function (rule) {\n    if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n    rules.push(rule);\n    return this;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.router.$urlRouterProvider#otherwise\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Defines a path that is used when an invalid route is requested.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   // if the path doesn't match any of the urls you configured\n   *   // otherwise will take care of routing the user to the\n   *   // specified url\n   *   $urlRouterProvider.otherwise('/index');\n   *\n   *   // Example of using function rule as param\n   *   $urlRouterProvider.otherwise(function ($injector, $location) {\n   *     return '/a/valid/url';\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {string|function} rule The url path you want to redirect to or a function \n   * rule that returns the url path. The function version is passed two params: \n   * `$injector` and `$location` services, and must return a url string.\n   *\n   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n   */\n  this.otherwise = function (rule) {\n    if (isString(rule)) {\n      var redirect = rule;\n      rule = function () { return redirect; };\n    }\n    else if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n    otherwise = rule;\n    return this;\n  };\n\n\n  function handleIfMatch($injector, handler, match) {\n    if (!match) return false;\n    var result = $injector.invoke(handler, handler, { $match: match });\n    return isDefined(result) ? result : true;\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#when\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Registers a handler for a given url matching. \n   * \n   * If the handler is a string, it is\n   * treated as a redirect, and is interpolated according to the syntax of match\n   * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).\n   *\n   * If the handler is a function, it is injectable. It gets invoked if `$location`\n   * matches. You have the option of inject the match object as `$match`.\n   *\n   * The handler can return\n   *\n   * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`\n   *   will continue trying to find another one that matches.\n   * - **string** which is treated as a redirect and passed to `$location.url()`\n   * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {\n   *     if ($state.$current.navigable !== state ||\n   *         !equalForKeys($match, $stateParams) {\n   *      $state.transitionTo(state, $match, false);\n   *     }\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {string|object} what The incoming path that you want to redirect.\n   * @param {string|function} handler The path you want to redirect your user to.\n   */\n  this.when = function (what, handler) {\n    var redirect, handlerIsString = isString(handler);\n    if (isString(what)) what = $urlMatcherFactory.compile(what);\n\n    if (!handlerIsString && !isFunction(handler) && !isArray(handler))\n      throw new Error(\"invalid 'handler' in when()\");\n\n    var strategies = {\n      matcher: function (what, handler) {\n        if (handlerIsString) {\n          redirect = $urlMatcherFactory.compile(handler);\n          handler = ['$match', function ($match) { return redirect.format($match); }];\n        }\n        return extend(function ($injector, $location) {\n          return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));\n        }, {\n          prefix: isString(what.prefix) ? what.prefix : ''\n        });\n      },\n      regex: function (what, handler) {\n        if (what.global || what.sticky) throw new Error(\"when() RegExp must not be global or sticky\");\n\n        if (handlerIsString) {\n          redirect = handler;\n          handler = ['$match', function ($match) { return interpolate(redirect, $match); }];\n        }\n        return extend(function ($injector, $location) {\n          return handleIfMatch($injector, handler, what.exec($location.path()));\n        }, {\n          prefix: regExpPrefix(what)\n        });\n      }\n    };\n\n    var check = { matcher: $urlMatcherFactory.isMatcher(what), regex: what instanceof RegExp };\n\n    for (var n in check) {\n      if (check[n]) return this.rule(strategies[n](what, handler));\n    }\n\n    throw new Error(\"invalid 'what' in when()\");\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#deferIntercept\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Disables (or enables) deferring location change interception.\n   *\n   * If you wish to customize the behavior of syncing the URL (for example, if you wish to\n   * defer a transition but maintain the current URL), call this method at configuration time.\n   * Then, at run time, call `$urlRouter.listen()` after you have configured your own\n   * `$locationChangeSuccess` event handler.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *\n   *   // Prevent $urlRouter from automatically intercepting URL changes;\n   *   // this allows you to configure custom behavior in between\n   *   // location changes and route synchronization:\n   *   $urlRouterProvider.deferIntercept();\n   *\n   * }).run(function ($rootScope, $urlRouter, UserService) {\n   *\n   *   $rootScope.$on('$locationChangeSuccess', function(e) {\n   *     // UserService is an example service for managing user state\n   *     if (UserService.isLoggedIn()) return;\n   *\n   *     // Prevent $urlRouter's default handler from firing\n   *     e.preventDefault();\n   *\n   *     UserService.handleLogin().then(function() {\n   *       // Once the user has logged in, sync the current URL\n   *       // to the router:\n   *       $urlRouter.sync();\n   *     });\n   *   });\n   *\n   *   // Configures $urlRouter's listener *after* your custom listener\n   *   $urlRouter.listen();\n   * });\n   * </pre>\n   *\n   * @param {boolean} defer Indicates whether to defer location change interception. Passing\n            no parameter is equivalent to `true`.\n   */\n  this.deferIntercept = function (defer) {\n    if (defer === undefined) defer = true;\n    interceptDeferred = defer;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.router.$urlRouter\n   *\n   * @requires $location\n   * @requires $rootScope\n   * @requires $injector\n   * @requires $browser\n   *\n   * @description\n   *\n   */\n  this.$get = $get;\n  $get.$inject = ['$location', '$rootScope', '$injector', '$browser', '$sniffer'];\n  function $get(   $location,   $rootScope,   $injector,   $browser,   $sniffer) {\n\n    var baseHref = $browser.baseHref(), location = $location.url(), lastPushedUrl;\n\n    function appendBasePath(url, isHtml5, absolute) {\n      if (baseHref === '/') return url;\n      if (isHtml5) return baseHref.slice(0, -1) + url;\n      if (absolute) return baseHref.slice(1) + url;\n      return url;\n    }\n\n    // TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree\n    function update(evt) {\n      if (evt && evt.defaultPrevented) return;\n      var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;\n      lastPushedUrl = undefined;\n      // TODO: Re-implement this in 1.0 for https://github.com/angular-ui/ui-router/issues/1573\n      //if (ignoreUpdate) return true;\n\n      function check(rule) {\n        var handled = rule($injector, $location);\n\n        if (!handled) return false;\n        if (isString(handled)) $location.replace().url(handled);\n        return true;\n      }\n      var n = rules.length, i;\n\n      for (i = 0; i < n; i++) {\n        if (check(rules[i])) return;\n      }\n      // always check otherwise last to allow dynamic updates to the set of rules\n      if (otherwise) check(otherwise);\n    }\n\n    function listen() {\n      listener = listener || $rootScope.$on('$locationChangeSuccess', update);\n      return listener;\n    }\n\n    if (!interceptDeferred) listen();\n\n    return {\n      /**\n       * @ngdoc function\n       * @name ui.router.router.$urlRouter#sync\n       * @methodOf ui.router.router.$urlRouter\n       *\n       * @description\n       * Triggers an update; the same update that happens when the address bar url changes, aka `$locationChangeSuccess`.\n       * This method is useful when you need to use `preventDefault()` on the `$locationChangeSuccess` event,\n       * perform some custom logic (route protection, auth, config, redirection, etc) and then finally proceed\n       * with the transition by calling `$urlRouter.sync()`.\n       *\n       * @example\n       * <pre>\n       * angular.module('app', ['ui.router'])\n       *   .run(function($rootScope, $urlRouter) {\n       *     $rootScope.$on('$locationChangeSuccess', function(evt) {\n       *       // Halt state change from even starting\n       *       evt.preventDefault();\n       *       // Perform custom logic\n       *       var meetsRequirement = ...\n       *       // Continue with the update and state transition if logic allows\n       *       if (meetsRequirement) $urlRouter.sync();\n       *     });\n       * });\n       * </pre>\n       */\n      sync: function() {\n        update();\n      },\n\n      listen: function() {\n        return listen();\n      },\n\n      update: function(read) {\n        if (read) {\n          location = $location.url();\n          return;\n        }\n        if ($location.url() === location) return;\n\n        $location.url(location);\n        $location.replace();\n      },\n\n      push: function(urlMatcher, params, options) {\n         var url = urlMatcher.format(params || {});\n\n        // Handle the special hash param, if needed\n        if (url !== null && params && params['#']) {\n            url += '#' + params['#'];\n        }\n\n        $location.url(url);\n        lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;\n        if (options && options.replace) $location.replace();\n      },\n\n      /**\n       * @ngdoc function\n       * @name ui.router.router.$urlRouter#href\n       * @methodOf ui.router.router.$urlRouter\n       *\n       * @description\n       * A URL generation method that returns the compiled URL for a given\n       * {@link ui.router.util.type:UrlMatcher `UrlMatcher`}, populated with the provided parameters.\n       *\n       * @example\n       * <pre>\n       * $bob = $urlRouter.href(new UrlMatcher(\"/about/:person\"), {\n       *   person: \"bob\"\n       * });\n       * // $bob == \"/about/bob\";\n       * </pre>\n       *\n       * @param {UrlMatcher} urlMatcher The `UrlMatcher` object which is used as the template of the URL to generate.\n       * @param {object=} params An object of parameter values to fill the matcher's required parameters.\n       * @param {object=} options Options object. The options are:\n       *\n       * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n       *\n       * @returns {string} Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n       */\n      href: function(urlMatcher, params, options) {\n        if (!urlMatcher.validates(params)) return null;\n\n        var isHtml5 = $locationProvider.html5Mode();\n        if (angular.isObject(isHtml5)) {\n          isHtml5 = isHtml5.enabled;\n        }\n\n        isHtml5 = isHtml5 && $sniffer.history;\n        \n        var url = urlMatcher.format(params);\n        options = options || {};\n\n        if (!isHtml5 && url !== null) {\n          url = \"#\" + $locationProvider.hashPrefix() + url;\n        }\n\n        // Handle special hash param, if needed\n        if (url !== null && params && params['#']) {\n          url += '#' + params['#'];\n        }\n\n        url = appendBasePath(url, isHtml5, options.absolute);\n\n        if (!options.absolute || !url) {\n          return url;\n        }\n\n        var slash = (!isHtml5 && url ? '/' : ''), port = $location.port();\n        port = (port === 80 || port === 443 ? '' : ':' + port);\n\n        return [$location.protocol(), '://', $location.host(), port, slash, url].join('');\n      }\n    };\n  }\n}\n\nangular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);\n\n/**\n * @ngdoc object\n * @name ui.router.state.$stateProvider\n *\n * @requires ui.router.router.$urlRouterProvider\n * @requires ui.router.util.$urlMatcherFactoryProvider\n *\n * @description\n * The new `$stateProvider` works similar to Angular's v1 router, but it focuses purely\n * on state.\n *\n * A state corresponds to a \"place\" in the application in terms of the overall UI and\n * navigation. A state describes (via the controller / template / view properties) what\n * the UI looks like and does at that place.\n *\n * States often have things in common, and the primary way of factoring out these\n * commonalities in this model is via the state hierarchy, i.e. parent/child states aka\n * nested states.\n *\n * The `$stateProvider` provides interfaces to declare these states for your app.\n */\n$StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];\nfunction $StateProvider(   $urlRouterProvider,   $urlMatcherFactory) {\n\n  var root, states = {}, $state, queue = {}, abstractKey = 'abstract';\n\n  // Builds state properties from definition passed to registerState()\n  var stateBuilder = {\n\n    // Derive parent state from a hierarchical name only if 'parent' is not explicitly defined.\n    // state.children = [];\n    // if (parent) parent.children.push(state);\n    parent: function(state) {\n      if (isDefined(state.parent) && state.parent) return findState(state.parent);\n      // regex matches any valid composite state name\n      // would match \"contact.list\" but not \"contacts\"\n      var compositeName = /^(.+)\\.[^.]+$/.exec(state.name);\n      return compositeName ? findState(compositeName[1]) : root;\n    },\n\n    // inherit 'data' from parent and override by own values (if any)\n    data: function(state) {\n      if (state.parent && state.parent.data) {\n        state.data = state.self.data = inherit(state.parent.data, state.data);\n      }\n      return state.data;\n    },\n\n    // Build a URLMatcher if necessary, either via a relative or absolute URL\n    url: function(state) {\n      var url = state.url, config = { params: state.params || {} };\n\n      if (isString(url)) {\n        if (url.charAt(0) == '^') return $urlMatcherFactory.compile(url.substring(1), config);\n        return (state.parent.navigable || root).url.concat(url, config);\n      }\n\n      if (!url || $urlMatcherFactory.isMatcher(url)) return url;\n      throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n    },\n\n    // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n    navigable: function(state) {\n      return state.url ? state : (state.parent ? state.parent.navigable : null);\n    },\n\n    // Own parameters for this state. state.url.params is already built at this point. Create and add non-url params\n    ownParams: function(state) {\n      var params = state.url && state.url.params || new $$UMFP.ParamSet();\n      forEach(state.params || {}, function(config, id) {\n        if (!params[id]) params[id] = new $$UMFP.Param(id, null, config, \"config\");\n      });\n      return params;\n    },\n\n    // Derive parameters for this state and ensure they're a super-set of parent's parameters\n    params: function(state) {\n      var ownParams = pick(state.ownParams, state.ownParams.$$keys());\n      return state.parent && state.parent.params ? extend(state.parent.params.$$new(), ownParams) : new $$UMFP.ParamSet();\n    },\n\n    // If there is no explicit multi-view configuration, make one up so we don't have\n    // to handle both cases in the view directive later. Note that having an explicit\n    // 'views' property will mean the default unnamed view properties are ignored. This\n    // is also a good time to resolve view names to absolute names, so everything is a\n    // straight lookup at link time.\n    views: function(state) {\n      var views = {};\n\n      forEach(isDefined(state.views) ? state.views : { '': state }, function (view, name) {\n        if (name.indexOf('@') < 0) name += '@' + state.parent.name;\n        view.resolveAs = view.resolveAs || state.resolveAs || '$resolve';\n        views[name] = view;\n      });\n      return views;\n    },\n\n    // Keep a full path from the root down to this state as this is needed for state activation.\n    path: function(state) {\n      return state.parent ? state.parent.path.concat(state) : []; // exclude root from path\n    },\n\n    // Speed up $state.contains() as it's used a lot\n    includes: function(state) {\n      var includes = state.parent ? extend({}, state.parent.includes) : {};\n      includes[state.name] = true;\n      return includes;\n    },\n\n    $delegates: {}\n  };\n\n  function isRelative(stateName) {\n    return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n  }\n\n  function findState(stateOrName, base) {\n    if (!stateOrName) return undefined;\n\n    var isStr = isString(stateOrName),\n        name  = isStr ? stateOrName : stateOrName.name,\n        path  = isRelative(name);\n\n    if (path) {\n      if (!base) throw new Error(\"No reference point given for path '\"  + name + \"'\");\n      base = findState(base);\n      \n      var rel = name.split(\".\"), i = 0, pathLength = rel.length, current = base;\n\n      for (; i < pathLength; i++) {\n        if (rel[i] === \"\" && i === 0) {\n          current = base;\n          continue;\n        }\n        if (rel[i] === \"^\") {\n          if (!current.parent) throw new Error(\"Path '\" + name + \"' not valid for state '\" + base.name + \"'\");\n          current = current.parent;\n          continue;\n        }\n        break;\n      }\n      rel = rel.slice(i).join(\".\");\n      name = current.name + (current.name && rel ? \".\" : \"\") + rel;\n    }\n    var state = states[name];\n\n    if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n      return state;\n    }\n    return undefined;\n  }\n\n  function queueState(parentName, state) {\n    if (!queue[parentName]) {\n      queue[parentName] = [];\n    }\n    queue[parentName].push(state);\n  }\n\n  function flushQueuedChildren(parentName) {\n    var queued = queue[parentName] || [];\n    while(queued.length) {\n      registerState(queued.shift());\n    }\n  }\n\n  function registerState(state) {\n    // Wrap a new object around the state so we can store our private details easily.\n    state = inherit(state, {\n      self: state,\n      resolve: state.resolve || {},\n      toString: function() { return this.name; }\n    });\n\n    var name = state.name;\n    if (!isString(name) || name.indexOf('@') >= 0) throw new Error(\"State must have a valid name\");\n    if (states.hasOwnProperty(name)) throw new Error(\"State '\" + name + \"' is already defined\");\n\n    // Get parent name\n    var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.'))\n        : (isString(state.parent)) ? state.parent\n        : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name\n        : '';\n\n    // If parent is not registered yet, add state to queue and register later\n    if (parentName && !states[parentName]) {\n      return queueState(parentName, state.self);\n    }\n\n    for (var key in stateBuilder) {\n      if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);\n    }\n    states[name] = state;\n\n    // Register the state in the global state list and with $urlRouter if necessary.\n    if (!state[abstractKey] && state.url) {\n      $urlRouterProvider.when(state.url, ['$match', '$stateParams', function ($match, $stateParams) {\n        if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {\n          $state.transitionTo(state, $match, { inherit: true, location: false });\n        }\n      }]);\n    }\n\n    // Register any queued children\n    flushQueuedChildren(name);\n\n    return state;\n  }\n\n  // Checks text to see if it looks like a glob.\n  function isGlob (text) {\n    return text.indexOf('*') > -1;\n  }\n\n  // Returns true if glob matches current $state name.\n  function doesStateMatchGlob (glob) {\n    var globSegments = glob.split('.'),\n        segments = $state.$current.name.split('.');\n\n    //match single stars\n    for (var i = 0, l = globSegments.length; i < l; i++) {\n      if (globSegments[i] === '*') {\n        segments[i] = '*';\n      }\n    }\n\n    //match greedy starts\n    if (globSegments[0] === '**') {\n       segments = segments.slice(indexOf(segments, globSegments[1]));\n       segments.unshift('**');\n    }\n    //match greedy ends\n    if (globSegments[globSegments.length - 1] === '**') {\n       segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);\n       segments.push('**');\n    }\n\n    if (globSegments.length != segments.length) {\n      return false;\n    }\n\n    return segments.join('') === globSegments.join('');\n  }\n\n\n  // Implicit root state that is always active\n  root = registerState({\n    name: '',\n    url: '^',\n    views: null,\n    'abstract': true\n  });\n  root.navigable = null;\n\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$stateProvider#decorator\n   * @methodOf ui.router.state.$stateProvider\n   *\n   * @description\n   * Allows you to extend (carefully) or override (at your own peril) the \n   * `stateBuilder` object used internally by `$stateProvider`. This can be used \n   * to add custom functionality to ui-router, for example inferring templateUrl \n   * based on the state name.\n   *\n   * When passing only a name, it returns the current (original or decorated) builder\n   * function that matches `name`.\n   *\n   * The builder functions that can be decorated are listed below. Though not all\n   * necessarily have a good use case for decoration, that is up to you to decide.\n   *\n   * In addition, users can attach custom decorators, which will generate new \n   * properties within the state's internal definition. There is currently no clear \n   * use-case for this beyond accessing internal states (i.e. $state.$current), \n   * however, expect this to become increasingly relevant as we introduce additional \n   * meta-programming features.\n   *\n   * **Warning**: Decorators should not be interdependent because the order of \n   * execution of the builder functions in non-deterministic. Builder functions \n   * should only be dependent on the state definition object and super function.\n   *\n   *\n   * Existing builder functions and current return values:\n   *\n   * - **parent** `{object}` - returns the parent state object.\n   * - **data** `{object}` - returns state data, including any inherited data that is not\n   *   overridden by own values (if any).\n   * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}\n   *   or `null`.\n   * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is \n   *   navigable).\n   * - **params** `{object}` - returns an array of state params that are ensured to \n   *   be a super-set of parent's params.\n   * - **views** `{object}` - returns a views object where each key is an absolute view \n   *   name (i.e. \"viewName@stateName\") and each value is the config object \n   *   (template, controller) for the view. Even when you don't use the views object \n   *   explicitly on a state config, one is still created for you internally.\n   *   So by decorating this builder function you have access to decorating template \n   *   and controller properties.\n   * - **ownParams** `{object}` - returns an array of params that belong to the state, \n   *   not including any params defined by ancestor states.\n   * - **path** `{string}` - returns the full path from the root down to this state. \n   *   Needed for state activation.\n   * - **includes** `{object}` - returns an object that includes every state that \n   *   would pass a `$state.includes()` test.\n   *\n   * @example\n   * <pre>\n   * // Override the internal 'views' builder with a function that takes the state\n   * // definition, and a reference to the internal function being overridden:\n   * $stateProvider.decorator('views', function (state, parent) {\n   *   var result = {},\n   *       views = parent(state);\n   *\n   *   angular.forEach(views, function (config, name) {\n   *     var autoName = (state.name + '.' + name).replace('.', '/');\n   *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';\n   *     result[name] = config;\n   *   });\n   *   return result;\n   * });\n   *\n   * $stateProvider.state('home', {\n   *   views: {\n   *     'contact.list': { controller: 'ListController' },\n   *     'contact.item': { controller: 'ItemController' }\n   *   }\n   * });\n   *\n   * // ...\n   *\n   * $state.go('home');\n   * // Auto-populates list and item views with /partials/home/contact/list.html,\n   * // and /partials/home/contact/item.html, respectively.\n   * </pre>\n   *\n   * @param {string} name The name of the builder function to decorate. \n   * @param {object} func A function that is responsible for decorating the original \n   * builder function. The function receives two parameters:\n   *\n   *   - `{object}` - state - The state config object.\n   *   - `{object}` - super - The original builder function.\n   *\n   * @return {object} $stateProvider - $stateProvider instance\n   */\n  this.decorator = decorator;\n  function decorator(name, func) {\n    /*jshint validthis: true */\n    if (isString(name) && !isDefined(func)) {\n      return stateBuilder[name];\n    }\n    if (!isFunction(func) || !isString(name)) {\n      return this;\n    }\n    if (stateBuilder[name] && !stateBuilder.$delegates[name]) {\n      stateBuilder.$delegates[name] = stateBuilder[name];\n    }\n    stateBuilder[name] = func;\n    return this;\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$stateProvider#state\n   * @methodOf ui.router.state.$stateProvider\n   *\n   * @description\n   * Registers a state configuration under a given state name. The stateConfig object\n   * has the following acceptable properties.\n   *\n   * @param {string} name A unique state name, e.g. \"home\", \"about\", \"contacts\".\n   * To create a parent/child state use a dot, e.g. \"about.sales\", \"home.newest\".\n   * @param {object} stateConfig State configuration object.\n   * @param {string|function=} stateConfig.template\n   * <a id='template'></a>\n   *   html template as a string or a function that returns\n   *   an html template as a string which should be used by the uiView directives. This property \n   *   takes precedence over templateUrl.\n   *   \n   *   If `template` is a function, it will be called with the following parameters:\n   *\n   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by\n   *     applying the current state\n   *\n   * <pre>template:\n   *   \"<h1>inline template definition</h1>\" +\n   *   \"<div ui-view></div>\"</pre>\n   * <pre>template: function(params) {\n   *       return \"<h1>generated template</h1>\"; }</pre>\n   * </div>\n   *\n   * @param {string|function=} stateConfig.templateUrl\n   * <a id='templateUrl'></a>\n   *\n   *   path or function that returns a path to an html\n   *   template that should be used by uiView.\n   *   \n   *   If `templateUrl` is a function, it will be called with the following parameters:\n   *\n   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by \n   *     applying the current state\n   *\n   * <pre>templateUrl: \"home.html\"</pre>\n   * <pre>templateUrl: function(params) {\n   *     return myTemplates[params.pageId]; }</pre>\n   *\n   * @param {function=} stateConfig.templateProvider\n   * <a id='templateProvider'></a>\n   *    Provider function that returns HTML content string.\n   * <pre> templateProvider:\n   *       function(MyTemplateService, params) {\n   *         return MyTemplateService.getTemplate(params.pageId);\n   *       }</pre>\n   *\n   * @param {string|function=} stateConfig.controller\n   * <a id='controller'></a>\n   *\n   *  Controller fn that should be associated with newly\n   *   related scope or the name of a registered controller if passed as a string.\n   *   Optionally, the ControllerAs may be declared here.\n   * <pre>controller: \"MyRegisteredController\"</pre>\n   * <pre>controller:\n   *     \"MyRegisteredController as fooCtrl\"}</pre>\n   * <pre>controller: function($scope, MyService) {\n   *     $scope.data = MyService.getData(); }</pre>\n   *\n   * @param {function=} stateConfig.controllerProvider\n   * <a id='controllerProvider'></a>\n   *\n   * Injectable provider function that returns the actual controller or string.\n   * <pre>controllerProvider:\n   *   function(MyResolveData) {\n   *     if (MyResolveData.foo)\n   *       return \"FooCtrl\"\n   *     else if (MyResolveData.bar)\n   *       return \"BarCtrl\";\n   *     else return function($scope) {\n   *       $scope.baz = \"Qux\";\n   *     }\n   *   }</pre>\n   *\n   * @param {string=} stateConfig.controllerAs\n   * <a id='controllerAs'></a>\n   * \n   * A controller alias name. If present the controller will be\n   *   published to scope under the controllerAs name.\n   * <pre>controllerAs: \"myCtrl\"</pre>\n   *\n   * @param {string|object=} stateConfig.parent\n   * <a id='parent'></a>\n   * Optionally specifies the parent state of this state.\n   *\n   * <pre>parent: 'parentState'</pre>\n   * <pre>parent: parentState // JS variable</pre>\n   *\n   * @param {object=} stateConfig.resolve\n   * <a id='resolve'></a>\n   *\n   * An optional map&lt;string, function&gt; of dependencies which\n   *   should be injected into the controller. If any of these dependencies are promises, \n   *   the router will wait for them all to be resolved before the controller is instantiated.\n   *   If all the promises are resolved successfully, the $stateChangeSuccess event is fired\n   *   and the values of the resolved promises are injected into any controllers that reference them.\n   *   If any  of the promises are rejected the $stateChangeError event is fired.\n   *\n   *   The map object is:\n   *   \n   *   - key - {string}: name of dependency to be injected into controller\n   *   - factory - {string|function}: If string then it is alias for service. Otherwise if function, \n   *     it is injected and return value it treated as dependency. If result is a promise, it is \n   *     resolved before its value is injected into controller.\n   *\n   * <pre>resolve: {\n   *     myResolve1:\n   *       function($http, $stateParams) {\n   *         return $http.get(\"/api/foos/\"+stateParams.fooID);\n   *       }\n   *     }</pre>\n   *\n   * @param {string=} stateConfig.url\n   * <a id='url'></a>\n   *\n   *   A url fragment with optional parameters. When a state is navigated or\n   *   transitioned to, the `$stateParams` service will be populated with any \n   *   parameters that were passed.\n   *\n   *   (See {@link ui.router.util.type:UrlMatcher UrlMatcher} `UrlMatcher`} for\n   *   more details on acceptable patterns )\n   *\n   * examples:\n   * <pre>url: \"/home\"\n   * url: \"/users/:userid\"\n   * url: \"/books/{bookid:[a-zA-Z_-]}\"\n   * url: \"/books/{categoryid:int}\"\n   * url: \"/books/{publishername:string}/{categoryid:int}\"\n   * url: \"/messages?before&after\"\n   * url: \"/messages?{before:date}&{after:date}\"\n   * url: \"/messages/:mailboxid?{before:date}&{after:date}\"\n   * </pre>\n   *\n   * @param {object=} stateConfig.views\n   * <a id='views'></a>\n   * an optional map&lt;string, object&gt; which defined multiple views, or targets views\n   * manually/explicitly.\n   *\n   * Examples:\n   *\n   * Targets three named `ui-view`s in the parent state's template\n   * <pre>views: {\n   *     header: {\n   *       controller: \"headerCtrl\",\n   *       templateUrl: \"header.html\"\n   *     }, body: {\n   *       controller: \"bodyCtrl\",\n   *       templateUrl: \"body.html\"\n   *     }, footer: {\n   *       controller: \"footCtrl\",\n   *       templateUrl: \"footer.html\"\n   *     }\n   *   }</pre>\n   *\n   * Targets named `ui-view=\"header\"` from grandparent state 'top''s template, and named `ui-view=\"body\" from parent state's template.\n   * <pre>views: {\n   *     'header@top': {\n   *       controller: \"msgHeaderCtrl\",\n   *       templateUrl: \"msgHeader.html\"\n   *     }, 'body': {\n   *       controller: \"messagesCtrl\",\n   *       templateUrl: \"messages.html\"\n   *     }\n   *   }</pre>\n   *\n   * @param {boolean=} [stateConfig.abstract=false]\n   * <a id='abstract'></a>\n   * An abstract state will never be directly activated,\n   *   but can provide inherited properties to its common children states.\n   * <pre>abstract: true</pre>\n   *\n   * @param {function=} stateConfig.onEnter\n   * <a id='onEnter'></a>\n   *\n   * Callback function for when a state is entered. Good way\n   *   to trigger an action or dispatch an event, such as opening a dialog.\n   * If minifying your scripts, make sure to explicitly annotate this function,\n   * because it won't be automatically annotated by your build tools.\n   *\n   * <pre>onEnter: function(MyService, $stateParams) {\n   *     MyService.foo($stateParams.myParam);\n   * }</pre>\n   *\n   * @param {function=} stateConfig.onExit\n   * <a id='onExit'></a>\n   *\n   * Callback function for when a state is exited. Good way to\n   *   trigger an action or dispatch an event, such as opening a dialog.\n   * If minifying your scripts, make sure to explicitly annotate this function,\n   * because it won't be automatically annotated by your build tools.\n   *\n   * <pre>onExit: function(MyService, $stateParams) {\n   *     MyService.cleanup($stateParams.myParam);\n   * }</pre>\n   *\n   * @param {boolean=} [stateConfig.reloadOnSearch=true]\n   * <a id='reloadOnSearch'></a>\n   *\n   * If `false`, will not retrigger the same state\n   *   just because a search/query parameter has changed (via $location.search() or $location.hash()). \n   *   Useful for when you'd like to modify $location.search() without triggering a reload.\n   * <pre>reloadOnSearch: false</pre>\n   *\n   * @param {object=} stateConfig.data\n   * <a id='data'></a>\n   *\n   * Arbitrary data object, useful for custom configuration.  The parent state's `data` is\n   *   prototypally inherited.  In other words, adding a data property to a state adds it to\n   *   the entire subtree via prototypal inheritance.\n   *\n   * <pre>data: {\n   *     requiredRole: 'foo'\n   * } </pre>\n   *\n   * @param {object=} stateConfig.params\n   * <a id='params'></a>\n   *\n   * A map which optionally configures parameters declared in the `url`, or\n   *   defines additional non-url parameters.  For each parameter being\n   *   configured, add a configuration object keyed to the name of the parameter.\n   *\n   *   Each parameter configuration object may contain the following properties:\n   *\n   *   - ** value ** - {object|function=}: specifies the default value for this\n   *     parameter.  This implicitly sets this parameter as optional.\n   *\n   *     When UI-Router routes to a state and no value is\n   *     specified for this parameter in the URL or transition, the\n   *     default value will be used instead.  If `value` is a function,\n   *     it will be injected and invoked, and the return value used.\n   *\n   *     *Note*: `undefined` is treated as \"no default value\" while `null`\n   *     is treated as \"the default value is `null`\".\n   *\n   *     *Shorthand*: If you only need to configure the default value of the\n   *     parameter, you may use a shorthand syntax.   In the **`params`**\n   *     map, instead mapping the param name to a full parameter configuration\n   *     object, simply set map it to the default parameter value, e.g.:\n   *\n   * <pre>// define a parameter's default value\n   * params: {\n   *     param1: { value: \"defaultValue\" }\n   * }\n   * // shorthand default values\n   * params: {\n   *     param1: \"defaultValue\",\n   *     param2: \"param2Default\"\n   * }</pre>\n   *\n   *   - ** array ** - {boolean=}: *(default: false)* If true, the param value will be\n   *     treated as an array of values.  If you specified a Type, the value will be\n   *     treated as an array of the specified Type.  Note: query parameter values\n   *     default to a special `\"auto\"` mode.\n   *\n   *     For query parameters in `\"auto\"` mode, if multiple  values for a single parameter\n   *     are present in the URL (e.g.: `/foo?bar=1&bar=2&bar=3`) then the values\n   *     are mapped to an array (e.g.: `{ foo: [ '1', '2', '3' ] }`).  However, if\n   *     only one value is present (e.g.: `/foo?bar=1`) then the value is treated as single\n   *     value (e.g.: `{ foo: '1' }`).\n   *\n   * <pre>params: {\n   *     param1: { array: true }\n   * }</pre>\n   *\n   *   - ** squash ** - {bool|string=}: `squash` configures how a default parameter value is represented in the URL when\n   *     the current parameter value is the same as the default value. If `squash` is not set, it uses the\n   *     configured default squash policy.\n   *     (See {@link ui.router.util.$urlMatcherFactory#methods_defaultSquashPolicy `defaultSquashPolicy()`})\n   *\n   *   There are three squash settings:\n   *\n   *     - false: The parameter's default value is not squashed.  It is encoded and included in the URL\n   *     - true: The parameter's default value is omitted from the URL.  If the parameter is preceeded and followed\n   *       by slashes in the state's `url` declaration, then one of those slashes are omitted.\n   *       This can allow for cleaner looking URLs.\n   *     - `\"<arbitrary string>\"`: The parameter's default value is replaced with an arbitrary placeholder of  your choice.\n   *\n   * <pre>params: {\n   *     param1: {\n   *       value: \"defaultId\",\n   *       squash: true\n   * } }\n   * // squash \"defaultValue\" to \"~\"\n   * params: {\n   *     param1: {\n   *       value: \"defaultValue\",\n   *       squash: \"~\"\n   * } }\n   * </pre>\n   *\n   *\n   * @example\n   * <pre>\n   * // Some state name examples\n   *\n   * // stateName can be a single top-level name (must be unique).\n   * $stateProvider.state(\"home\", {});\n   *\n   * // Or it can be a nested state name. This state is a child of the\n   * // above \"home\" state.\n   * $stateProvider.state(\"home.newest\", {});\n   *\n   * // Nest states as deeply as needed.\n   * $stateProvider.state(\"home.newest.abc.xyz.inception\", {});\n   *\n   * // state() returns $stateProvider, so you can chain state declarations.\n   * $stateProvider\n   *   .state(\"home\", {})\n   *   .state(\"about\", {})\n   *   .state(\"contacts\", {});\n   * </pre>\n   *\n   */\n  this.state = state;\n  function state(name, definition) {\n    /*jshint validthis: true */\n    if (isObject(name)) definition = name;\n    else definition.name = name;\n    registerState(definition);\n    return this;\n  }\n\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$state\n   *\n   * @requires $rootScope\n   * @requires $q\n   * @requires ui.router.state.$view\n   * @requires $injector\n   * @requires ui.router.util.$resolve\n   * @requires ui.router.state.$stateParams\n   * @requires ui.router.router.$urlRouter\n   *\n   * @property {object} params A param object, e.g. {sectionId: section.id)}, that \n   * you'd like to test against the current active state.\n   * @property {object} current A reference to the state's config object. However \n   * you passed it in. Useful for accessing custom data.\n   * @property {object} transition Currently pending transition. A promise that'll \n   * resolve or reject.\n   *\n   * @description\n   * `$state` service is responsible for representing states as well as transitioning\n   * between them. It also provides interfaces to ask for current state or even states\n   * you're coming from.\n   */\n  this.$get = $get;\n  $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];\n  function $get(   $rootScope,   $q,   $view,   $injector,   $resolve,   $stateParams,   $urlRouter,   $location,   $urlMatcherFactory) {\n\n    var TransitionSuperseded = $q.reject(new Error('transition superseded'));\n    var TransitionPrevented = $q.reject(new Error('transition prevented'));\n    var TransitionAborted = $q.reject(new Error('transition aborted'));\n    var TransitionFailed = $q.reject(new Error('transition failed'));\n\n    // Handles the case where a state which is the target of a transition is not found, and the user\n    // can optionally retry or defer the transition\n    function handleRedirect(redirect, state, params, options) {\n      /**\n       * @ngdoc event\n       * @name ui.router.state.$state#$stateNotFound\n       * @eventOf ui.router.state.$state\n       * @eventType broadcast on root scope\n       * @description\n       * Fired when a requested state **cannot be found** using the provided state name during transition.\n       * The event is broadcast allowing any handlers a single chance to deal with the error (usually by\n       * lazy-loading the unfound state). A special `unfoundState` object is passed to the listener handler,\n       * you can see its three properties in the example. You can use `event.preventDefault()` to abort the\n       * transition and the promise returned from `go` will be rejected with a `'transition aborted'` value.\n       *\n       * @param {Object} event Event object.\n       * @param {Object} unfoundState Unfound State information. Contains: `to, toParams, options` properties.\n       * @param {State} fromState Current state object.\n       * @param {Object} fromParams Current state params.\n       *\n       * @example\n       *\n       * <pre>\n       * // somewhere, assume lazy.state has not been defined\n       * $state.go(\"lazy.state\", {a:1, b:2}, {inherit:false});\n       *\n       * // somewhere else\n       * $scope.$on('$stateNotFound',\n       * function(event, unfoundState, fromState, fromParams){\n       *     console.log(unfoundState.to); // \"lazy.state\"\n       *     console.log(unfoundState.toParams); // {a:1, b:2}\n       *     console.log(unfoundState.options); // {inherit:false} + default options\n       * })\n       * </pre>\n       */\n      var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);\n\n      if (evt.defaultPrevented) {\n        $urlRouter.update();\n        return TransitionAborted;\n      }\n\n      if (!evt.retry) {\n        return null;\n      }\n\n      // Allow the handler to return a promise to defer state lookup retry\n      if (options.$retry) {\n        $urlRouter.update();\n        return TransitionFailed;\n      }\n      var retryTransition = $state.transition = $q.when(evt.retry);\n\n      retryTransition.then(function() {\n        if (retryTransition !== $state.transition) return TransitionSuperseded;\n        redirect.options.$retry = true;\n        return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);\n      }, function() {\n        return TransitionAborted;\n      });\n      $urlRouter.update();\n\n      return retryTransition;\n    }\n\n    root.locals = { resolve: null, globals: { $stateParams: {} } };\n\n    $state = {\n      params: {},\n      current: root.self,\n      $current: root,\n      transition: null\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#reload\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A method that force reloads the current state. All resolves are re-resolved,\n     * controllers reinstantiated, and events re-fired.\n     *\n     * @example\n     * <pre>\n     * var app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     $state.reload();\n     *   }\n     * });\n     * </pre>\n     *\n     * `reload()` is just an alias for:\n     * <pre>\n     * $state.transitionTo($state.current, $stateParams, { \n     *   reload: true, inherit: false, notify: true\n     * });\n     * </pre>\n     *\n     * @param {string=|object=} state - A state name or a state object, which is the root of the resolves to be re-resolved.\n     * @example\n     * <pre>\n     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item' \n     * //and current state is 'contacts.detail.item'\n     * var app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     //will reload 'contact.detail' and 'contact.detail.item' states\n     *     $state.reload('contact.detail');\n     *   }\n     * });\n     * </pre>\n     *\n     * `reload()` is just an alias for:\n     * <pre>\n     * $state.transitionTo($state.current, $stateParams, { \n     *   reload: true, inherit: false, notify: true\n     * });\n     * </pre>\n\n     * @returns {promise} A promise representing the state of the new transition. See\n     * {@link ui.router.state.$state#methods_go $state.go}.\n     */\n    $state.reload = function reload(state) {\n      return $state.transitionTo($state.current, $stateParams, { reload: state || true, inherit: false, notify: true});\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#go\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Convenience method for transitioning to a new state. `$state.go` calls \n     * `$state.transitionTo` internally but automatically sets options to \n     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`. \n     * This allows you to easily use an absolute or relative to path and specify \n     * only the parameters you'd like to update (while letting unspecified parameters \n     * inherit from the currently active ancestor states).\n     *\n     * @example\n     * <pre>\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.go('contact.detail');\n     *   };\n     * });\n     * </pre>\n     * <img src='../ngdoc_assets/StateGoExamples.png'/>\n     *\n     * @param {string} to Absolute state name or relative state path. Some examples:\n     *\n     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n     * - `$state.go('^')` - will go to a parent state\n     * - `$state.go('^.sibling')` - will go to a sibling state\n     * - `$state.go('.child.grandchild')` - will go to grandchild state\n     *\n     * @param {object=} params A map of the parameters that will be sent to the state, \n     * will populate $stateParams. Any parameters that are not specified will be inherited from currently \n     * defined parameters. Only parameters specified in the state definition can be overridden, new \n     * parameters will be ignored. This allows, for example, going to a sibling state that shares parameters\n     * specified in a parent state. Parameter inheritance only works between common ancestor states, I.e.\n     * transitioning to a sibling will get you the parameters for all parents, transitioning to a child\n     * will get you all current parameters, etc.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n     * - **`reload`** (v0.2.5) - {boolean=false|string|object}, If `true` will force transition even if no state or params\n     *    have changed.  It will reload the resolves and views of the current state and parent states.\n     *    If `reload` is a string (or state object), the state object is fetched (by name, or object reference); and \\\n     *    the transition reloads the resolves and views for that matched state, and all its children states.\n     *\n     * @returns {promise} A promise representing the state of the new transition.\n     *\n     * Possible success values:\n     *\n     * - $state.current\n     *\n     * <br/>Possible rejection values:\n     *\n     * - 'transition superseded' - when a newer transition has been started after this one\n     * - 'transition prevented' - when `event.preventDefault()` has been called in a `$stateChangeStart` listener\n     * - 'transition aborted' - when `event.preventDefault()` has been called in a `$stateNotFound` listener or\n     *   when a `$stateNotFound` `event.retry` promise errors.\n     * - 'transition failed' - when a state has been unsuccessfully found after 2 tries.\n     * - *resolve error* - when an error has occurred with a `resolve`\n     *\n     */\n    $state.go = function go(to, params, options) {\n      return $state.transitionTo(to, params, extend({ inherit: true, relative: $state.$current }, options));\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#transitionTo\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Low-level method for transitioning to a new state. {@link ui.router.state.$state#methods_go $state.go}\n     * uses `transitionTo` internally. `$state.go` is recommended in most situations.\n     *\n     * @example\n     * <pre>\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.transitionTo('contact.detail');\n     *   };\n     * });\n     * </pre>\n     *\n     * @param {string} to State name.\n     * @param {object=} toParams A map of the parameters that will be sent to the state,\n     * will populate $stateParams.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n     * - **`inherit`** - {boolean=false}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n     * - **`reload`** (v0.2.5) - {boolean=false|string=|object=}, If `true` will force transition even if the state or params \n     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n     *    use this when you want to force a reload when *everything* is the same, including search params.\n     *    if String, then will reload the state with the name given in reload, and any children.\n     *    if Object, then a stateObj is expected, will reload the state found in stateObj, and any children.\n     *\n     * @returns {promise} A promise representing the state of the new transition. See\n     * {@link ui.router.state.$state#methods_go $state.go}.\n     */\n    $state.transitionTo = function transitionTo(to, toParams, options) {\n      toParams = toParams || {};\n      options = extend({\n        location: true, inherit: false, relative: null, notify: true, reload: false, $retry: false\n      }, options || {});\n\n      var from = $state.$current, fromParams = $state.params, fromPath = from.path;\n      var evt, toState = findState(to, options.relative);\n\n      // Store the hash param for later (since it will be stripped out by various methods)\n      var hash = toParams['#'];\n\n      if (!isDefined(toState)) {\n        var redirect = { to: to, toParams: toParams, options: options };\n        var redirectResult = handleRedirect(redirect, from.self, fromParams, options);\n\n        if (redirectResult) {\n          return redirectResult;\n        }\n\n        // Always retry once if the $stateNotFound was not prevented\n        // (handles either redirect changed or state lazy-definition)\n        to = redirect.to;\n        toParams = redirect.toParams;\n        options = redirect.options;\n        toState = findState(to, options.relative);\n\n        if (!isDefined(toState)) {\n          if (!options.relative) throw new Error(\"No such state '\" + to + \"'\");\n          throw new Error(\"Could not resolve '\" + to + \"' from state '\" + options.relative + \"'\");\n        }\n      }\n      if (toState[abstractKey]) throw new Error(\"Cannot transition to abstract state '\" + to + \"'\");\n      if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);\n      if (!toState.params.$$validates(toParams)) return TransitionFailed;\n\n      toParams = toState.params.$$values(toParams);\n      to = toState;\n\n      var toPath = to.path;\n\n      // Starting from the root of the path, keep all levels that haven't changed\n      var keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];\n\n      if (!options.reload) {\n        while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {\n          locals = toLocals[keep] = state.locals;\n          keep++;\n          state = toPath[keep];\n        }\n      } else if (isString(options.reload) || isObject(options.reload)) {\n        if (isObject(options.reload) && !options.reload.name) {\n          throw new Error('Invalid reload state object');\n        }\n        \n        var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);\n        if (options.reload && !reloadState) {\n          throw new Error(\"No such reload state '\" + (isString(options.reload) ? options.reload : options.reload.name) + \"'\");\n        }\n\n        while (state && state === fromPath[keep] && state !== reloadState) {\n          locals = toLocals[keep] = state.locals;\n          keep++;\n          state = toPath[keep];\n        }\n      }\n\n      // If we're going to the same state and all locals are kept, we've got nothing to do.\n      // But clear 'transition', as we still want to cancel any other pending transitions.\n      // TODO: We may not want to bump 'transition' if we're called from a location change\n      // that we've initiated ourselves, because we might accidentally abort a legitimate\n      // transition initiated from code?\n      if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {\n        if (hash) toParams['#'] = hash;\n        $state.params = toParams;\n        copy($state.params, $stateParams);\n        copy(filterByKeys(to.params.$$keys(), $stateParams), to.locals.globals.$stateParams);\n        if (options.location && to.navigable && to.navigable.url) {\n          $urlRouter.push(to.navigable.url, toParams, {\n            $$avoidResync: true, replace: options.location === 'replace'\n          });\n          $urlRouter.update(true);\n        }\n        $state.transition = null;\n        return $q.when($state.current);\n      }\n\n      // Filter parameters before we pass them to event handlers etc.\n      toParams = filterByKeys(to.params.$$keys(), toParams || {});\n      \n      // Re-add the saved hash before we start returning things or broadcasting $stateChangeStart\n      if (hash) toParams['#'] = hash;\n      \n      // Broadcast start event and cancel the transition if requested\n      if (options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeStart\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired when the state transition **begins**. You can use `event.preventDefault()`\n         * to prevent the transition from happening and then the transition promise will be\n         * rejected with a `'transition prevented'` value.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         *\n         * @example\n         *\n         * <pre>\n         * $rootScope.$on('$stateChangeStart',\n         * function(event, toState, toParams, fromState, fromParams){\n         *     event.preventDefault();\n         *     // transitionTo() promise will be rejected with\n         *     // a 'transition prevented' error\n         * })\n         * </pre>\n         */\n        if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams, options).defaultPrevented) {\n          $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);\n          //Don't update and resync url if there's been a new transition started. see issue #2238, #600\n          if ($state.transition == null) $urlRouter.update();\n          return TransitionPrevented;\n        }\n      }\n\n      // Resolve locals for the remaining states, but don't update any global state just\n      // yet -- if anything fails to resolve the current state needs to remain untouched.\n      // We also set up an inheritance chain for the locals here. This allows the view directive\n      // to quickly look up the correct definition for each view in the current state. Even\n      // though we create the locals object itself outside resolveState(), it is initially\n      // empty and gets filled asynchronously. We need to keep track of the promise for the\n      // (fully resolved) current locals, and pass this down the chain.\n      var resolved = $q.when(locals);\n\n      for (var l = keep; l < toPath.length; l++, state = toPath[l]) {\n        locals = toLocals[l] = inherit(locals);\n        resolved = resolveState(state, toParams, state === to, resolved, locals, options);\n      }\n\n      // Once everything is resolved, we are ready to perform the actual transition\n      // and return a promise for the new state. We also keep track of what the\n      // current promise is, so that we can detect overlapping transitions and\n      // keep only the outcome of the last transition.\n      var transition = $state.transition = resolved.then(function () {\n        var l, entering, exiting;\n\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        // Exit 'from' states not kept\n        for (l = fromPath.length - 1; l >= keep; l--) {\n          exiting = fromPath[l];\n          if (exiting.self.onExit) {\n            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);\n          }\n          exiting.locals = null;\n        }\n\n        // Enter 'to' states not kept\n        for (l = keep; l < toPath.length; l++) {\n          entering = toPath[l];\n          entering.locals = toLocals[l];\n          if (entering.self.onEnter) {\n            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);\n          }\n        }\n\n        // Run it again, to catch any transitions in callbacks\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        // Update globals in $state\n        $state.$current = to;\n        $state.current = to.self;\n        $state.params = toParams;\n        copy($state.params, $stateParams);\n        $state.transition = null;\n\n        if (options.location && to.navigable) {\n          $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {\n            $$avoidResync: true, replace: options.location === 'replace'\n          });\n        }\n\n        if (options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeSuccess\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired once the state transition is **complete**.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         */\n          $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);\n        }\n        $urlRouter.update(true);\n\n        return $state.current;\n      }).then(null, function (error) {\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        $state.transition = null;\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeError\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired when an **error occurs** during transition. It's important to note that if you\n         * have any errors in your resolve functions (javascript errors, non-existent services, etc)\n         * they will not throw traditionally. You must listen for this $stateChangeError event to\n         * catch **ALL** errors.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         * @param {Error} error The resolve error object.\n         */\n        evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);\n\n        if (!evt.defaultPrevented) {\n            $urlRouter.update();\n        }\n\n        return $q.reject(error);\n      });\n\n      return transition;\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#is\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Similar to {@link ui.router.state.$state#methods_includes $state.includes},\n     * but only checks for the full state name. If params is supplied then it will be\n     * tested for strict equality against the current active params object, so all params\n     * must match with none missing and no extras.\n     *\n     * @example\n     * <pre>\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // absolute name\n     * $state.is('contact.details.item'); // returns true\n     * $state.is(contactDetailItemStateObject); // returns true\n     *\n     * // relative name (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n     * </pre>\n     *\n     * @param {string|object} stateOrName The state name (absolute or relative) or state object you'd like to check.\n     * @param {object=} params A param object, e.g. `{sectionId: section.id}`, that you'd like\n     * to test against the current active state.\n     * @param {object=} options An options object.  The options are:\n     *\n     * - **`relative`** - {string|object} -  If `stateOrName` is a relative state name and `options.relative` is set, .is will\n     * test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it is the state.\n     */\n    $state.is = function is(stateOrName, params, options) {\n      options = extend({ relative: $state.$current }, options || {});\n      var state = findState(stateOrName, options.relative);\n\n      if (!isDefined(state)) { return undefined; }\n      if ($state.$current !== state) { return false; }\n      return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#includes\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A method to determine if the current active state is equal to or is the child of the\n     * state stateName. If any params are passed then they will be tested for a match as well.\n     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n     *\n     * @example\n     * Partial and relative names\n     * <pre>\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // Using partial names\n     * $state.includes(\"contacts\"); // returns true\n     * $state.includes(\"contacts.details\"); // returns true\n     * $state.includes(\"contacts.details.item\"); // returns true\n     * $state.includes(\"contacts.list\"); // returns false\n     * $state.includes(\"about\"); // returns false\n     *\n     * // Using relative names (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * <div ng-class=\"{highlighted: $state.includes('.item')}\">Item</div>\n     * </pre>\n     *\n     * Basic globbing patterns\n     * <pre>\n     * $state.$current.name = 'contacts.details.item.url';\n     *\n     * $state.includes(\"*.details.*.*\"); // returns true\n     * $state.includes(\"*.details.**\"); // returns true\n     * $state.includes(\"**.item.**\"); // returns true\n     * $state.includes(\"*.details.item.url\"); // returns true\n     * $state.includes(\"*.details.*.url\"); // returns true\n     * $state.includes(\"*.details.*\"); // returns false\n     * $state.includes(\"item.**\"); // returns false\n     * </pre>\n     *\n     * @param {string} stateOrName A partial name, relative name, or glob pattern\n     * to be searched for within the current state name.\n     * @param {object=} params A param object, e.g. `{sectionId: section.id}`,\n     * that you'd like to test against the current active state.\n     * @param {object=} options An options object.  The options are:\n     *\n     * - **`relative`** - {string|object=} -  If `stateOrName` is a relative state reference and `options.relative` is set,\n     * .includes will test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it does include the state\n     */\n    $state.includes = function includes(stateOrName, params, options) {\n      options = extend({ relative: $state.$current }, options || {});\n      if (isString(stateOrName) && isGlob(stateOrName)) {\n        if (!doesStateMatchGlob(stateOrName)) {\n          return false;\n        }\n        stateOrName = $state.$current.name;\n      }\n\n      var state = findState(stateOrName, options.relative);\n      if (!isDefined(state)) { return undefined; }\n      if (!isDefined($state.$current.includes[state.name])) { return false; }\n      return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;\n    };\n\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#href\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A url generation method that returns the compiled url for the given state populated with the given params.\n     *\n     * @example\n     * <pre>\n     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n     * </pre>\n     *\n     * @param {string|object} stateOrName The state name or state object you'd like to generate a url from.\n     * @param {object=} params An object of parameter values to fill the state's required parameters.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the\n     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka\n     *    ancestor with a valid url).\n     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n     * \n     * @returns {string} compiled state url\n     */\n    $state.href = function href(stateOrName, params, options) {\n      options = extend({\n        lossy:    true,\n        inherit:  true,\n        absolute: false,\n        relative: $state.$current\n      }, options || {});\n\n      var state = findState(stateOrName, options.relative);\n\n      if (!isDefined(state)) return null;\n      if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state);\n      \n      var nav = (state && options.lossy) ? state.navigable : state;\n\n      if (!nav || nav.url === undefined || nav.url === null) {\n        return null;\n      }\n      return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat('#'), params || {}), {\n        absolute: options.absolute\n      });\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#get\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Returns the state configuration object for any specific state or all states.\n     *\n     * @param {string|object=} stateOrName (absolute or relative) If provided, will only get the config for\n     * the requested state. If not provided, returns an array of ALL state configs.\n     * @param {string|object=} context When stateOrName is a relative state reference, the state will be retrieved relative to context.\n     * @returns {Object|Array} State configuration object or array of all objects.\n     */\n    $state.get = function (stateOrName, context) {\n      if (arguments.length === 0) return map(objectKeys(states), function(name) { return states[name].self; });\n      var state = findState(stateOrName, context || $state.$current);\n      return (state && state.self) ? state.self : null;\n    };\n\n    function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {\n      // Make a restricted $stateParams with only the parameters that apply to this state if\n      // necessary. In addition to being available to the controller and onEnter/onExit callbacks,\n      // we also need $stateParams to be available for any $injector calls we make during the\n      // dependency resolution process.\n      var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);\n      var locals = { $stateParams: $stateParams };\n\n      // Resolve 'global' dependencies for the state, i.e. those not specific to a view.\n      // We're also including $stateParams in this; that way the parameters are restricted\n      // to the set that should be visible to the state, and are independent of when we update\n      // the global $state and $stateParams values.\n      dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);\n      var promises = [dst.resolve.then(function (globals) {\n        dst.globals = globals;\n      })];\n      if (inherited) promises.push(inherited);\n\n      function resolveViews() {\n        var viewsPromises = [];\n\n        // Resolve template and dependencies for all views.\n        forEach(state.views, function (view, name) {\n          var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});\n          injectables.$template = [ function () {\n            return $view.load(name, { view: view, locals: dst.globals, params: $stateParams, notify: options.notify }) || '';\n          }];\n\n          viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function (result) {\n            // References to the controller (only instantiated at link time)\n            if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {\n              var injectLocals = angular.extend({}, injectables, dst.globals);\n              result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);\n            } else {\n              result.$$controller = view.controller;\n            }\n            // Provide access to the state itself for internal use\n            result.$$state = state;\n            result.$$controllerAs = view.controllerAs;\n            result.$$resolveAs = view.resolveAs;\n            dst[name] = result;\n          }));\n        });\n\n        return $q.all(viewsPromises).then(function(){\n          return dst.globals;\n        });\n      }\n\n      // Wait for all the promises and then return the activation object\n      return $q.all(promises).then(resolveViews).then(function (values) {\n        return dst;\n      });\n    }\n\n    return $state;\n  }\n\n  function shouldSkipReload(to, toParams, from, fromParams, locals, options) {\n    // Return true if there are no differences in non-search (path/object) params, false if there are differences\n    function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {\n      // Identify whether all the parameters that differ between `fromParams` and `toParams` were search params.\n      function notSearchParam(key) {\n        return fromAndToState.params[key].location != \"search\";\n      }\n      var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);\n      var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));\n      var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);\n      return nonQueryParamSet.$$equals(fromParams, toParams);\n    }\n\n    // If reload was not explicitly requested\n    // and we're transitioning to the same state we're already in\n    // and    the locals didn't change\n    //     or they changed in a way that doesn't merit reloading\n    //        (reloadOnParams:false, or reloadOnSearch.false and only search params changed)\n    // Then return true.\n    if (!options.reload && to === from &&\n      (locals === from.locals || (to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams)))) {\n      return true;\n    }\n  }\n}\n\nangular.module('ui.router.state')\n  .factory('$stateParams', function () { return {}; })\n  .constant(\"$state.runtime\", { autoinject: true })\n  .provider('$state', $StateProvider)\n  // Inject $state to initialize when entering runtime. #2574\n  .run(['$injector', function ($injector) {\n    // Allow tests (stateSpec.js) to turn this off by defining this constant\n    if ($injector.get(\"$state.runtime\").autoinject) {\n      $injector.get('$state');\n    }\n  }]);\n\n\n$ViewProvider.$inject = [];\nfunction $ViewProvider() {\n\n  this.$get = $get;\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$view\n   *\n   * @requires ui.router.util.$templateFactory\n   * @requires $rootScope\n   *\n   * @description\n   *\n   */\n  $get.$inject = ['$rootScope', '$templateFactory'];\n  function $get(   $rootScope,   $templateFactory) {\n    return {\n      // $view.load('full.viewName', { template: ..., controller: ..., resolve: ..., async: false, params: ... })\n      /**\n       * @ngdoc function\n       * @name ui.router.state.$view#load\n       * @methodOf ui.router.state.$view\n       *\n       * @description\n       *\n       * @param {string} name name\n       * @param {object} options option object.\n       */\n      load: function load(name, options) {\n        var result, defaults = {\n          template: null, controller: null, view: null, locals: null, notify: true, async: true, params: {}\n        };\n        options = extend(defaults, options);\n\n        if (options.view) {\n          result = $templateFactory.fromConfig(options.view, options.params, options.locals);\n        }\n        return result;\n      }\n    };\n  }\n}\n\nangular.module('ui.router.state').provider('$view', $ViewProvider);\n\n/**\n * @ngdoc object\n * @name ui.router.state.$uiViewScrollProvider\n *\n * @description\n * Provider that returns the {@link ui.router.state.$uiViewScroll} service function.\n */\nfunction $ViewScrollProvider() {\n\n  var useAnchorScroll = false;\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$uiViewScrollProvider#useAnchorScroll\n   * @methodOf ui.router.state.$uiViewScrollProvider\n   *\n   * @description\n   * Reverts back to using the core [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll) service for\n   * scrolling based on the url anchor.\n   */\n  this.useAnchorScroll = function () {\n    useAnchorScroll = true;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$uiViewScroll\n   *\n   * @requires $anchorScroll\n   * @requires $timeout\n   *\n   * @description\n   * When called with a jqLite element, it scrolls the element into view (after a\n   * `$timeout` so the DOM has time to refresh).\n   *\n   * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,\n   * this can be enabled by calling {@link ui.router.state.$uiViewScrollProvider#methods_useAnchorScroll `$uiViewScrollProvider.useAnchorScroll()`}.\n   */\n  this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {\n    if (useAnchorScroll) {\n      return $anchorScroll;\n    }\n\n    return function ($element) {\n      return $timeout(function () {\n        $element[0].scrollIntoView();\n      }, 0, false);\n    };\n  }];\n}\n\nangular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-view\n *\n * @requires ui.router.state.$state\n * @requires $compile\n * @requires $controller\n * @requires $injector\n * @requires ui.router.state.$uiViewScroll\n * @requires $document\n *\n * @restrict ECA\n *\n * @description\n * The ui-view directive tells $state where to place your templates.\n *\n * @param {string=} name A view name. The name should be unique amongst the other views in the\n * same state. You can have views of the same name that live in different states.\n *\n * @param {string=} autoscroll It allows you to set the scroll behavior of the browser window\n * when a view is populated. By default, $anchorScroll is overridden by ui-router's custom scroll\n * service, {@link ui.router.state.$uiViewScroll}. This custom service let's you\n * scroll ui-view elements into view when they are populated during a state activation.\n *\n * *Note: To revert back to old [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll)\n * functionality, call `$uiViewScrollProvider.useAnchorScroll()`.*\n *\n * @param {string=} onload Expression to evaluate whenever the view updates.\n *\n * @example\n * A view can be unnamed or named.\n * <pre>\n * <!-- Unnamed -->\n * <div ui-view></div>\n *\n * <!-- Named -->\n * <div ui-view=\"viewName\"></div>\n * </pre>\n *\n * You can only have one unnamed view within any template (or root html). If you are only using a\n * single view and it is unnamed then you can populate it like so:\n * <pre>\n * <div ui-view></div>\n * $stateProvider.state(\"home\", {\n *   template: \"<h1>HELLO!</h1>\"\n * })\n * </pre>\n *\n * The above is a convenient shortcut equivalent to specifying your view explicitly with the {@link ui.router.state.$stateProvider#methods_state `views`}\n * config property, by name, in this case an empty name:\n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }    \n * })\n * </pre>\n *\n * But typically you'll only use the views property if you name your view or have more than one view\n * in the same template. There's not really a compelling reason to name a view if its the only one,\n * but you could if you wanted, like so:\n * <pre>\n * <div ui-view=\"main\"></div>\n * </pre>\n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"main\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }    \n * })\n * </pre>\n *\n * Really though, you'll use views to set up multiple views:\n * <pre>\n * <div ui-view></div>\n * <div ui-view=\"chart\"></div>\n * <div ui-view=\"data\"></div>\n * </pre>\n *\n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     },\n *     \"chart\": {\n *       template: \"<chart_thing/>\"\n *     },\n *     \"data\": {\n *       template: \"<data_thing/>\"\n *     }\n *   }    \n * })\n * </pre>\n *\n * Examples for `autoscroll`:\n *\n * <pre>\n * <!-- If autoscroll present with no expression,\n *      then scroll ui-view into view -->\n * <ui-view autoscroll/>\n *\n * <!-- If autoscroll present with valid expression,\n *      then scroll ui-view into view if expression evaluates to true -->\n * <ui-view autoscroll='true'/>\n * <ui-view autoscroll='false'/>\n * <ui-view autoscroll='scopeVariable'/>\n * </pre>\n *\n * Resolve data:\n *\n * The resolved data from the state's `resolve` block is placed on the scope as `$resolve` (this\n * can be customized using [[ViewDeclaration.resolveAs]]).  This can be then accessed from the template.\n *\n * Note that when `controllerAs` is being used, `$resolve` is set on the controller instance *after* the\n * controller is instantiated.  The `$onInit()` hook can be used to perform initialization code which\n * depends on `$resolve` data.\n *\n * Example usage of $resolve in a view template\n * <pre>\n * $stateProvider.state('home', {\n *   template: '<my-component user=\"$resolve.user\"></my-component>',\n *   resolve: {\n *     user: function(UserService) { return UserService.fetchUser(); }\n *   }\n * });\n * </pre>\n */\n$ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate', '$q'];\nfunction $ViewDirective(   $state,   $injector,   $uiViewScroll,   $interpolate,   $q) {\n\n  function getService() {\n    return ($injector.has) ? function(service) {\n      return $injector.has(service) ? $injector.get(service) : null;\n    } : function(service) {\n      try {\n        return $injector.get(service);\n      } catch (e) {\n        return null;\n      }\n    };\n  }\n\n  var service = getService(),\n      $animator = service('$animator'),\n      $animate = service('$animate');\n\n  // Returns a set of DOM manipulation functions based on which Angular version\n  // it should use\n  function getRenderer(attrs, scope) {\n    var statics = function() {\n      return {\n        enter: function (element, target, cb) { target.after(element); cb(); },\n        leave: function (element, cb) { element.remove(); cb(); }\n      };\n    };\n\n    if ($animate) {\n      return {\n        enter: function(element, target, cb) {\n          if (angular.version.minor > 2) {\n            $animate.enter(element, null, target).then(cb);\n          } else {\n            $animate.enter(element, null, target, cb);\n          }\n        },\n        leave: function(element, cb) {\n          if (angular.version.minor > 2) {\n            $animate.leave(element).then(cb);\n          } else {\n            $animate.leave(element, cb);\n          }\n        }\n      };\n    }\n\n    if ($animator) {\n      var animate = $animator && $animator(scope, attrs);\n\n      return {\n        enter: function(element, target, cb) {animate.enter(element, null, target); cb(); },\n        leave: function(element, cb) { animate.leave(element); cb(); }\n      };\n    }\n\n    return statics();\n  }\n\n  var directive = {\n    restrict: 'ECA',\n    terminal: true,\n    priority: 400,\n    transclude: 'element',\n    compile: function (tElement, tAttrs, $transclude) {\n      return function (scope, $element, attrs) {\n        var previousEl, currentEl, currentScope, latestLocals,\n            onloadExp     = attrs.onload || '',\n            autoScrollExp = attrs.autoscroll,\n            renderer      = getRenderer(attrs, scope),\n            inherited     = $element.inheritedData('$uiView');\n\n        scope.$on('$stateChangeSuccess', function() {\n          updateView(false);\n        });\n\n        updateView(true);\n\n        function cleanupLastView() {\n          if (previousEl) {\n            previousEl.remove();\n            previousEl = null;\n          }\n\n          if (currentScope) {\n            currentScope.$destroy();\n            currentScope = null;\n          }\n\n          if (currentEl) {\n            var $uiViewData = currentEl.data('$uiViewAnim');\n            renderer.leave(currentEl, function() {\n              $uiViewData.$$animLeave.resolve();\n              previousEl = null;\n            });\n\n            previousEl = currentEl;\n            currentEl = null;\n          }\n        }\n\n        function updateView(firstTime) {\n          var newScope,\n              name            = getUiViewName(scope, attrs, $element, $interpolate),\n              previousLocals  = name && $state.$current && $state.$current.locals[name];\n\n          if (!firstTime && previousLocals === latestLocals) return; // nothing to do\n          newScope = scope.$new();\n          latestLocals = $state.$current.locals[name];\n\n          /**\n           * @ngdoc event\n           * @name ui.router.state.directive:ui-view#$viewContentLoading\n           * @eventOf ui.router.state.directive:ui-view\n           * @eventType emits on ui-view directive scope\n           * @description\n           *\n           * Fired once the view **begins loading**, *before* the DOM is rendered.\n           *\n           * @param {Object} event Event object.\n           * @param {string} viewName Name of the view.\n           */\n          newScope.$emit('$viewContentLoading', name);\n\n          var clone = $transclude(newScope, function(clone) {\n            var animEnter = $q.defer(), animLeave = $q.defer();\n            var viewAnimData = {\n              $animEnter: animEnter.promise,\n              $animLeave: animLeave.promise,\n              $$animLeave: animLeave\n            };\n\n            clone.data('$uiViewAnim', viewAnimData);\n            renderer.enter(clone, $element, function onUiViewEnter() {\n              animEnter.resolve();\n              if(currentScope) {\n                currentScope.$emit('$viewContentAnimationEnded');\n              }\n\n              if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {\n                $uiViewScroll(clone);\n              }\n            });\n            cleanupLastView();\n          });\n\n          currentEl = clone;\n          currentScope = newScope;\n          /**\n           * @ngdoc event\n           * @name ui.router.state.directive:ui-view#$viewContentLoaded\n           * @eventOf ui.router.state.directive:ui-view\n           * @eventType emits on ui-view directive scope\n           * @description\n           * Fired once the view is **loaded**, *after* the DOM is rendered.\n           *\n           * @param {Object} event Event object.\n           * @param {string} viewName Name of the view.\n           */\n          currentScope.$emit('$viewContentLoaded', name);\n          currentScope.$eval(onloadExp);\n        }\n      };\n    }\n  };\n\n  return directive;\n}\n\n$ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];\nfunction $ViewDirectiveFill (  $compile,   $controller,   $state,   $interpolate) {\n  return {\n    restrict: 'ECA',\n    priority: -400,\n    compile: function (tElement) {\n      var initial = tElement.html();\n      return function (scope, $element, attrs) {\n        var current = $state.$current,\n            name = getUiViewName(scope, attrs, $element, $interpolate),\n            locals  = current && current.locals[name];\n\n        if (! locals) {\n          return;\n        }\n\n        $element.data('$uiView', { name: name, state: locals.$$state });\n        $element.html(locals.$template ? locals.$template : initial);\n\n        var resolveData = angular.extend({}, locals);\n        scope[locals.$$resolveAs] = resolveData;\n\n        var link = $compile($element.contents());\n\n        if (locals.$$controller) {\n          locals.$scope = scope;\n          locals.$element = $element;\n          var controller = $controller(locals.$$controller, locals);\n          if (locals.$$controllerAs) {\n            scope[locals.$$controllerAs] = controller;\n            scope[locals.$$controllerAs][locals.$$resolveAs] = resolveData;\n          }\n          if (isFunction(controller.$onInit)) controller.$onInit();\n          $element.data('$ngControllerController', controller);\n          $element.children().data('$ngControllerController', controller);\n        }\n\n        link(scope);\n      };\n    }\n  };\n}\n\n/**\n * Shared ui-view code for both directives:\n * Given scope, element, and its attributes, return the view's name\n */\nfunction getUiViewName(scope, attrs, element, $interpolate) {\n  var name = $interpolate(attrs.uiView || attrs.name || '')(scope);\n  var uiViewCreatedBy = element.inheritedData('$uiView');\n  return name.indexOf('@') >= 0 ?  name :  (name + '@' + (uiViewCreatedBy ? uiViewCreatedBy.state.name : ''));\n}\n\nangular.module('ui.router.state').directive('uiView', $ViewDirective);\nangular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);\n\nfunction parseStateRef(ref, current) {\n  var preparsed = ref.match(/^\\s*({[^}]*})\\s*$/), parsed;\n  if (preparsed) ref = current + '(' + preparsed[1] + ')';\n  parsed = ref.replace(/\\n/g, \" \").match(/^([^(]+?)\\s*(\\((.*)\\))?$/);\n  if (!parsed || parsed.length !== 4) throw new Error(\"Invalid state ref '\" + ref + \"'\");\n  return { state: parsed[1], paramExpr: parsed[3] || null };\n}\n\nfunction stateContext(el) {\n  var stateData = el.parent().inheritedData('$uiView');\n\n  if (stateData && stateData.state && stateData.state.name) {\n    return stateData.state;\n  }\n}\n\nfunction getTypeInfo(el) {\n  // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.\n  var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';\n  var isForm = el[0].nodeName === \"FORM\";\n\n  return {\n    attr: isForm ? \"action\" : (isSvg ? 'xlink:href' : 'href'),\n    isAnchor: el.prop(\"tagName\").toUpperCase() === \"A\",\n    clickable: !isForm\n  };\n}\n\nfunction clickHook(el, $state, $timeout, type, current) {\n  return function(e) {\n    var button = e.which || e.button, target = current();\n\n    if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {\n      // HACK: This is to allow ng-clicks to be processed before the transition is initiated:\n      var transition = $timeout(function() {\n        $state.go(target.state, target.params, target.options);\n      });\n      e.preventDefault();\n\n      // if the state has no URL, ignore one preventDefault from the <a> directive.\n      var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1: 0;\n\n      e.preventDefault = function() {\n        if (ignorePreventDefaultCount-- <= 0) $timeout.cancel(transition);\n      };\n    }\n  };\n}\n\nfunction defaultOpts(el, $state) {\n  return { relative: stateContext(el) || $state.$current, inherit: true };\n}\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref\n *\n * @requires ui.router.state.$state\n * @requires $timeout\n *\n * @restrict A\n *\n * @description\n * A directive that binds a link (`<a>` tag) to a state. If the state has an associated\n * URL, the directive will automatically generate & update the `href` attribute via\n * the {@link ui.router.state.$state#methods_href $state.href()} method. Clicking\n * the link will trigger a state transition with optional parameters.\n *\n * Also middle-clicking, right-clicking, and ctrl-clicking on the link will be\n * handled natively by the browser.\n *\n * You can also use relative state paths within ui-sref, just like the relative\n * paths passed to `$state.go()`. You just need to be aware that the path is relative\n * to the state that the link lives in, in other words the state that loaded the\n * template containing the link.\n *\n * You can specify options to pass to {@link ui.router.state.$state#methods_go $state.go()}\n * using the `ui-sref-opts` attribute. Options are restricted to `location`, `inherit`,\n * and `reload`.\n *\n * @example\n * Here's an example of how you'd use ui-sref and how it would compile. If you have the\n * following template:\n * <pre>\n * <a ui-sref=\"home\">Home</a> | <a ui-sref=\"about\">About</a> | <a ui-sref=\"{page: 2}\">Next page</a>\n *\n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a ui-sref=\"contacts.detail({ id: contact.id })\">{{ contact.name }}</a>\n *     </li>\n * </ul>\n * </pre>\n *\n * Then the compiled html would be (assuming Html5Mode is off and current state is contacts):\n * <pre>\n * <a href=\"#/home\" ui-sref=\"home\">Home</a> | <a href=\"#/about\" ui-sref=\"about\">About</a> | <a href=\"#/contacts?page=2\" ui-sref=\"{page: 2}\">Next page</a>\n *\n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/1\" ui-sref=\"contacts.detail({ id: contact.id })\">Joe</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/2\" ui-sref=\"contacts.detail({ id: contact.id })\">Alice</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/3\" ui-sref=\"contacts.detail({ id: contact.id })\">Bob</a>\n *     </li>\n * </ul>\n *\n * <a ui-sref=\"home\" ui-sref-opts=\"{reload: true}\">Home</a>\n * </pre>\n *\n * @param {string} ui-sref 'stateName' can be any valid absolute or relative state\n * @param {Object} ui-sref-opts options to pass to {@link ui.router.state.$state#methods_go $state.go()}\n */\n$StateRefDirective.$inject = ['$state', '$timeout'];\nfunction $StateRefDirective($state, $timeout) {\n  return {\n    restrict: 'A',\n    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n    link: function(scope, element, attrs, uiSrefActive) {\n      var ref    = parseStateRef(attrs.uiSref, $state.current.name);\n      var def    = { state: ref.state, href: null, params: null };\n      var type   = getTypeInfo(element);\n      var active = uiSrefActive[1] || uiSrefActive[0];\n      var unlinkInfoFn = null;\n      var hookFn;\n\n      def.options = extend(defaultOpts(element, $state), attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {});\n\n      var update = function(val) {\n        if (val) def.params = angular.copy(val);\n        def.href = $state.href(ref.state, def.params, def.options);\n\n        if (unlinkInfoFn) unlinkInfoFn();\n        if (active) unlinkInfoFn = active.$$addStateInfo(ref.state, def.params);\n        if (def.href !== null) attrs.$set(type.attr, def.href);\n      };\n\n      if (ref.paramExpr) {\n        scope.$watch(ref.paramExpr, function(val) { if (val !== def.params) update(val); }, true);\n        def.params = angular.copy(scope.$eval(ref.paramExpr));\n      }\n      update();\n\n      if (!type.clickable) return;\n      hookFn = clickHook(element, $state, $timeout, type, function() { return def; });\n      element.bind(\"click\", hookFn);\n      scope.$on('$destroy', function() {\n        element.unbind(\"click\", hookFn);\n      });\n    }\n  };\n}\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-state\n *\n * @requires ui.router.state.uiSref\n *\n * @restrict A\n *\n * @description\n * Much like ui-sref, but will accept named $scope properties to evaluate for a state definition,\n * params and override options.\n *\n * @param {string} ui-state 'stateName' can be any valid absolute or relative state\n * @param {Object} ui-state-params params to pass to {@link ui.router.state.$state#methods_href $state.href()}\n * @param {Object} ui-state-opts options to pass to {@link ui.router.state.$state#methods_go $state.go()}\n */\n$StateRefDynamicDirective.$inject = ['$state', '$timeout'];\nfunction $StateRefDynamicDirective($state, $timeout) {\n  return {\n    restrict: 'A',\n    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n    link: function(scope, element, attrs, uiSrefActive) {\n      var type   = getTypeInfo(element);\n      var active = uiSrefActive[1] || uiSrefActive[0];\n      var group  = [attrs.uiState, attrs.uiStateParams || null, attrs.uiStateOpts || null];\n      var watch  = '[' + group.map(function(val) { return val || 'null'; }).join(', ') + ']';\n      var def    = { state: null, params: null, options: null, href: null };\n      var unlinkInfoFn = null;\n      var hookFn;\n\n      function runStateRefLink (group) {\n        def.state = group[0]; def.params = group[1]; def.options = group[2];\n        def.href = $state.href(def.state, def.params, def.options);\n\n        if (unlinkInfoFn) unlinkInfoFn();\n        if (active) unlinkInfoFn = active.$$addStateInfo(def.state, def.params);\n        if (def.href) attrs.$set(type.attr, def.href);\n      }\n\n      scope.$watch(watch, runStateRefLink, true);\n      runStateRefLink(scope.$eval(watch));\n\n      if (!type.clickable) return;\n      hookFn = clickHook(element, $state, $timeout, type, function() { return def; });\n      element.bind(\"click\", hookFn);\n      scope.$on('$destroy', function() {\n        element.unbind(\"click\", hookFn);\n      });\n    }\n  };\n}\n\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref-active\n *\n * @requires ui.router.state.$state\n * @requires ui.router.state.$stateParams\n * @requires $interpolate\n *\n * @restrict A\n *\n * @description\n * A directive working alongside ui-sref to add classes to an element when the\n * related ui-sref directive's state is active, and removing them when it is inactive.\n * The primary use-case is to simplify the special appearance of navigation menus\n * relying on `ui-sref`, by having the \"active\" state's menu button appear different,\n * distinguishing it from the inactive menu items.\n *\n * ui-sref-active can live on the same element as ui-sref or on a parent element. The first\n * ui-sref-active found at the same level or above the ui-sref will be used.\n *\n * Will activate when the ui-sref's target state or any child state is active. If you\n * need to activate only when the ui-sref target state is active and *not* any of\n * it's children, then you will use\n * {@link ui.router.state.directive:ui-sref-active-eq ui-sref-active-eq}\n *\n * @example\n * Given the following template:\n * <pre>\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item\">\n *     <a href ui-sref=\"app.user({user: 'bilbobaggins'})\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * </pre>\n *\n *\n * When the app state is \"app.user\" (or any children states), and contains the state parameter \"user\" with value \"bilbobaggins\",\n * the resulting HTML will appear as (note the 'active' class):\n * <pre>\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item active\">\n *     <a ui-sref=\"app.user({user: 'bilbobaggins'})\" href=\"/users/bilbobaggins\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * </pre>\n *\n * The class name is interpolated **once** during the directives link time (any further changes to the\n * interpolated value are ignored).\n *\n * Multiple classes may be specified in a space-separated format:\n * <pre>\n * <ul>\n *   <li ui-sref-active='class1 class2 class3'>\n *     <a ui-sref=\"app.user\">link</a>\n *   </li>\n * </ul>\n * </pre>\n *\n * It is also possible to pass ui-sref-active an expression that evaluates\n * to an object hash, whose keys represent active class names and whose\n * values represent the respective state names/globs.\n * ui-sref-active will match if the current active state **includes** any of\n * the specified state names/globs, even the abstract ones.\n *\n * @Example\n * Given the following template, with \"admin\" being an abstract state:\n * <pre>\n * <div ui-sref-active=\"{'active': 'admin.*'}\">\n *   <a ui-sref-active=\"active\" ui-sref=\"admin.roles\">Roles</a>\n * </div>\n * </pre>\n *\n * When the current state is \"admin.roles\" the \"active\" class will be applied\n * to both the <div> and <a> elements. It is important to note that the state\n * names/globs passed to ui-sref-active shadow the state provided by ui-sref.\n */\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref-active-eq\n *\n * @requires ui.router.state.$state\n * @requires ui.router.state.$stateParams\n * @requires $interpolate\n *\n * @restrict A\n *\n * @description\n * The same as {@link ui.router.state.directive:ui-sref-active ui-sref-active} but will only activate\n * when the exact target state used in the `ui-sref` is active; no child states.\n *\n */\n$StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];\nfunction $StateRefActiveDirective($state, $stateParams, $interpolate) {\n  return  {\n    restrict: \"A\",\n    controller: ['$scope', '$element', '$attrs', '$timeout', function ($scope, $element, $attrs, $timeout) {\n      var states = [], activeClasses = {}, activeEqClass, uiSrefActive;\n\n      // There probably isn't much point in $observing this\n      // uiSrefActive and uiSrefActiveEq share the same directive object with some\n      // slight difference in logic routing\n      activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);\n\n      try {\n        uiSrefActive = $scope.$eval($attrs.uiSrefActive);\n      } catch (e) {\n        // Do nothing. uiSrefActive is not a valid expression.\n        // Fall back to using $interpolate below\n      }\n      uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);\n      if (isObject(uiSrefActive)) {\n        forEach(uiSrefActive, function(stateOrName, activeClass) {\n          if (isString(stateOrName)) {\n            var ref = parseStateRef(stateOrName, $state.current.name);\n            addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);\n          }\n        });\n      }\n\n      // Allow uiSref to communicate with uiSrefActive[Equals]\n      this.$$addStateInfo = function (newState, newParams) {\n        // we already got an explicit state provided by ui-sref-active, so we\n        // shadow the one that comes from ui-sref\n        if (isObject(uiSrefActive) && states.length > 0) {\n          return;\n        }\n        var deregister = addState(newState, newParams, uiSrefActive);\n        update();\n        return deregister;\n      };\n\n      $scope.$on('$stateChangeSuccess', update);\n\n      function addState(stateName, stateParams, activeClass) {\n        var state = $state.get(stateName, stateContext($element));\n        var stateHash = createStateHash(stateName, stateParams);\n\n        var stateInfo = {\n          state: state || { name: stateName },\n          params: stateParams,\n          hash: stateHash\n        };\n\n        states.push(stateInfo);\n        activeClasses[stateHash] = activeClass;\n\n        return function removeState() {\n          var idx = states.indexOf(stateInfo);\n          if (idx !== -1) states.splice(idx, 1);\n        };\n      }\n\n      /**\n       * @param {string} state\n       * @param {Object|string} [params]\n       * @return {string}\n       */\n      function createStateHash(state, params) {\n        if (!isString(state)) {\n          throw new Error('state should be a string');\n        }\n        if (isObject(params)) {\n          return state + toJson(params);\n        }\n        params = $scope.$eval(params);\n        if (isObject(params)) {\n          return state + toJson(params);\n        }\n        return state;\n      }\n\n      // Update route state\n      function update() {\n        for (var i = 0; i < states.length; i++) {\n          if (anyMatch(states[i].state, states[i].params)) {\n            addClass($element, activeClasses[states[i].hash]);\n          } else {\n            removeClass($element, activeClasses[states[i].hash]);\n          }\n\n          if (exactMatch(states[i].state, states[i].params)) {\n            addClass($element, activeEqClass);\n          } else {\n            removeClass($element, activeEqClass);\n          }\n        }\n      }\n\n      function addClass(el, className) { $timeout(function () { el.addClass(className); }); }\n      function removeClass(el, className) { el.removeClass(className); }\n      function anyMatch(state, params) { return $state.includes(state.name, params); }\n      function exactMatch(state, params) { return $state.is(state.name, params); }\n\n      update();\n    }]\n  };\n}\n\nangular.module('ui.router.state')\n  .directive('uiSref', $StateRefDirective)\n  .directive('uiSrefActive', $StateRefActiveDirective)\n  .directive('uiSrefActiveEq', $StateRefActiveDirective)\n  .directive('uiState', $StateRefDynamicDirective);\n\n/**\n * @ngdoc filter\n * @name ui.router.state.filter:isState\n *\n * @requires ui.router.state.$state\n *\n * @description\n * Translates to {@link ui.router.state.$state#methods_is $state.is(\"stateName\")}.\n */\n$IsStateFilter.$inject = ['$state'];\nfunction $IsStateFilter($state) {\n  var isFilter = function (state, params) {\n    return $state.is(state, params);\n  };\n  isFilter.$stateful = true;\n  return isFilter;\n}\n\n/**\n * @ngdoc filter\n * @name ui.router.state.filter:includedByState\n *\n * @requires ui.router.state.$state\n *\n * @description\n * Translates to {@link ui.router.state.$state#methods_includes $state.includes('fullOrPartialStateName')}.\n */\n$IncludedByStateFilter.$inject = ['$state'];\nfunction $IncludedByStateFilter($state) {\n  var includesFilter = function (state, params, options) {\n    return $state.includes(state, params, options);\n  };\n  includesFilter.$stateful = true;\n  return  includesFilter;\n}\n\nangular.module('ui.router.state')\n  .filter('isState', $IsStateFilter)\n  .filter('includedByState', $IncludedByStateFilter);\n})(window, window.angular);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-ui-router/release/angular-ui-router.js\n ** module id = 3\n ** module chunks = 0\n **/","import angular from 'angular';\r\nimport uirouter from 'angular-ui-router';\r\nimport angularAnimate from 'angular-animate';\r\nimport uiBootstrap from 'angular-ui-bootstrap';\r\n\r\nimport routing from './weather.routes';\r\nimport WeatherCtrl from './weather.controller';\r\nimport apiservice from './weather.service';\r\n\r\nexport default angular.module('appNomin.weather', [uirouter, angularAnimate, uiBootstrap, apiservice])\r\n.config(routing)\r\n.controller('WeatherCtrl', WeatherCtrl)\r\n.name;\n\n\n/** WEBPACK FOOTER **\n ** ./app/weather/index.js\n **/","require('./angular-animate');\nmodule.exports = 'ngAnimate';\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-animate/index.js\n ** module id = 5\n ** module chunks = 0\n **/","/**\n * @license AngularJS v1.5.7\n * (c) 2010-2016 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular) {'use strict';\n\n/* jshint ignore:start */\nvar noop        = angular.noop;\nvar copy        = angular.copy;\nvar extend      = angular.extend;\nvar jqLite      = angular.element;\nvar forEach     = angular.forEach;\nvar isArray     = angular.isArray;\nvar isString    = angular.isString;\nvar isObject    = angular.isObject;\nvar isUndefined = angular.isUndefined;\nvar isDefined   = angular.isDefined;\nvar isFunction  = angular.isFunction;\nvar isElement   = angular.isElement;\n\nvar ELEMENT_NODE = 1;\nvar COMMENT_NODE = 8;\n\nvar ADD_CLASS_SUFFIX = '-add';\nvar REMOVE_CLASS_SUFFIX = '-remove';\nvar EVENT_CLASS_PREFIX = 'ng-';\nvar ACTIVE_CLASS_SUFFIX = '-active';\nvar PREPARE_CLASS_SUFFIX = '-prepare';\n\nvar NG_ANIMATE_CLASSNAME = 'ng-animate';\nvar NG_ANIMATE_CHILDREN_DATA = '$$ngAnimateChildren';\n\n// Detect proper transitionend/animationend event names.\nvar CSS_PREFIX = '', TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;\n\n// If unprefixed events are not supported but webkit-prefixed are, use the latter.\n// Otherwise, just use W3C names, browsers not supporting them at all will just ignore them.\n// Note: Chrome implements `window.onwebkitanimationend` and doesn't implement `window.onanimationend`\n// but at the same time dispatches the `animationend` event and not `webkitAnimationEnd`.\n// Register both events in case `window.onanimationend` is not supported because of that,\n// do the same for `transitionend` as Safari is likely to exhibit similar behavior.\n// Also, the only modern browser that uses vendor prefixes for transitions/keyframes is webkit\n// therefore there is no reason to test anymore for other vendor prefixes:\n// http://caniuse.com/#search=transition\nif (isUndefined(window.ontransitionend) && isDefined(window.onwebkittransitionend)) {\n  CSS_PREFIX = '-webkit-';\n  TRANSITION_PROP = 'WebkitTransition';\n  TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';\n} else {\n  TRANSITION_PROP = 'transition';\n  TRANSITIONEND_EVENT = 'transitionend';\n}\n\nif (isUndefined(window.onanimationend) && isDefined(window.onwebkitanimationend)) {\n  CSS_PREFIX = '-webkit-';\n  ANIMATION_PROP = 'WebkitAnimation';\n  ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';\n} else {\n  ANIMATION_PROP = 'animation';\n  ANIMATIONEND_EVENT = 'animationend';\n}\n\nvar DURATION_KEY = 'Duration';\nvar PROPERTY_KEY = 'Property';\nvar DELAY_KEY = 'Delay';\nvar TIMING_KEY = 'TimingFunction';\nvar ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';\nvar ANIMATION_PLAYSTATE_KEY = 'PlayState';\nvar SAFE_FAST_FORWARD_DURATION_VALUE = 9999;\n\nvar ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;\nvar ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;\nvar TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;\nvar TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;\n\nvar isPromiseLike = function(p) {\n  return p && p.then ? true : false;\n};\n\nvar ngMinErr = angular.$$minErr('ng');\nfunction assertArg(arg, name, reason) {\n  if (!arg) {\n    throw ngMinErr('areq', \"Argument '{0}' is {1}\", (name || '?'), (reason || \"required\"));\n  }\n  return arg;\n}\n\nfunction mergeClasses(a,b) {\n  if (!a && !b) return '';\n  if (!a) return b;\n  if (!b) return a;\n  if (isArray(a)) a = a.join(' ');\n  if (isArray(b)) b = b.join(' ');\n  return a + ' ' + b;\n}\n\nfunction packageStyles(options) {\n  var styles = {};\n  if (options && (options.to || options.from)) {\n    styles.to = options.to;\n    styles.from = options.from;\n  }\n  return styles;\n}\n\nfunction pendClasses(classes, fix, isPrefix) {\n  var className = '';\n  classes = isArray(classes)\n      ? classes\n      : classes && isString(classes) && classes.length\n          ? classes.split(/\\s+/)\n          : [];\n  forEach(classes, function(klass, i) {\n    if (klass && klass.length > 0) {\n      className += (i > 0) ? ' ' : '';\n      className += isPrefix ? fix + klass\n                            : klass + fix;\n    }\n  });\n  return className;\n}\n\nfunction removeFromArray(arr, val) {\n  var index = arr.indexOf(val);\n  if (val >= 0) {\n    arr.splice(index, 1);\n  }\n}\n\nfunction stripCommentsFromElement(element) {\n  if (element instanceof jqLite) {\n    switch (element.length) {\n      case 0:\n        return element;\n        break;\n\n      case 1:\n        // there is no point of stripping anything if the element\n        // is the only element within the jqLite wrapper.\n        // (it's important that we retain the element instance.)\n        if (element[0].nodeType === ELEMENT_NODE) {\n          return element;\n        }\n        break;\n\n      default:\n        return jqLite(extractElementNode(element));\n        break;\n    }\n  }\n\n  if (element.nodeType === ELEMENT_NODE) {\n    return jqLite(element);\n  }\n}\n\nfunction extractElementNode(element) {\n  if (!element[0]) return element;\n  for (var i = 0; i < element.length; i++) {\n    var elm = element[i];\n    if (elm.nodeType == ELEMENT_NODE) {\n      return elm;\n    }\n  }\n}\n\nfunction $$addClass($$jqLite, element, className) {\n  forEach(element, function(elm) {\n    $$jqLite.addClass(elm, className);\n  });\n}\n\nfunction $$removeClass($$jqLite, element, className) {\n  forEach(element, function(elm) {\n    $$jqLite.removeClass(elm, className);\n  });\n}\n\nfunction applyAnimationClassesFactory($$jqLite) {\n  return function(element, options) {\n    if (options.addClass) {\n      $$addClass($$jqLite, element, options.addClass);\n      options.addClass = null;\n    }\n    if (options.removeClass) {\n      $$removeClass($$jqLite, element, options.removeClass);\n      options.removeClass = null;\n    }\n  }\n}\n\nfunction prepareAnimationOptions(options) {\n  options = options || {};\n  if (!options.$$prepared) {\n    var domOperation = options.domOperation || noop;\n    options.domOperation = function() {\n      options.$$domOperationFired = true;\n      domOperation();\n      domOperation = noop;\n    };\n    options.$$prepared = true;\n  }\n  return options;\n}\n\nfunction applyAnimationStyles(element, options) {\n  applyAnimationFromStyles(element, options);\n  applyAnimationToStyles(element, options);\n}\n\nfunction applyAnimationFromStyles(element, options) {\n  if (options.from) {\n    element.css(options.from);\n    options.from = null;\n  }\n}\n\nfunction applyAnimationToStyles(element, options) {\n  if (options.to) {\n    element.css(options.to);\n    options.to = null;\n  }\n}\n\nfunction mergeAnimationDetails(element, oldAnimation, newAnimation) {\n  var target = oldAnimation.options || {};\n  var newOptions = newAnimation.options || {};\n\n  var toAdd = (target.addClass || '') + ' ' + (newOptions.addClass || '');\n  var toRemove = (target.removeClass || '') + ' ' + (newOptions.removeClass || '');\n  var classes = resolveElementClasses(element.attr('class'), toAdd, toRemove);\n\n  if (newOptions.preparationClasses) {\n    target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);\n    delete newOptions.preparationClasses;\n  }\n\n  // noop is basically when there is no callback; otherwise something has been set\n  var realDomOperation = target.domOperation !== noop ? target.domOperation : null;\n\n  extend(target, newOptions);\n\n  // TODO(matsko or sreeramu): proper fix is to maintain all animation callback in array and call at last,but now only leave has the callback so no issue with this.\n  if (realDomOperation) {\n    target.domOperation = realDomOperation;\n  }\n\n  if (classes.addClass) {\n    target.addClass = classes.addClass;\n  } else {\n    target.addClass = null;\n  }\n\n  if (classes.removeClass) {\n    target.removeClass = classes.removeClass;\n  } else {\n    target.removeClass = null;\n  }\n\n  oldAnimation.addClass = target.addClass;\n  oldAnimation.removeClass = target.removeClass;\n\n  return target;\n}\n\nfunction resolveElementClasses(existing, toAdd, toRemove) {\n  var ADD_CLASS = 1;\n  var REMOVE_CLASS = -1;\n\n  var flags = {};\n  existing = splitClassesToLookup(existing);\n\n  toAdd = splitClassesToLookup(toAdd);\n  forEach(toAdd, function(value, key) {\n    flags[key] = ADD_CLASS;\n  });\n\n  toRemove = splitClassesToLookup(toRemove);\n  forEach(toRemove, function(value, key) {\n    flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;\n  });\n\n  var classes = {\n    addClass: '',\n    removeClass: ''\n  };\n\n  forEach(flags, function(val, klass) {\n    var prop, allow;\n    if (val === ADD_CLASS) {\n      prop = 'addClass';\n      allow = !existing[klass];\n    } else if (val === REMOVE_CLASS) {\n      prop = 'removeClass';\n      allow = existing[klass];\n    }\n    if (allow) {\n      if (classes[prop].length) {\n        classes[prop] += ' ';\n      }\n      classes[prop] += klass;\n    }\n  });\n\n  function splitClassesToLookup(classes) {\n    if (isString(classes)) {\n      classes = classes.split(' ');\n    }\n\n    var obj = {};\n    forEach(classes, function(klass) {\n      // sometimes the split leaves empty string values\n      // incase extra spaces were applied to the options\n      if (klass.length) {\n        obj[klass] = true;\n      }\n    });\n    return obj;\n  }\n\n  return classes;\n}\n\nfunction getDomNode(element) {\n  return (element instanceof angular.element) ? element[0] : element;\n}\n\nfunction applyGeneratedPreparationClasses(element, event, options) {\n  var classes = '';\n  if (event) {\n    classes = pendClasses(event, EVENT_CLASS_PREFIX, true);\n  }\n  if (options.addClass) {\n    classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));\n  }\n  if (options.removeClass) {\n    classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));\n  }\n  if (classes.length) {\n    options.preparationClasses = classes;\n    element.addClass(classes);\n  }\n}\n\nfunction clearGeneratedClasses(element, options) {\n  if (options.preparationClasses) {\n    element.removeClass(options.preparationClasses);\n    options.preparationClasses = null;\n  }\n  if (options.activeClasses) {\n    element.removeClass(options.activeClasses);\n    options.activeClasses = null;\n  }\n}\n\nfunction blockTransitions(node, duration) {\n  // we use a negative delay value since it performs blocking\n  // yet it doesn't kill any existing transitions running on the\n  // same element which makes this safe for class-based animations\n  var value = duration ? '-' + duration + 's' : '';\n  applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);\n  return [TRANSITION_DELAY_PROP, value];\n}\n\nfunction blockKeyframeAnimations(node, applyBlock) {\n  var value = applyBlock ? 'paused' : '';\n  var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;\n  applyInlineStyle(node, [key, value]);\n  return [key, value];\n}\n\nfunction applyInlineStyle(node, styleTuple) {\n  var prop = styleTuple[0];\n  var value = styleTuple[1];\n  node.style[prop] = value;\n}\n\nfunction concatWithSpace(a,b) {\n  if (!a) return b;\n  if (!b) return a;\n  return a + ' ' + b;\n}\n\nvar $$rAFSchedulerFactory = ['$$rAF', function($$rAF) {\n  var queue, cancelFn;\n\n  function scheduler(tasks) {\n    // we make a copy since RAFScheduler mutates the state\n    // of the passed in array variable and this would be difficult\n    // to track down on the outside code\n    queue = queue.concat(tasks);\n    nextTick();\n  }\n\n  queue = scheduler.queue = [];\n\n  /* waitUntilQuiet does two things:\n   * 1. It will run the FINAL `fn` value only when an uncanceled RAF has passed through\n   * 2. It will delay the next wave of tasks from running until the quiet `fn` has run.\n   *\n   * The motivation here is that animation code can request more time from the scheduler\n   * before the next wave runs. This allows for certain DOM properties such as classes to\n   * be resolved in time for the next animation to run.\n   */\n  scheduler.waitUntilQuiet = function(fn) {\n    if (cancelFn) cancelFn();\n\n    cancelFn = $$rAF(function() {\n      cancelFn = null;\n      fn();\n      nextTick();\n    });\n  };\n\n  return scheduler;\n\n  function nextTick() {\n    if (!queue.length) return;\n\n    var items = queue.shift();\n    for (var i = 0; i < items.length; i++) {\n      items[i]();\n    }\n\n    if (!cancelFn) {\n      $$rAF(function() {\n        if (!cancelFn) nextTick();\n      });\n    }\n  }\n}];\n\n/**\n * @ngdoc directive\n * @name ngAnimateChildren\n * @restrict AE\n * @element ANY\n *\n * @description\n *\n * ngAnimateChildren allows you to specify that children of this element should animate even if any\n * of the children's parents are currently animating. By default, when an element has an active `enter`, `leave`, or `move`\n * (structural) animation, child elements that also have an active structural animation are not animated.\n *\n * Note that even if `ngAnimteChildren` is set, no child animations will run when the parent element is removed from the DOM (`leave` animation).\n *\n *\n * @param {string} ngAnimateChildren If the value is empty, `true` or `on`,\n *     then child animations are allowed. If the value is `false`, child animations are not allowed.\n *\n * @example\n * <example module=\"ngAnimateChildren\" name=\"ngAnimateChildren\" deps=\"angular-animate.js\" animations=\"true\">\n     <file name=\"index.html\">\n       <div ng-controller=\"mainController as main\">\n         <label>Show container? <input type=\"checkbox\" ng-model=\"main.enterElement\" /></label>\n         <label>Animate children? <input type=\"checkbox\" ng-model=\"main.animateChildren\" /></label>\n         <hr>\n         <div ng-animate-children=\"{{main.animateChildren}}\">\n           <div ng-if=\"main.enterElement\" class=\"container\">\n             List of items:\n             <div ng-repeat=\"item in [0, 1, 2, 3]\" class=\"item\">Item {{item}}</div>\n           </div>\n         </div>\n       </div>\n     </file>\n     <file name=\"animations.css\">\n\n      .container.ng-enter,\n      .container.ng-leave {\n        transition: all ease 1.5s;\n      }\n\n      .container.ng-enter,\n      .container.ng-leave-active {\n        opacity: 0;\n      }\n\n      .container.ng-leave,\n      .container.ng-enter-active {\n        opacity: 1;\n      }\n\n      .item {\n        background: firebrick;\n        color: #FFF;\n        margin-bottom: 10px;\n      }\n\n      .item.ng-enter,\n      .item.ng-leave {\n        transition: transform 1.5s ease;\n      }\n\n      .item.ng-enter {\n        transform: translateX(50px);\n      }\n\n      .item.ng-enter-active {\n        transform: translateX(0);\n      }\n    </file>\n    <file name=\"script.js\">\n      angular.module('ngAnimateChildren', ['ngAnimate'])\n        .controller('mainController', function() {\n          this.animateChildren = false;\n          this.enterElement = false;\n        });\n    </file>\n  </example>\n */\nvar $$AnimateChildrenDirective = ['$interpolate', function($interpolate) {\n  return {\n    link: function(scope, element, attrs) {\n      var val = attrs.ngAnimateChildren;\n      if (angular.isString(val) && val.length === 0) { //empty attribute\n        element.data(NG_ANIMATE_CHILDREN_DATA, true);\n      } else {\n        // Interpolate and set the value, so that it is available to\n        // animations that run right after compilation\n        setData($interpolate(val)(scope));\n        attrs.$observe('ngAnimateChildren', setData);\n      }\n\n      function setData(value) {\n        value = value === 'on' || value === 'true';\n        element.data(NG_ANIMATE_CHILDREN_DATA, value);\n      }\n    }\n  };\n}];\n\nvar ANIMATE_TIMER_KEY = '$$animateCss';\n\n/**\n * @ngdoc service\n * @name $animateCss\n * @kind object\n *\n * @description\n * The `$animateCss` service is a useful utility to trigger customized CSS-based transitions/keyframes\n * from a JavaScript-based animation or directly from a directive. The purpose of `$animateCss` is NOT\n * to side-step how `$animate` and ngAnimate work, but the goal is to allow pre-existing animations or\n * directives to create more complex animations that can be purely driven using CSS code.\n *\n * Note that only browsers that support CSS transitions and/or keyframe animations are capable of\n * rendering animations triggered via `$animateCss` (bad news for IE9 and lower).\n *\n * ## Usage\n * Once again, `$animateCss` is designed to be used inside of a registered JavaScript animation that\n * is powered by ngAnimate. It is possible to use `$animateCss` directly inside of a directive, however,\n * any automatic control over cancelling animations and/or preventing animations from being run on\n * child elements will not be handled by Angular. For this to work as expected, please use `$animate` to\n * trigger the animation and then setup a JavaScript animation that injects `$animateCss` to trigger\n * the CSS animation.\n *\n * The example below shows how we can create a folding animation on an element using `ng-if`:\n *\n * ```html\n * <!-- notice the `fold-animation` CSS class -->\n * <div ng-if=\"onOff\" class=\"fold-animation\">\n *   This element will go BOOM\n * </div>\n * <button ng-click=\"onOff=true\">Fold In</button>\n * ```\n *\n * Now we create the **JavaScript animation** that will trigger the CSS transition:\n *\n * ```js\n * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var height = element[0].offsetHeight;\n *       return $animateCss(element, {\n *         from: { height:'0px' },\n *         to: { height:height + 'px' },\n *         duration: 1 // one second\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * ## More Advanced Uses\n *\n * `$animateCss` is the underlying code that ngAnimate uses to power **CSS-based animations** behind the scenes. Therefore CSS hooks\n * like `.ng-EVENT`, `.ng-EVENT-active`, `.ng-EVENT-stagger` are all features that can be triggered using `$animateCss` via JavaScript code.\n *\n * This also means that just about any combination of adding classes, removing classes, setting styles, dynamically setting a keyframe animation,\n * applying a hardcoded duration or delay value, changing the animation easing or applying a stagger animation are all options that work with\n * `$animateCss`. The service itself is smart enough to figure out the combination of options and examine the element styling properties in order\n * to provide a working animation that will run in CSS.\n *\n * The example below showcases a more advanced version of the `.fold-animation` from the example above:\n *\n * ```js\n * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var height = element[0].offsetHeight;\n *       return $animateCss(element, {\n *         addClass: 'red large-text pulse-twice',\n *         easing: 'ease-out',\n *         from: { height:'0px' },\n *         to: { height:height + 'px' },\n *         duration: 1 // one second\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * Since we're adding/removing CSS classes then the CSS transition will also pick those up:\n *\n * ```css\n * /&#42; since a hardcoded duration value of 1 was provided in the JavaScript animation code,\n * the CSS classes below will be transitioned despite them being defined as regular CSS classes &#42;/\n * .red { background:red; }\n * .large-text { font-size:20px; }\n *\n * /&#42; we can also use a keyframe animation and $animateCss will make it work alongside the transition &#42;/\n * .pulse-twice {\n *   animation: 0.5s pulse linear 2;\n *   -webkit-animation: 0.5s pulse linear 2;\n * }\n *\n * @keyframes pulse {\n *   from { transform: scale(0.5); }\n *   to { transform: scale(1.5); }\n * }\n *\n * @-webkit-keyframes pulse {\n *   from { -webkit-transform: scale(0.5); }\n *   to { -webkit-transform: scale(1.5); }\n * }\n * ```\n *\n * Given this complex combination of CSS classes, styles and options, `$animateCss` will figure everything out and make the animation happen.\n *\n * ## How the Options are handled\n *\n * `$animateCss` is very versatile and intelligent when it comes to figuring out what configurations to apply to the element to ensure the animation\n * works with the options provided. Say for example we were adding a class that contained a keyframe value and we wanted to also animate some inline\n * styles using the `from` and `to` properties.\n *\n * ```js\n * var animator = $animateCss(element, {\n *   from: { background:'red' },\n *   to: { background:'blue' }\n * });\n * animator.start();\n * ```\n *\n * ```css\n * .rotating-animation {\n *   animation:0.5s rotate linear;\n *   -webkit-animation:0.5s rotate linear;\n * }\n *\n * @keyframes rotate {\n *   from { transform: rotate(0deg); }\n *   to { transform: rotate(360deg); }\n * }\n *\n * @-webkit-keyframes rotate {\n *   from { -webkit-transform: rotate(0deg); }\n *   to { -webkit-transform: rotate(360deg); }\n * }\n * ```\n *\n * The missing pieces here are that we do not have a transition set (within the CSS code nor within the `$animateCss` options) and the duration of the animation is\n * going to be detected from what the keyframe styles on the CSS class are. In this event, `$animateCss` will automatically create an inline transition\n * style matching the duration detected from the keyframe style (which is present in the CSS class that is being added) and then prepare both the transition\n * and keyframe animations to run in parallel on the element. Then when the animation is underway the provided `from` and `to` CSS styles will be applied\n * and spread across the transition and keyframe animation.\n *\n * ## What is returned\n *\n * `$animateCss` works in two stages: a preparation phase and an animation phase. Therefore when `$animateCss` is first called it will NOT actually\n * start the animation. All that is going on here is that the element is being prepared for the animation (which means that the generated CSS classes are\n * added and removed on the element). Once `$animateCss` is called it will return an object with the following properties:\n *\n * ```js\n * var animator = $animateCss(element, { ... });\n * ```\n *\n * Now what do the contents of our `animator` variable look like:\n *\n * ```js\n * {\n *   // starts the animation\n *   start: Function,\n *\n *   // ends (aborts) the animation\n *   end: Function\n * }\n * ```\n *\n * To actually start the animation we need to run `animation.start()` which will then return a promise that we can hook into to detect when the animation ends.\n * If we choose not to run the animation then we MUST run `animation.end()` to perform a cleanup on the element (since some CSS classes and styles may have been\n * applied to the element during the preparation phase). Note that all other properties such as duration, delay, transitions and keyframes are just properties\n * and that changing them will not reconfigure the parameters of the animation.\n *\n * ### runner.done() vs runner.then()\n * It is documented that `animation.start()` will return a promise object and this is true, however, there is also an additional method available on the\n * runner called `.done(callbackFn)`. The done method works the same as `.finally(callbackFn)`, however, it does **not trigger a digest to occur**.\n * Therefore, for performance reasons, it's always best to use `runner.done(callback)` instead of `runner.then()`, `runner.catch()` or `runner.finally()`\n * unless you really need a digest to kick off afterwards.\n *\n * Keep in mind that, to make this easier, ngAnimate has tweaked the JS animations API to recognize when a runner instance is returned from $animateCss\n * (so there is no need to call `runner.done(doneFn)` inside of your JavaScript animation code).\n * Check the {@link ngAnimate.$animateCss#usage animation code above} to see how this works.\n *\n * @param {DOMElement} element the element that will be animated\n * @param {object} options the animation-related options that will be applied during the animation\n *\n * * `event` - The DOM event (e.g. enter, leave, move). When used, a generated CSS class of `ng-EVENT` and `ng-EVENT-active` will be applied\n * to the element during the animation. Multiple events can be provided when spaces are used as a separator. (Note that this will not perform any DOM operation.)\n * * `structural` - Indicates that the `ng-` prefix will be added to the event class. Setting to `false` or omitting will turn `ng-EVENT` and\n * `ng-EVENT-active` in `EVENT` and `EVENT-active`. Unused if `event` is omitted.\n * * `easing` - The CSS easing value that will be applied to the transition or keyframe animation (or both).\n * * `transitionStyle` - The raw CSS transition style that will be used (e.g. `1s linear all`).\n * * `keyframeStyle` - The raw CSS keyframe animation style that will be used (e.g. `1s my_animation linear`).\n * * `from` - The starting CSS styles (a key/value object) that will be applied at the start of the animation.\n * * `to` - The ending CSS styles (a key/value object) that will be applied across the animation via a CSS transition.\n * * `addClass` - A space separated list of CSS classes that will be added to the element and spread across the animation.\n * * `removeClass` - A space separated list of CSS classes that will be removed from the element and spread across the animation.\n * * `duration` - A number value representing the total duration of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `0`\n * is provided then the animation will be skipped entirely.\n * * `delay` - A number value representing the total delay of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `true` is\n * used then whatever delay value is detected from the CSS classes will be mirrored on the elements styles (e.g. by setting delay true then the style value\n * of the element will be `transition-delay: DETECTED_VALUE`). Using `true` is useful when you want the CSS classes and inline styles to all share the same\n * CSS delay value.\n * * `stagger` - A numeric time value representing the delay between successively animated elements\n * ({@link ngAnimate#css-staggering-animations Click here to learn how CSS-based staggering works in ngAnimate.})\n * * `staggerIndex` - The numeric index representing the stagger item (e.g. a value of 5 is equal to the sixth item in the stagger; therefore when a\n *   `stagger` option value of `0.1` is used then there will be a stagger delay of `600ms`)\n * * `applyClassesEarly` - Whether or not the classes being added or removed will be used when detecting the animation. This is set by `$animate` when enter/leave/move animations are fired to ensure that the CSS classes are resolved in time. (Note that this will prevent any transitions from occurring on the classes being added and removed.)\n * * `cleanupStyles` - Whether or not the provided `from` and `to` styles will be removed once\n *    the animation is closed. This is useful for when the styles are used purely for the sake of\n *    the animation and do not have a lasting visual effect on the element (e.g. a collapse and open animation).\n *    By default this value is set to `false`.\n *\n * @return {object} an object with start and end methods and details about the animation.\n *\n * * `start` - The method to start the animation. This will return a `Promise` when called.\n * * `end` - This method will cancel the animation and remove all applied CSS classes and styles.\n */\nvar ONE_SECOND = 1000;\nvar BASE_TEN = 10;\n\nvar ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;\nvar CLOSING_TIME_BUFFER = 1.5;\n\nvar DETECT_CSS_PROPERTIES = {\n  transitionDuration:      TRANSITION_DURATION_PROP,\n  transitionDelay:         TRANSITION_DELAY_PROP,\n  transitionProperty:      TRANSITION_PROP + PROPERTY_KEY,\n  animationDuration:       ANIMATION_DURATION_PROP,\n  animationDelay:          ANIMATION_DELAY_PROP,\n  animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY\n};\n\nvar DETECT_STAGGER_CSS_PROPERTIES = {\n  transitionDuration:      TRANSITION_DURATION_PROP,\n  transitionDelay:         TRANSITION_DELAY_PROP,\n  animationDuration:       ANIMATION_DURATION_PROP,\n  animationDelay:          ANIMATION_DELAY_PROP\n};\n\nfunction getCssKeyframeDurationStyle(duration) {\n  return [ANIMATION_DURATION_PROP, duration + 's'];\n}\n\nfunction getCssDelayStyle(delay, isKeyframeAnimation) {\n  var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;\n  return [prop, delay + 's'];\n}\n\nfunction computeCssStyles($window, element, properties) {\n  var styles = Object.create(null);\n  var detectedStyles = $window.getComputedStyle(element) || {};\n  forEach(properties, function(formalStyleName, actualStyleName) {\n    var val = detectedStyles[formalStyleName];\n    if (val) {\n      var c = val.charAt(0);\n\n      // only numerical-based values have a negative sign or digit as the first value\n      if (c === '-' || c === '+' || c >= 0) {\n        val = parseMaxTime(val);\n      }\n\n      // by setting this to null in the event that the delay is not set or is set directly as 0\n      // then we can still allow for negative values to be used later on and not mistake this\n      // value for being greater than any other negative value.\n      if (val === 0) {\n        val = null;\n      }\n      styles[actualStyleName] = val;\n    }\n  });\n\n  return styles;\n}\n\nfunction parseMaxTime(str) {\n  var maxValue = 0;\n  var values = str.split(/\\s*,\\s*/);\n  forEach(values, function(value) {\n    // it's always safe to consider only second values and omit `ms` values since\n    // getComputedStyle will always handle the conversion for us\n    if (value.charAt(value.length - 1) == 's') {\n      value = value.substring(0, value.length - 1);\n    }\n    value = parseFloat(value) || 0;\n    maxValue = maxValue ? Math.max(value, maxValue) : value;\n  });\n  return maxValue;\n}\n\nfunction truthyTimingValue(val) {\n  return val === 0 || val != null;\n}\n\nfunction getCssTransitionDurationStyle(duration, applyOnlyDuration) {\n  var style = TRANSITION_PROP;\n  var value = duration + 's';\n  if (applyOnlyDuration) {\n    style += DURATION_KEY;\n  } else {\n    value += ' linear all';\n  }\n  return [style, value];\n}\n\nfunction createLocalCacheLookup() {\n  var cache = Object.create(null);\n  return {\n    flush: function() {\n      cache = Object.create(null);\n    },\n\n    count: function(key) {\n      var entry = cache[key];\n      return entry ? entry.total : 0;\n    },\n\n    get: function(key) {\n      var entry = cache[key];\n      return entry && entry.value;\n    },\n\n    put: function(key, value) {\n      if (!cache[key]) {\n        cache[key] = { total: 1, value: value };\n      } else {\n        cache[key].total++;\n      }\n    }\n  };\n}\n\n// we do not reassign an already present style value since\n// if we detect the style property value again we may be\n// detecting styles that were added via the `from` styles.\n// We make use of `isDefined` here since an empty string\n// or null value (which is what getPropertyValue will return\n// for a non-existing style) will still be marked as a valid\n// value for the style (a falsy value implies that the style\n// is to be removed at the end of the animation). If we had a simple\n// \"OR\" statement then it would not be enough to catch that.\nfunction registerRestorableStyles(backup, node, properties) {\n  forEach(properties, function(prop) {\n    backup[prop] = isDefined(backup[prop])\n        ? backup[prop]\n        : node.style.getPropertyValue(prop);\n  });\n}\n\nvar $AnimateCssProvider = ['$animateProvider', function($animateProvider) {\n  var gcsLookup = createLocalCacheLookup();\n  var gcsStaggerLookup = createLocalCacheLookup();\n\n  this.$get = ['$window', '$$jqLite', '$$AnimateRunner', '$timeout',\n               '$$forceReflow', '$sniffer', '$$rAFScheduler', '$$animateQueue',\n       function($window,   $$jqLite,   $$AnimateRunner,   $timeout,\n                $$forceReflow,   $sniffer,   $$rAFScheduler, $$animateQueue) {\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    var parentCounter = 0;\n    function gcsHashFn(node, extraClasses) {\n      var KEY = \"$$ngAnimateParentKey\";\n      var parentNode = node.parentNode;\n      var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);\n      return parentID + '-' + node.getAttribute('class') + '-' + extraClasses;\n    }\n\n    function computeCachedCssStyles(node, className, cacheKey, properties) {\n      var timings = gcsLookup.get(cacheKey);\n\n      if (!timings) {\n        timings = computeCssStyles($window, node, properties);\n        if (timings.animationIterationCount === 'infinite') {\n          timings.animationIterationCount = 1;\n        }\n      }\n\n      // we keep putting this in multiple times even though the value and the cacheKey are the same\n      // because we're keeping an internal tally of how many duplicate animations are detected.\n      gcsLookup.put(cacheKey, timings);\n      return timings;\n    }\n\n    function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {\n      var stagger;\n\n      // if we have one or more existing matches of matching elements\n      // containing the same parent + CSS styles (which is how cacheKey works)\n      // then staggering is possible\n      if (gcsLookup.count(cacheKey) > 0) {\n        stagger = gcsStaggerLookup.get(cacheKey);\n\n        if (!stagger) {\n          var staggerClassName = pendClasses(className, '-stagger');\n\n          $$jqLite.addClass(node, staggerClassName);\n\n          stagger = computeCssStyles($window, node, properties);\n\n          // force the conversion of a null value to zero incase not set\n          stagger.animationDuration = Math.max(stagger.animationDuration, 0);\n          stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);\n\n          $$jqLite.removeClass(node, staggerClassName);\n\n          gcsStaggerLookup.put(cacheKey, stagger);\n        }\n      }\n\n      return stagger || {};\n    }\n\n    var cancelLastRAFRequest;\n    var rafWaitQueue = [];\n    function waitUntilQuiet(callback) {\n      rafWaitQueue.push(callback);\n      $$rAFScheduler.waitUntilQuiet(function() {\n        gcsLookup.flush();\n        gcsStaggerLookup.flush();\n\n        // DO NOT REMOVE THIS LINE OR REFACTOR OUT THE `pageWidth` variable.\n        // PLEASE EXAMINE THE `$$forceReflow` service to understand why.\n        var pageWidth = $$forceReflow();\n\n        // we use a for loop to ensure that if the queue is changed\n        // during this looping then it will consider new requests\n        for (var i = 0; i < rafWaitQueue.length; i++) {\n          rafWaitQueue[i](pageWidth);\n        }\n        rafWaitQueue.length = 0;\n      });\n    }\n\n    function computeTimings(node, className, cacheKey) {\n      var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);\n      var aD = timings.animationDelay;\n      var tD = timings.transitionDelay;\n      timings.maxDelay = aD && tD\n          ? Math.max(aD, tD)\n          : (aD || tD);\n      timings.maxDuration = Math.max(\n          timings.animationDuration * timings.animationIterationCount,\n          timings.transitionDuration);\n\n      return timings;\n    }\n\n    return function init(element, initialOptions) {\n      // all of the animation functions should create\n      // a copy of the options data, however, if a\n      // parent service has already created a copy then\n      // we should stick to using that\n      var options = initialOptions || {};\n      if (!options.$$prepared) {\n        options = prepareAnimationOptions(copy(options));\n      }\n\n      var restoreStyles = {};\n      var node = getDomNode(element);\n      if (!node\n          || !node.parentNode\n          || !$$animateQueue.enabled()) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      var temporaryStyles = [];\n      var classes = element.attr('class');\n      var styles = packageStyles(options);\n      var animationClosed;\n      var animationPaused;\n      var animationCompleted;\n      var runner;\n      var runnerHost;\n      var maxDelay;\n      var maxDelayTime;\n      var maxDuration;\n      var maxDurationTime;\n      var startTime;\n      var events = [];\n\n      if (options.duration === 0 || (!$sniffer.animations && !$sniffer.transitions)) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      var method = options.event && isArray(options.event)\n            ? options.event.join(' ')\n            : options.event;\n\n      var isStructural = method && options.structural;\n      var structuralClassName = '';\n      var addRemoveClassName = '';\n\n      if (isStructural) {\n        structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);\n      } else if (method) {\n        structuralClassName = method;\n      }\n\n      if (options.addClass) {\n        addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);\n      }\n\n      if (options.removeClass) {\n        if (addRemoveClassName.length) {\n          addRemoveClassName += ' ';\n        }\n        addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);\n      }\n\n      // there may be a situation where a structural animation is combined together\n      // with CSS classes that need to resolve before the animation is computed.\n      // However this means that there is no explicit CSS code to block the animation\n      // from happening (by setting 0s none in the class name). If this is the case\n      // we need to apply the classes before the first rAF so we know to continue if\n      // there actually is a detected transition or keyframe animation\n      if (options.applyClassesEarly && addRemoveClassName.length) {\n        applyAnimationClasses(element, options);\n      }\n\n      var preparationClasses = [structuralClassName, addRemoveClassName].join(' ').trim();\n      var fullClassName = classes + ' ' + preparationClasses;\n      var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);\n      var hasToStyles = styles.to && Object.keys(styles.to).length > 0;\n      var containsKeyframeAnimation = (options.keyframeStyle || '').length > 0;\n\n      // there is no way we can trigger an animation if no styles and\n      // no classes are being applied which would then trigger a transition,\n      // unless there a is raw keyframe value that is applied to the element.\n      if (!containsKeyframeAnimation\n           && !hasToStyles\n           && !preparationClasses) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      var cacheKey, stagger;\n      if (options.stagger > 0) {\n        var staggerVal = parseFloat(options.stagger);\n        stagger = {\n          transitionDelay: staggerVal,\n          animationDelay: staggerVal,\n          transitionDuration: 0,\n          animationDuration: 0\n        };\n      } else {\n        cacheKey = gcsHashFn(node, fullClassName);\n        stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);\n      }\n\n      if (!options.$$skipPreparationClasses) {\n        $$jqLite.addClass(element, preparationClasses);\n      }\n\n      var applyOnlyDuration;\n\n      if (options.transitionStyle) {\n        var transitionStyle = [TRANSITION_PROP, options.transitionStyle];\n        applyInlineStyle(node, transitionStyle);\n        temporaryStyles.push(transitionStyle);\n      }\n\n      if (options.duration >= 0) {\n        applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;\n        var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);\n\n        // we set the duration so that it will be picked up by getComputedStyle later\n        applyInlineStyle(node, durationStyle);\n        temporaryStyles.push(durationStyle);\n      }\n\n      if (options.keyframeStyle) {\n        var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];\n        applyInlineStyle(node, keyframeStyle);\n        temporaryStyles.push(keyframeStyle);\n      }\n\n      var itemIndex = stagger\n          ? options.staggerIndex >= 0\n              ? options.staggerIndex\n              : gcsLookup.count(cacheKey)\n          : 0;\n\n      var isFirst = itemIndex === 0;\n\n      // this is a pre-emptive way of forcing the setup classes to be added and applied INSTANTLY\n      // without causing any combination of transitions to kick in. By adding a negative delay value\n      // it forces the setup class' transition to end immediately. We later then remove the negative\n      // transition delay to allow for the transition to naturally do it's thing. The beauty here is\n      // that if there is no transition defined then nothing will happen and this will also allow\n      // other transitions to be stacked on top of each other without any chopping them out.\n      if (isFirst && !options.skipBlocking) {\n        blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);\n      }\n\n      var timings = computeTimings(node, fullClassName, cacheKey);\n      var relativeDelay = timings.maxDelay;\n      maxDelay = Math.max(relativeDelay, 0);\n      maxDuration = timings.maxDuration;\n\n      var flags = {};\n      flags.hasTransitions          = timings.transitionDuration > 0;\n      flags.hasAnimations           = timings.animationDuration > 0;\n      flags.hasTransitionAll        = flags.hasTransitions && timings.transitionProperty == 'all';\n      flags.applyTransitionDuration = hasToStyles && (\n                                        (flags.hasTransitions && !flags.hasTransitionAll)\n                                         || (flags.hasAnimations && !flags.hasTransitions));\n      flags.applyAnimationDuration  = options.duration && flags.hasAnimations;\n      flags.applyTransitionDelay    = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);\n      flags.applyAnimationDelay     = truthyTimingValue(options.delay) && flags.hasAnimations;\n      flags.recalculateTimingStyles = addRemoveClassName.length > 0;\n\n      if (flags.applyTransitionDuration || flags.applyAnimationDuration) {\n        maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;\n\n        if (flags.applyTransitionDuration) {\n          flags.hasTransitions = true;\n          timings.transitionDuration = maxDuration;\n          applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;\n          temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));\n        }\n\n        if (flags.applyAnimationDuration) {\n          flags.hasAnimations = true;\n          timings.animationDuration = maxDuration;\n          temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));\n        }\n      }\n\n      if (maxDuration === 0 && !flags.recalculateTimingStyles) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      if (options.delay != null) {\n        var delayStyle;\n        if (typeof options.delay !== \"boolean\") {\n          delayStyle = parseFloat(options.delay);\n          // number in options.delay means we have to recalculate the delay for the closing timeout\n          maxDelay = Math.max(delayStyle, 0);\n        }\n\n        if (flags.applyTransitionDelay) {\n          temporaryStyles.push(getCssDelayStyle(delayStyle));\n        }\n\n        if (flags.applyAnimationDelay) {\n          temporaryStyles.push(getCssDelayStyle(delayStyle, true));\n        }\n      }\n\n      // we need to recalculate the delay value since we used a pre-emptive negative\n      // delay value and the delay value is required for the final event checking. This\n      // property will ensure that this will happen after the RAF phase has passed.\n      if (options.duration == null && timings.transitionDuration > 0) {\n        flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;\n      }\n\n      maxDelayTime = maxDelay * ONE_SECOND;\n      maxDurationTime = maxDuration * ONE_SECOND;\n      if (!options.skipBlocking) {\n        flags.blockTransition = timings.transitionDuration > 0;\n        flags.blockKeyframeAnimation = timings.animationDuration > 0 &&\n                                       stagger.animationDelay > 0 &&\n                                       stagger.animationDuration === 0;\n      }\n\n      if (options.from) {\n        if (options.cleanupStyles) {\n          registerRestorableStyles(restoreStyles, node, Object.keys(options.from));\n        }\n        applyAnimationFromStyles(element, options);\n      }\n\n      if (flags.blockTransition || flags.blockKeyframeAnimation) {\n        applyBlocking(maxDuration);\n      } else if (!options.skipBlocking) {\n        blockTransitions(node, false);\n      }\n\n      // TODO(matsko): for 1.5 change this code to have an animator object for better debugging\n      return {\n        $$willAnimate: true,\n        end: endFn,\n        start: function() {\n          if (animationClosed) return;\n\n          runnerHost = {\n            end: endFn,\n            cancel: cancelFn,\n            resume: null, //this will be set during the start() phase\n            pause: null\n          };\n\n          runner = new $$AnimateRunner(runnerHost);\n\n          waitUntilQuiet(start);\n\n          // we don't have access to pause/resume the animation\n          // since it hasn't run yet. AnimateRunner will therefore\n          // set noop functions for resume and pause and they will\n          // later be overridden once the animation is triggered\n          return runner;\n        }\n      };\n\n      function endFn() {\n        close();\n      }\n\n      function cancelFn() {\n        close(true);\n      }\n\n      function close(rejected) { // jshint ignore:line\n        // if the promise has been called already then we shouldn't close\n        // the animation again\n        if (animationClosed || (animationCompleted && animationPaused)) return;\n        animationClosed = true;\n        animationPaused = false;\n\n        if (!options.$$skipPreparationClasses) {\n          $$jqLite.removeClass(element, preparationClasses);\n        }\n        $$jqLite.removeClass(element, activeClasses);\n\n        blockKeyframeAnimations(node, false);\n        blockTransitions(node, false);\n\n        forEach(temporaryStyles, function(entry) {\n          // There is only one way to remove inline style properties entirely from elements.\n          // By using `removeProperty` this works, but we need to convert camel-cased CSS\n          // styles down to hyphenated values.\n          node.style[entry[0]] = '';\n        });\n\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n\n        if (Object.keys(restoreStyles).length) {\n          forEach(restoreStyles, function(value, prop) {\n            value ? node.style.setProperty(prop, value)\n                  : node.style.removeProperty(prop);\n          });\n        }\n\n        // the reason why we have this option is to allow a synchronous closing callback\n        // that is fired as SOON as the animation ends (when the CSS is removed) or if\n        // the animation never takes off at all. A good example is a leave animation since\n        // the element must be removed just after the animation is over or else the element\n        // will appear on screen for one animation frame causing an overbearing flicker.\n        if (options.onDone) {\n          options.onDone();\n        }\n\n        if (events && events.length) {\n          // Remove the transitionend / animationend listener(s)\n          element.off(events.join(' '), onAnimationProgress);\n        }\n\n        //Cancel the fallback closing timeout and remove the timer data\n        var animationTimerData = element.data(ANIMATE_TIMER_KEY);\n        if (animationTimerData) {\n          $timeout.cancel(animationTimerData[0].timer);\n          element.removeData(ANIMATE_TIMER_KEY);\n        }\n\n        // if the preparation function fails then the promise is not setup\n        if (runner) {\n          runner.complete(!rejected);\n        }\n      }\n\n      function applyBlocking(duration) {\n        if (flags.blockTransition) {\n          blockTransitions(node, duration);\n        }\n\n        if (flags.blockKeyframeAnimation) {\n          blockKeyframeAnimations(node, !!duration);\n        }\n      }\n\n      function closeAndReturnNoopAnimator() {\n        runner = new $$AnimateRunner({\n          end: endFn,\n          cancel: cancelFn\n        });\n\n        // should flush the cache animation\n        waitUntilQuiet(noop);\n        close();\n\n        return {\n          $$willAnimate: false,\n          start: function() {\n            return runner;\n          },\n          end: endFn\n        };\n      }\n\n      function onAnimationProgress(event) {\n        event.stopPropagation();\n        var ev = event.originalEvent || event;\n\n        // we now always use `Date.now()` due to the recent changes with\n        // event.timeStamp in Firefox, Webkit and Chrome (see #13494 for more info)\n        var timeStamp = ev.$manualTimeStamp || Date.now();\n\n        /* Firefox (or possibly just Gecko) likes to not round values up\n         * when a ms measurement is used for the animation */\n        var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));\n\n        /* $manualTimeStamp is a mocked timeStamp value which is set\n         * within browserTrigger(). This is only here so that tests can\n         * mock animations properly. Real events fallback to event.timeStamp,\n         * or, if they don't, then a timeStamp is automatically created for them.\n         * We're checking to see if the timeStamp surpasses the expected delay,\n         * but we're using elapsedTime instead of the timeStamp on the 2nd\n         * pre-condition since animationPauseds sometimes close off early */\n        if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {\n          // we set this flag to ensure that if the transition is paused then, when resumed,\n          // the animation will automatically close itself since transitions cannot be paused.\n          animationCompleted = true;\n          close();\n        }\n      }\n\n      function start() {\n        if (animationClosed) return;\n        if (!node.parentNode) {\n          close();\n          return;\n        }\n\n        // even though we only pause keyframe animations here the pause flag\n        // will still happen when transitions are used. Only the transition will\n        // not be paused since that is not possible. If the animation ends when\n        // paused then it will not complete until unpaused or cancelled.\n        var playPause = function(playAnimation) {\n          if (!animationCompleted) {\n            animationPaused = !playAnimation;\n            if (timings.animationDuration) {\n              var value = blockKeyframeAnimations(node, animationPaused);\n              animationPaused\n                  ? temporaryStyles.push(value)\n                  : removeFromArray(temporaryStyles, value);\n            }\n          } else if (animationPaused && playAnimation) {\n            animationPaused = false;\n            close();\n          }\n        };\n\n        // checking the stagger duration prevents an accidentally cascade of the CSS delay style\n        // being inherited from the parent. If the transition duration is zero then we can safely\n        // rely that the delay value is an intentional stagger delay style.\n        var maxStagger = itemIndex > 0\n                         && ((timings.transitionDuration && stagger.transitionDuration === 0) ||\n                            (timings.animationDuration && stagger.animationDuration === 0))\n                         && Math.max(stagger.animationDelay, stagger.transitionDelay);\n        if (maxStagger) {\n          $timeout(triggerAnimationStart,\n                   Math.floor(maxStagger * itemIndex * ONE_SECOND),\n                   false);\n        } else {\n          triggerAnimationStart();\n        }\n\n        // this will decorate the existing promise runner with pause/resume methods\n        runnerHost.resume = function() {\n          playPause(true);\n        };\n\n        runnerHost.pause = function() {\n          playPause(false);\n        };\n\n        function triggerAnimationStart() {\n          // just incase a stagger animation kicks in when the animation\n          // itself was cancelled entirely\n          if (animationClosed) return;\n\n          applyBlocking(false);\n\n          forEach(temporaryStyles, function(entry) {\n            var key = entry[0];\n            var value = entry[1];\n            node.style[key] = value;\n          });\n\n          applyAnimationClasses(element, options);\n          $$jqLite.addClass(element, activeClasses);\n\n          if (flags.recalculateTimingStyles) {\n            fullClassName = node.className + ' ' + preparationClasses;\n            cacheKey = gcsHashFn(node, fullClassName);\n\n            timings = computeTimings(node, fullClassName, cacheKey);\n            relativeDelay = timings.maxDelay;\n            maxDelay = Math.max(relativeDelay, 0);\n            maxDuration = timings.maxDuration;\n\n            if (maxDuration === 0) {\n              close();\n              return;\n            }\n\n            flags.hasTransitions = timings.transitionDuration > 0;\n            flags.hasAnimations = timings.animationDuration > 0;\n          }\n\n          if (flags.applyAnimationDelay) {\n            relativeDelay = typeof options.delay !== \"boolean\" && truthyTimingValue(options.delay)\n                  ? parseFloat(options.delay)\n                  : relativeDelay;\n\n            maxDelay = Math.max(relativeDelay, 0);\n            timings.animationDelay = relativeDelay;\n            delayStyle = getCssDelayStyle(relativeDelay, true);\n            temporaryStyles.push(delayStyle);\n            node.style[delayStyle[0]] = delayStyle[1];\n          }\n\n          maxDelayTime = maxDelay * ONE_SECOND;\n          maxDurationTime = maxDuration * ONE_SECOND;\n\n          if (options.easing) {\n            var easeProp, easeVal = options.easing;\n            if (flags.hasTransitions) {\n              easeProp = TRANSITION_PROP + TIMING_KEY;\n              temporaryStyles.push([easeProp, easeVal]);\n              node.style[easeProp] = easeVal;\n            }\n            if (flags.hasAnimations) {\n              easeProp = ANIMATION_PROP + TIMING_KEY;\n              temporaryStyles.push([easeProp, easeVal]);\n              node.style[easeProp] = easeVal;\n            }\n          }\n\n          if (timings.transitionDuration) {\n            events.push(TRANSITIONEND_EVENT);\n          }\n\n          if (timings.animationDuration) {\n            events.push(ANIMATIONEND_EVENT);\n          }\n\n          startTime = Date.now();\n          var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;\n          var endTime = startTime + timerTime;\n\n          var animationsData = element.data(ANIMATE_TIMER_KEY) || [];\n          var setupFallbackTimer = true;\n          if (animationsData.length) {\n            var currentTimerData = animationsData[0];\n            setupFallbackTimer = endTime > currentTimerData.expectedEndTime;\n            if (setupFallbackTimer) {\n              $timeout.cancel(currentTimerData.timer);\n            } else {\n              animationsData.push(close);\n            }\n          }\n\n          if (setupFallbackTimer) {\n            var timer = $timeout(onAnimationExpired, timerTime, false);\n            animationsData[0] = {\n              timer: timer,\n              expectedEndTime: endTime\n            };\n            animationsData.push(close);\n            element.data(ANIMATE_TIMER_KEY, animationsData);\n          }\n\n          if (events.length) {\n            element.on(events.join(' '), onAnimationProgress);\n          }\n\n          if (options.to) {\n            if (options.cleanupStyles) {\n              registerRestorableStyles(restoreStyles, node, Object.keys(options.to));\n            }\n            applyAnimationToStyles(element, options);\n          }\n        }\n\n        function onAnimationExpired() {\n          var animationsData = element.data(ANIMATE_TIMER_KEY);\n\n          // this will be false in the event that the element was\n          // removed from the DOM (via a leave animation or something\n          // similar)\n          if (animationsData) {\n            for (var i = 1; i < animationsData.length; i++) {\n              animationsData[i]();\n            }\n            element.removeData(ANIMATE_TIMER_KEY);\n          }\n        }\n      }\n    };\n  }];\n}];\n\nvar $$AnimateCssDriverProvider = ['$$animationProvider', function($$animationProvider) {\n  $$animationProvider.drivers.push('$$animateCssDriver');\n\n  var NG_ANIMATE_SHIM_CLASS_NAME = 'ng-animate-shim';\n  var NG_ANIMATE_ANCHOR_CLASS_NAME = 'ng-anchor';\n\n  var NG_OUT_ANCHOR_CLASS_NAME = 'ng-anchor-out';\n  var NG_IN_ANCHOR_CLASS_NAME = 'ng-anchor-in';\n\n  function isDocumentFragment(node) {\n    return node.parentNode && node.parentNode.nodeType === 11;\n  }\n\n  this.$get = ['$animateCss', '$rootScope', '$$AnimateRunner', '$rootElement', '$sniffer', '$$jqLite', '$document',\n       function($animateCss,   $rootScope,   $$AnimateRunner,   $rootElement,   $sniffer,   $$jqLite,   $document) {\n\n    // only browsers that support these properties can render animations\n    if (!$sniffer.animations && !$sniffer.transitions) return noop;\n\n    var bodyNode = $document[0].body;\n    var rootNode = getDomNode($rootElement);\n\n    var rootBodyElement = jqLite(\n      // this is to avoid using something that exists outside of the body\n      // we also special case the doc fragment case because our unit test code\n      // appends the $rootElement to the body after the app has been bootstrapped\n      isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode\n    );\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    return function initDriverFn(animationDetails) {\n      return animationDetails.from && animationDetails.to\n          ? prepareFromToAnchorAnimation(animationDetails.from,\n                                         animationDetails.to,\n                                         animationDetails.classes,\n                                         animationDetails.anchors)\n          : prepareRegularAnimation(animationDetails);\n    };\n\n    function filterCssClasses(classes) {\n      //remove all the `ng-` stuff\n      return classes.replace(/\\bng-\\S+\\b/g, '');\n    }\n\n    function getUniqueValues(a, b) {\n      if (isString(a)) a = a.split(' ');\n      if (isString(b)) b = b.split(' ');\n      return a.filter(function(val) {\n        return b.indexOf(val) === -1;\n      }).join(' ');\n    }\n\n    function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {\n      var clone = jqLite(getDomNode(outAnchor).cloneNode(true));\n      var startingClasses = filterCssClasses(getClassVal(clone));\n\n      outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);\n      inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);\n\n      clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);\n\n      rootBodyElement.append(clone);\n\n      var animatorIn, animatorOut = prepareOutAnimation();\n\n      // the user may not end up using the `out` animation and\n      // only making use of the `in` animation or vice-versa.\n      // In either case we should allow this and not assume the\n      // animation is over unless both animations are not used.\n      if (!animatorOut) {\n        animatorIn = prepareInAnimation();\n        if (!animatorIn) {\n          return end();\n        }\n      }\n\n      var startingAnimator = animatorOut || animatorIn;\n\n      return {\n        start: function() {\n          var runner;\n\n          var currentAnimation = startingAnimator.start();\n          currentAnimation.done(function() {\n            currentAnimation = null;\n            if (!animatorIn) {\n              animatorIn = prepareInAnimation();\n              if (animatorIn) {\n                currentAnimation = animatorIn.start();\n                currentAnimation.done(function() {\n                  currentAnimation = null;\n                  end();\n                  runner.complete();\n                });\n                return currentAnimation;\n              }\n            }\n            // in the event that there is no `in` animation\n            end();\n            runner.complete();\n          });\n\n          runner = new $$AnimateRunner({\n            end: endFn,\n            cancel: endFn\n          });\n\n          return runner;\n\n          function endFn() {\n            if (currentAnimation) {\n              currentAnimation.end();\n            }\n          }\n        }\n      };\n\n      function calculateAnchorStyles(anchor) {\n        var styles = {};\n\n        var coords = getDomNode(anchor).getBoundingClientRect();\n\n        // we iterate directly since safari messes up and doesn't return\n        // all the keys for the coords object when iterated\n        forEach(['width','height','top','left'], function(key) {\n          var value = coords[key];\n          switch (key) {\n            case 'top':\n              value += bodyNode.scrollTop;\n              break;\n            case 'left':\n              value += bodyNode.scrollLeft;\n              break;\n          }\n          styles[key] = Math.floor(value) + 'px';\n        });\n        return styles;\n      }\n\n      function prepareOutAnimation() {\n        var animator = $animateCss(clone, {\n          addClass: NG_OUT_ANCHOR_CLASS_NAME,\n          delay: true,\n          from: calculateAnchorStyles(outAnchor)\n        });\n\n        // read the comment within `prepareRegularAnimation` to understand\n        // why this check is necessary\n        return animator.$$willAnimate ? animator : null;\n      }\n\n      function getClassVal(element) {\n        return element.attr('class') || '';\n      }\n\n      function prepareInAnimation() {\n        var endingClasses = filterCssClasses(getClassVal(inAnchor));\n        var toAdd = getUniqueValues(endingClasses, startingClasses);\n        var toRemove = getUniqueValues(startingClasses, endingClasses);\n\n        var animator = $animateCss(clone, {\n          to: calculateAnchorStyles(inAnchor),\n          addClass: NG_IN_ANCHOR_CLASS_NAME + ' ' + toAdd,\n          removeClass: NG_OUT_ANCHOR_CLASS_NAME + ' ' + toRemove,\n          delay: true\n        });\n\n        // read the comment within `prepareRegularAnimation` to understand\n        // why this check is necessary\n        return animator.$$willAnimate ? animator : null;\n      }\n\n      function end() {\n        clone.remove();\n        outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);\n        inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);\n      }\n    }\n\n    function prepareFromToAnchorAnimation(from, to, classes, anchors) {\n      var fromAnimation = prepareRegularAnimation(from, noop);\n      var toAnimation = prepareRegularAnimation(to, noop);\n\n      var anchorAnimations = [];\n      forEach(anchors, function(anchor) {\n        var outElement = anchor['out'];\n        var inElement = anchor['in'];\n        var animator = prepareAnchoredAnimation(classes, outElement, inElement);\n        if (animator) {\n          anchorAnimations.push(animator);\n        }\n      });\n\n      // no point in doing anything when there are no elements to animate\n      if (!fromAnimation && !toAnimation && anchorAnimations.length === 0) return;\n\n      return {\n        start: function() {\n          var animationRunners = [];\n\n          if (fromAnimation) {\n            animationRunners.push(fromAnimation.start());\n          }\n\n          if (toAnimation) {\n            animationRunners.push(toAnimation.start());\n          }\n\n          forEach(anchorAnimations, function(animation) {\n            animationRunners.push(animation.start());\n          });\n\n          var runner = new $$AnimateRunner({\n            end: endFn,\n            cancel: endFn // CSS-driven animations cannot be cancelled, only ended\n          });\n\n          $$AnimateRunner.all(animationRunners, function(status) {\n            runner.complete(status);\n          });\n\n          return runner;\n\n          function endFn() {\n            forEach(animationRunners, function(runner) {\n              runner.end();\n            });\n          }\n        }\n      };\n    }\n\n    function prepareRegularAnimation(animationDetails) {\n      var element = animationDetails.element;\n      var options = animationDetails.options || {};\n\n      if (animationDetails.structural) {\n        options.event = animationDetails.event;\n        options.structural = true;\n        options.applyClassesEarly = true;\n\n        // we special case the leave animation since we want to ensure that\n        // the element is removed as soon as the animation is over. Otherwise\n        // a flicker might appear or the element may not be removed at all\n        if (animationDetails.event === 'leave') {\n          options.onDone = options.domOperation;\n        }\n      }\n\n      // We assign the preparationClasses as the actual animation event since\n      // the internals of $animateCss will just suffix the event token values\n      // with `-active` to trigger the animation.\n      if (options.preparationClasses) {\n        options.event = concatWithSpace(options.event, options.preparationClasses);\n      }\n\n      var animator = $animateCss(element, options);\n\n      // the driver lookup code inside of $$animation attempts to spawn a\n      // driver one by one until a driver returns a.$$willAnimate animator object.\n      // $animateCss will always return an object, however, it will pass in\n      // a flag as a hint as to whether an animation was detected or not\n      return animator.$$willAnimate ? animator : null;\n    }\n  }];\n}];\n\n// TODO(matsko): use caching here to speed things up for detection\n// TODO(matsko): add documentation\n//  by the time...\n\nvar $$AnimateJsProvider = ['$animateProvider', function($animateProvider) {\n  this.$get = ['$injector', '$$AnimateRunner', '$$jqLite',\n       function($injector,   $$AnimateRunner,   $$jqLite) {\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n         // $animateJs(element, 'enter');\n    return function(element, event, classes, options) {\n      var animationClosed = false;\n\n      // the `classes` argument is optional and if it is not used\n      // then the classes will be resolved from the element's className\n      // property as well as options.addClass/options.removeClass.\n      if (arguments.length === 3 && isObject(classes)) {\n        options = classes;\n        classes = null;\n      }\n\n      options = prepareAnimationOptions(options);\n      if (!classes) {\n        classes = element.attr('class') || '';\n        if (options.addClass) {\n          classes += ' ' + options.addClass;\n        }\n        if (options.removeClass) {\n          classes += ' ' + options.removeClass;\n        }\n      }\n\n      var classesToAdd = options.addClass;\n      var classesToRemove = options.removeClass;\n\n      // the lookupAnimations function returns a series of animation objects that are\n      // matched up with one or more of the CSS classes. These animation objects are\n      // defined via the module.animation factory function. If nothing is detected then\n      // we don't return anything which then makes $animation query the next driver.\n      var animations = lookupAnimations(classes);\n      var before, after;\n      if (animations.length) {\n        var afterFn, beforeFn;\n        if (event == 'leave') {\n          beforeFn = 'leave';\n          afterFn = 'afterLeave'; // TODO(matsko): get rid of this\n        } else {\n          beforeFn = 'before' + event.charAt(0).toUpperCase() + event.substr(1);\n          afterFn = event;\n        }\n\n        if (event !== 'enter' && event !== 'move') {\n          before = packageAnimations(element, event, options, animations, beforeFn);\n        }\n        after  = packageAnimations(element, event, options, animations, afterFn);\n      }\n\n      // no matching animations\n      if (!before && !after) return;\n\n      function applyOptions() {\n        options.domOperation();\n        applyAnimationClasses(element, options);\n      }\n\n      function close() {\n        animationClosed = true;\n        applyOptions();\n        applyAnimationStyles(element, options);\n      }\n\n      var runner;\n\n      return {\n        $$willAnimate: true,\n        end: function() {\n          if (runner) {\n            runner.end();\n          } else {\n            close();\n            runner = new $$AnimateRunner();\n            runner.complete(true);\n          }\n          return runner;\n        },\n        start: function() {\n          if (runner) {\n            return runner;\n          }\n\n          runner = new $$AnimateRunner();\n          var closeActiveAnimations;\n          var chain = [];\n\n          if (before) {\n            chain.push(function(fn) {\n              closeActiveAnimations = before(fn);\n            });\n          }\n\n          if (chain.length) {\n            chain.push(function(fn) {\n              applyOptions();\n              fn(true);\n            });\n          } else {\n            applyOptions();\n          }\n\n          if (after) {\n            chain.push(function(fn) {\n              closeActiveAnimations = after(fn);\n            });\n          }\n\n          runner.setHost({\n            end: function() {\n              endAnimations();\n            },\n            cancel: function() {\n              endAnimations(true);\n            }\n          });\n\n          $$AnimateRunner.chain(chain, onComplete);\n          return runner;\n\n          function onComplete(success) {\n            close(success);\n            runner.complete(success);\n          }\n\n          function endAnimations(cancelled) {\n            if (!animationClosed) {\n              (closeActiveAnimations || noop)(cancelled);\n              onComplete(cancelled);\n            }\n          }\n        }\n      };\n\n      function executeAnimationFn(fn, element, event, options, onDone) {\n        var args;\n        switch (event) {\n          case 'animate':\n            args = [element, options.from, options.to, onDone];\n            break;\n\n          case 'setClass':\n            args = [element, classesToAdd, classesToRemove, onDone];\n            break;\n\n          case 'addClass':\n            args = [element, classesToAdd, onDone];\n            break;\n\n          case 'removeClass':\n            args = [element, classesToRemove, onDone];\n            break;\n\n          default:\n            args = [element, onDone];\n            break;\n        }\n\n        args.push(options);\n\n        var value = fn.apply(fn, args);\n        if (value) {\n          if (isFunction(value.start)) {\n            value = value.start();\n          }\n\n          if (value instanceof $$AnimateRunner) {\n            value.done(onDone);\n          } else if (isFunction(value)) {\n            // optional onEnd / onCancel callback\n            return value;\n          }\n        }\n\n        return noop;\n      }\n\n      function groupEventedAnimations(element, event, options, animations, fnName) {\n        var operations = [];\n        forEach(animations, function(ani) {\n          var animation = ani[fnName];\n          if (!animation) return;\n\n          // note that all of these animations will run in parallel\n          operations.push(function() {\n            var runner;\n            var endProgressCb;\n\n            var resolved = false;\n            var onAnimationComplete = function(rejected) {\n              if (!resolved) {\n                resolved = true;\n                (endProgressCb || noop)(rejected);\n                runner.complete(!rejected);\n              }\n            };\n\n            runner = new $$AnimateRunner({\n              end: function() {\n                onAnimationComplete();\n              },\n              cancel: function() {\n                onAnimationComplete(true);\n              }\n            });\n\n            endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {\n              var cancelled = result === false;\n              onAnimationComplete(cancelled);\n            });\n\n            return runner;\n          });\n        });\n\n        return operations;\n      }\n\n      function packageAnimations(element, event, options, animations, fnName) {\n        var operations = groupEventedAnimations(element, event, options, animations, fnName);\n        if (operations.length === 0) {\n          var a,b;\n          if (fnName === 'beforeSetClass') {\n            a = groupEventedAnimations(element, 'removeClass', options, animations, 'beforeRemoveClass');\n            b = groupEventedAnimations(element, 'addClass', options, animations, 'beforeAddClass');\n          } else if (fnName === 'setClass') {\n            a = groupEventedAnimations(element, 'removeClass', options, animations, 'removeClass');\n            b = groupEventedAnimations(element, 'addClass', options, animations, 'addClass');\n          }\n\n          if (a) {\n            operations = operations.concat(a);\n          }\n          if (b) {\n            operations = operations.concat(b);\n          }\n        }\n\n        if (operations.length === 0) return;\n\n        // TODO(matsko): add documentation\n        return function startAnimation(callback) {\n          var runners = [];\n          if (operations.length) {\n            forEach(operations, function(animateFn) {\n              runners.push(animateFn());\n            });\n          }\n\n          runners.length ? $$AnimateRunner.all(runners, callback) : callback();\n\n          return function endFn(reject) {\n            forEach(runners, function(runner) {\n              reject ? runner.cancel() : runner.end();\n            });\n          };\n        };\n      }\n    };\n\n    function lookupAnimations(classes) {\n      classes = isArray(classes) ? classes : classes.split(' ');\n      var matches = [], flagMap = {};\n      for (var i=0; i < classes.length; i++) {\n        var klass = classes[i],\n            animationFactory = $animateProvider.$$registeredAnimations[klass];\n        if (animationFactory && !flagMap[klass]) {\n          matches.push($injector.get(animationFactory));\n          flagMap[klass] = true;\n        }\n      }\n      return matches;\n    }\n  }];\n}];\n\nvar $$AnimateJsDriverProvider = ['$$animationProvider', function($$animationProvider) {\n  $$animationProvider.drivers.push('$$animateJsDriver');\n  this.$get = ['$$animateJs', '$$AnimateRunner', function($$animateJs, $$AnimateRunner) {\n    return function initDriverFn(animationDetails) {\n      if (animationDetails.from && animationDetails.to) {\n        var fromAnimation = prepareAnimation(animationDetails.from);\n        var toAnimation = prepareAnimation(animationDetails.to);\n        if (!fromAnimation && !toAnimation) return;\n\n        return {\n          start: function() {\n            var animationRunners = [];\n\n            if (fromAnimation) {\n              animationRunners.push(fromAnimation.start());\n            }\n\n            if (toAnimation) {\n              animationRunners.push(toAnimation.start());\n            }\n\n            $$AnimateRunner.all(animationRunners, done);\n\n            var runner = new $$AnimateRunner({\n              end: endFnFactory(),\n              cancel: endFnFactory()\n            });\n\n            return runner;\n\n            function endFnFactory() {\n              return function() {\n                forEach(animationRunners, function(runner) {\n                  // at this point we cannot cancel animations for groups just yet. 1.5+\n                  runner.end();\n                });\n              };\n            }\n\n            function done(status) {\n              runner.complete(status);\n            }\n          }\n        };\n      } else {\n        return prepareAnimation(animationDetails);\n      }\n    };\n\n    function prepareAnimation(animationDetails) {\n      // TODO(matsko): make sure to check for grouped animations and delegate down to normal animations\n      var element = animationDetails.element;\n      var event = animationDetails.event;\n      var options = animationDetails.options;\n      var classes = animationDetails.classes;\n      return $$animateJs(element, event, classes, options);\n    }\n  }];\n}];\n\nvar NG_ANIMATE_ATTR_NAME = 'data-ng-animate';\nvar NG_ANIMATE_PIN_DATA = '$ngAnimatePin';\nvar $$AnimateQueueProvider = ['$animateProvider', function($animateProvider) {\n  var PRE_DIGEST_STATE = 1;\n  var RUNNING_STATE = 2;\n  var ONE_SPACE = ' ';\n\n  var rules = this.rules = {\n    skip: [],\n    cancel: [],\n    join: []\n  };\n\n  function makeTruthyCssClassMap(classString) {\n    if (!classString) {\n      return null;\n    }\n\n    var keys = classString.split(ONE_SPACE);\n    var map = Object.create(null);\n\n    forEach(keys, function(key) {\n      map[key] = true;\n    });\n    return map;\n  }\n\n  function hasMatchingClasses(newClassString, currentClassString) {\n    if (newClassString && currentClassString) {\n      var currentClassMap = makeTruthyCssClassMap(currentClassString);\n      return newClassString.split(ONE_SPACE).some(function(className) {\n        return currentClassMap[className];\n      });\n    }\n  }\n\n  function isAllowed(ruleType, element, currentAnimation, previousAnimation) {\n    return rules[ruleType].some(function(fn) {\n      return fn(element, currentAnimation, previousAnimation);\n    });\n  }\n\n  function hasAnimationClasses(animation, and) {\n    var a = (animation.addClass || '').length > 0;\n    var b = (animation.removeClass || '').length > 0;\n    return and ? a && b : a || b;\n  }\n\n  rules.join.push(function(element, newAnimation, currentAnimation) {\n    // if the new animation is class-based then we can just tack that on\n    return !newAnimation.structural && hasAnimationClasses(newAnimation);\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // there is no need to animate anything if no classes are being added and\n    // there is no structural animation that will be triggered\n    return !newAnimation.structural && !hasAnimationClasses(newAnimation);\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // why should we trigger a new structural animation if the element will\n    // be removed from the DOM anyway?\n    return currentAnimation.event == 'leave' && newAnimation.structural;\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // if there is an ongoing current animation then don't even bother running the class-based animation\n    return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    // there can never be two structural animations running at the same time\n    return currentAnimation.structural && newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    // if the previous animation is already running, but the new animation will\n    // be triggered, but the new animation is structural\n    return currentAnimation.state === RUNNING_STATE && newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    // cancel the animation if classes added / removed in both animation cancel each other out,\n    // but only if the current animation isn't structural\n\n    if (currentAnimation.structural) return false;\n\n    var nA = newAnimation.addClass;\n    var nR = newAnimation.removeClass;\n    var cA = currentAnimation.addClass;\n    var cR = currentAnimation.removeClass;\n\n    // early detection to save the global CPU shortage :)\n    if ((isUndefined(nA) && isUndefined(nR)) || (isUndefined(cA) && isUndefined(cR))) {\n      return false;\n    }\n\n    return hasMatchingClasses(nA, cR) || hasMatchingClasses(nR, cA);\n  });\n\n  this.$get = ['$$rAF', '$rootScope', '$rootElement', '$document', '$$HashMap',\n               '$$animation', '$$AnimateRunner', '$templateRequest', '$$jqLite', '$$forceReflow',\n       function($$rAF,   $rootScope,   $rootElement,   $document,   $$HashMap,\n                $$animation,   $$AnimateRunner,   $templateRequest,   $$jqLite,   $$forceReflow) {\n\n    var activeAnimationsLookup = new $$HashMap();\n    var disabledElementsLookup = new $$HashMap();\n    var animationsEnabled = null;\n\n    function postDigestTaskFactory() {\n      var postDigestCalled = false;\n      return function(fn) {\n        // we only issue a call to postDigest before\n        // it has first passed. This prevents any callbacks\n        // from not firing once the animation has completed\n        // since it will be out of the digest cycle.\n        if (postDigestCalled) {\n          fn();\n        } else {\n          $rootScope.$$postDigest(function() {\n            postDigestCalled = true;\n            fn();\n          });\n        }\n      };\n    }\n\n    // Wait until all directive and route-related templates are downloaded and\n    // compiled. The $templateRequest.totalPendingRequests variable keeps track of\n    // all of the remote templates being currently downloaded. If there are no\n    // templates currently downloading then the watcher will still fire anyway.\n    var deregisterWatch = $rootScope.$watch(\n      function() { return $templateRequest.totalPendingRequests === 0; },\n      function(isEmpty) {\n        if (!isEmpty) return;\n        deregisterWatch();\n\n        // Now that all templates have been downloaded, $animate will wait until\n        // the post digest queue is empty before enabling animations. By having two\n        // calls to $postDigest calls we can ensure that the flag is enabled at the\n        // very end of the post digest queue. Since all of the animations in $animate\n        // use $postDigest, it's important that the code below executes at the end.\n        // This basically means that the page is fully downloaded and compiled before\n        // any animations are triggered.\n        $rootScope.$$postDigest(function() {\n          $rootScope.$$postDigest(function() {\n            // we check for null directly in the event that the application already called\n            // .enabled() with whatever arguments that it provided it with\n            if (animationsEnabled === null) {\n              animationsEnabled = true;\n            }\n          });\n        });\n      }\n    );\n\n    var callbackRegistry = {};\n\n    // remember that the classNameFilter is set during the provider/config\n    // stage therefore we can optimize here and setup a helper function\n    var classNameFilter = $animateProvider.classNameFilter();\n    var isAnimatableClassName = !classNameFilter\n              ? function() { return true; }\n              : function(className) {\n                return classNameFilter.test(className);\n              };\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    function normalizeAnimationDetails(element, animation) {\n      return mergeAnimationDetails(element, animation, {});\n    }\n\n    // IE9-11 has no method \"contains\" in SVG element and in Node.prototype. Bug #10259.\n    var contains = window.Node.prototype.contains || function(arg) {\n      // jshint bitwise: false\n      return this === arg || !!(this.compareDocumentPosition(arg) & 16);\n      // jshint bitwise: true\n    };\n\n    function findCallbacks(parent, element, event) {\n      var targetNode = getDomNode(element);\n      var targetParentNode = getDomNode(parent);\n\n      var matches = [];\n      var entries = callbackRegistry[event];\n      if (entries) {\n        forEach(entries, function(entry) {\n          if (contains.call(entry.node, targetNode)) {\n            matches.push(entry.callback);\n          } else if (event === 'leave' && contains.call(entry.node, targetParentNode)) {\n            matches.push(entry.callback);\n          }\n        });\n      }\n\n      return matches;\n    }\n\n    function filterFromRegistry(list, matchContainer, matchCallback) {\n      var containerNode = extractElementNode(matchContainer);\n      return list.filter(function(entry) {\n        var isMatch = entry.node === containerNode &&\n                        (!matchCallback || entry.callback === matchCallback);\n        return !isMatch;\n      });\n    }\n\n    function cleanupEventListeners(phase, element) {\n      if (phase === 'close' && !element[0].parentNode) {\n        // If the element is not attached to a parentNode, it has been removed by\n        // the domOperation, and we can safely remove the event callbacks\n        $animate.off(element);\n      }\n    }\n\n    var $animate = {\n      on: function(event, container, callback) {\n        var node = extractElementNode(container);\n        callbackRegistry[event] = callbackRegistry[event] || [];\n        callbackRegistry[event].push({\n          node: node,\n          callback: callback\n        });\n\n        // Remove the callback when the element is removed from the DOM\n        jqLite(container).on('$destroy', function() {\n          var animationDetails = activeAnimationsLookup.get(node);\n\n          if (!animationDetails) {\n            // If there's an animation ongoing, the callback calling code will remove\n            // the event listeners. If we'd remove here, the callbacks would be removed\n            // before the animation ends\n            $animate.off(event, container, callback);\n          }\n        });\n      },\n\n      off: function(event, container, callback) {\n        if (arguments.length === 1 && !angular.isString(arguments[0])) {\n          container = arguments[0];\n          for (var eventType in callbackRegistry) {\n            callbackRegistry[eventType] = filterFromRegistry(callbackRegistry[eventType], container);\n          }\n\n          return;\n        }\n\n        var entries = callbackRegistry[event];\n        if (!entries) return;\n\n        callbackRegistry[event] = arguments.length === 1\n            ? null\n            : filterFromRegistry(entries, container, callback);\n      },\n\n      pin: function(element, parentElement) {\n        assertArg(isElement(element), 'element', 'not an element');\n        assertArg(isElement(parentElement), 'parentElement', 'not an element');\n        element.data(NG_ANIMATE_PIN_DATA, parentElement);\n      },\n\n      push: function(element, event, options, domOperation) {\n        options = options || {};\n        options.domOperation = domOperation;\n        return queueAnimation(element, event, options);\n      },\n\n      // this method has four signatures:\n      //  () - global getter\n      //  (bool) - global setter\n      //  (element) - element getter\n      //  (element, bool) - element setter<F37>\n      enabled: function(element, bool) {\n        var argCount = arguments.length;\n\n        if (argCount === 0) {\n          // () - Global getter\n          bool = !!animationsEnabled;\n        } else {\n          var hasElement = isElement(element);\n\n          if (!hasElement) {\n            // (bool) - Global setter\n            bool = animationsEnabled = !!element;\n          } else {\n            var node = getDomNode(element);\n            var recordExists = disabledElementsLookup.get(node);\n\n            if (argCount === 1) {\n              // (element) - Element getter\n              bool = !recordExists;\n            } else {\n              // (element, bool) - Element setter\n              disabledElementsLookup.put(node, !bool);\n            }\n          }\n        }\n\n        return bool;\n      }\n    };\n\n    return $animate;\n\n    function queueAnimation(element, event, initialOptions) {\n      // we always make a copy of the options since\n      // there should never be any side effects on\n      // the input data when running `$animateCss`.\n      var options = copy(initialOptions);\n\n      var node, parent;\n      element = stripCommentsFromElement(element);\n      if (element) {\n        node = getDomNode(element);\n        parent = element.parent();\n      }\n\n      options = prepareAnimationOptions(options);\n\n      // we create a fake runner with a working promise.\n      // These methods will become available after the digest has passed\n      var runner = new $$AnimateRunner();\n\n      // this is used to trigger callbacks in postDigest mode\n      var runInNextPostDigestOrNow = postDigestTaskFactory();\n\n      if (isArray(options.addClass)) {\n        options.addClass = options.addClass.join(' ');\n      }\n\n      if (options.addClass && !isString(options.addClass)) {\n        options.addClass = null;\n      }\n\n      if (isArray(options.removeClass)) {\n        options.removeClass = options.removeClass.join(' ');\n      }\n\n      if (options.removeClass && !isString(options.removeClass)) {\n        options.removeClass = null;\n      }\n\n      if (options.from && !isObject(options.from)) {\n        options.from = null;\n      }\n\n      if (options.to && !isObject(options.to)) {\n        options.to = null;\n      }\n\n      // there are situations where a directive issues an animation for\n      // a jqLite wrapper that contains only comment nodes... If this\n      // happens then there is no way we can perform an animation\n      if (!node) {\n        close();\n        return runner;\n      }\n\n      var className = [node.className, options.addClass, options.removeClass].join(' ');\n      if (!isAnimatableClassName(className)) {\n        close();\n        return runner;\n      }\n\n      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;\n\n      var documentHidden = $document[0].hidden;\n\n      // this is a hard disable of all animations for the application or on\n      // the element itself, therefore  there is no need to continue further\n      // past this point if not enabled\n      // Animations are also disabled if the document is currently hidden (page is not visible\n      // to the user), because browsers slow down or do not flush calls to requestAnimationFrame\n      var skipAnimations = !animationsEnabled || documentHidden || disabledElementsLookup.get(node);\n      var existingAnimation = (!skipAnimations && activeAnimationsLookup.get(node)) || {};\n      var hasExistingAnimation = !!existingAnimation.state;\n\n      // there is no point in traversing the same collection of parent ancestors if a followup\n      // animation will be run on the same element that already did all that checking work\n      if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state != PRE_DIGEST_STATE)) {\n        skipAnimations = !areAnimationsAllowed(element, parent, event);\n      }\n\n      if (skipAnimations) {\n        // Callbacks should fire even if the document is hidden (regression fix for issue #14120)\n        if (documentHidden) notifyProgress(runner, event, 'start');\n        close();\n        if (documentHidden) notifyProgress(runner, event, 'close');\n        return runner;\n      }\n\n      if (isStructural) {\n        closeChildAnimations(element);\n      }\n\n      var newAnimation = {\n        structural: isStructural,\n        element: element,\n        event: event,\n        addClass: options.addClass,\n        removeClass: options.removeClass,\n        close: close,\n        options: options,\n        runner: runner\n      };\n\n      if (hasExistingAnimation) {\n        var skipAnimationFlag = isAllowed('skip', element, newAnimation, existingAnimation);\n        if (skipAnimationFlag) {\n          if (existingAnimation.state === RUNNING_STATE) {\n            close();\n            return runner;\n          } else {\n            mergeAnimationDetails(element, existingAnimation, newAnimation);\n            return existingAnimation.runner;\n          }\n        }\n        var cancelAnimationFlag = isAllowed('cancel', element, newAnimation, existingAnimation);\n        if (cancelAnimationFlag) {\n          if (existingAnimation.state === RUNNING_STATE) {\n            // this will end the animation right away and it is safe\n            // to do so since the animation is already running and the\n            // runner callback code will run in async\n            existingAnimation.runner.end();\n          } else if (existingAnimation.structural) {\n            // this means that the animation is queued into a digest, but\n            // hasn't started yet. Therefore it is safe to run the close\n            // method which will call the runner methods in async.\n            existingAnimation.close();\n          } else {\n            // this will merge the new animation options into existing animation options\n            mergeAnimationDetails(element, existingAnimation, newAnimation);\n\n            return existingAnimation.runner;\n          }\n        } else {\n          // a joined animation means that this animation will take over the existing one\n          // so an example would involve a leave animation taking over an enter. Then when\n          // the postDigest kicks in the enter will be ignored.\n          var joinAnimationFlag = isAllowed('join', element, newAnimation, existingAnimation);\n          if (joinAnimationFlag) {\n            if (existingAnimation.state === RUNNING_STATE) {\n              normalizeAnimationDetails(element, newAnimation);\n            } else {\n              applyGeneratedPreparationClasses(element, isStructural ? event : null, options);\n\n              event = newAnimation.event = existingAnimation.event;\n              options = mergeAnimationDetails(element, existingAnimation, newAnimation);\n\n              //we return the same runner since only the option values of this animation will\n              //be fed into the `existingAnimation`.\n              return existingAnimation.runner;\n            }\n          }\n        }\n      } else {\n        // normalization in this case means that it removes redundant CSS classes that\n        // already exist (addClass) or do not exist (removeClass) on the element\n        normalizeAnimationDetails(element, newAnimation);\n      }\n\n      // when the options are merged and cleaned up we may end up not having to do\n      // an animation at all, therefore we should check this before issuing a post\n      // digest callback. Structural animations will always run no matter what.\n      var isValidAnimation = newAnimation.structural;\n      if (!isValidAnimation) {\n        // animate (from/to) can be quickly checked first, otherwise we check if any classes are present\n        isValidAnimation = (newAnimation.event === 'animate' && Object.keys(newAnimation.options.to || {}).length > 0)\n                            || hasAnimationClasses(newAnimation);\n      }\n\n      if (!isValidAnimation) {\n        close();\n        clearElementAnimationState(element);\n        return runner;\n      }\n\n      // the counter keeps track of cancelled animations\n      var counter = (existingAnimation.counter || 0) + 1;\n      newAnimation.counter = counter;\n\n      markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation);\n\n      $rootScope.$$postDigest(function() {\n        var animationDetails = activeAnimationsLookup.get(node);\n        var animationCancelled = !animationDetails;\n        animationDetails = animationDetails || {};\n\n        // if addClass/removeClass is called before something like enter then the\n        // registered parent element may not be present. The code below will ensure\n        // that a final value for parent element is obtained\n        var parentElement = element.parent() || [];\n\n        // animate/structural/class-based animations all have requirements. Otherwise there\n        // is no point in performing an animation. The parent node must also be set.\n        var isValidAnimation = parentElement.length > 0\n                                && (animationDetails.event === 'animate'\n                                    || animationDetails.structural\n                                    || hasAnimationClasses(animationDetails));\n\n        // this means that the previous animation was cancelled\n        // even if the follow-up animation is the same event\n        if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {\n          // if another animation did not take over then we need\n          // to make sure that the domOperation and options are\n          // handled accordingly\n          if (animationCancelled) {\n            applyAnimationClasses(element, options);\n            applyAnimationStyles(element, options);\n          }\n\n          // if the event changed from something like enter to leave then we do\n          // it, otherwise if it's the same then the end result will be the same too\n          if (animationCancelled || (isStructural && animationDetails.event !== event)) {\n            options.domOperation();\n            runner.end();\n          }\n\n          // in the event that the element animation was not cancelled or a follow-up animation\n          // isn't allowed to animate from here then we need to clear the state of the element\n          // so that any future animations won't read the expired animation data.\n          if (!isValidAnimation) {\n            clearElementAnimationState(element);\n          }\n\n          return;\n        }\n\n        // this combined multiple class to addClass / removeClass into a setClass event\n        // so long as a structural event did not take over the animation\n        event = !animationDetails.structural && hasAnimationClasses(animationDetails, true)\n            ? 'setClass'\n            : animationDetails.event;\n\n        markElementAnimationState(element, RUNNING_STATE);\n        var realRunner = $$animation(element, event, animationDetails.options);\n\n        // this will update the runner's flow-control events based on\n        // the `realRunner` object.\n        runner.setHost(realRunner);\n        notifyProgress(runner, event, 'start', {});\n\n        realRunner.done(function(status) {\n          close(!status);\n          var animationDetails = activeAnimationsLookup.get(node);\n          if (animationDetails && animationDetails.counter === counter) {\n            clearElementAnimationState(getDomNode(element));\n          }\n          notifyProgress(runner, event, 'close', {});\n        });\n      });\n\n      return runner;\n\n      function notifyProgress(runner, event, phase, data) {\n        runInNextPostDigestOrNow(function() {\n          var callbacks = findCallbacks(parent, element, event);\n          if (callbacks.length) {\n            // do not optimize this call here to RAF because\n            // we don't know how heavy the callback code here will\n            // be and if this code is buffered then this can\n            // lead to a performance regression.\n            $$rAF(function() {\n              forEach(callbacks, function(callback) {\n                callback(element, phase, data);\n              });\n              cleanupEventListeners(phase, element);\n            });\n          } else {\n            cleanupEventListeners(phase, element);\n          }\n        });\n        runner.progress(event, phase, data);\n      }\n\n      function close(reject) { // jshint ignore:line\n        clearGeneratedClasses(element, options);\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n        options.domOperation();\n        runner.complete(!reject);\n      }\n    }\n\n    function closeChildAnimations(element) {\n      var node = getDomNode(element);\n      var children = node.querySelectorAll('[' + NG_ANIMATE_ATTR_NAME + ']');\n      forEach(children, function(child) {\n        var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME));\n        var animationDetails = activeAnimationsLookup.get(child);\n        if (animationDetails) {\n          switch (state) {\n            case RUNNING_STATE:\n              animationDetails.runner.end();\n              /* falls through */\n            case PRE_DIGEST_STATE:\n              activeAnimationsLookup.remove(child);\n              break;\n          }\n        }\n      });\n    }\n\n    function clearElementAnimationState(element) {\n      var node = getDomNode(element);\n      node.removeAttribute(NG_ANIMATE_ATTR_NAME);\n      activeAnimationsLookup.remove(node);\n    }\n\n    function isMatchingElement(nodeOrElmA, nodeOrElmB) {\n      return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);\n    }\n\n    /**\n     * This fn returns false if any of the following is true:\n     * a) animations on any parent element are disabled, and animations on the element aren't explicitly allowed\n     * b) a parent element has an ongoing structural animation, and animateChildren is false\n     * c) the element is not a child of the body\n     * d) the element is not a child of the $rootElement\n     */\n    function areAnimationsAllowed(element, parentElement, event) {\n      var bodyElement = jqLite($document[0].body);\n      var bodyElementDetected = isMatchingElement(element, bodyElement) || element[0].nodeName === 'HTML';\n      var rootElementDetected = isMatchingElement(element, $rootElement);\n      var parentAnimationDetected = false;\n      var animateChildren;\n      var elementDisabled = disabledElementsLookup.get(getDomNode(element));\n\n      var parentHost = jqLite.data(element[0], NG_ANIMATE_PIN_DATA);\n      if (parentHost) {\n        parentElement = parentHost;\n      }\n\n      parentElement = getDomNode(parentElement);\n\n      while (parentElement) {\n        if (!rootElementDetected) {\n          // angular doesn't want to attempt to animate elements outside of the application\n          // therefore we need to ensure that the rootElement is an ancestor of the current element\n          rootElementDetected = isMatchingElement(parentElement, $rootElement);\n        }\n\n        if (parentElement.nodeType !== ELEMENT_NODE) {\n          // no point in inspecting the #document element\n          break;\n        }\n\n        var details = activeAnimationsLookup.get(parentElement) || {};\n        // either an enter, leave or move animation will commence\n        // therefore we can't allow any animations to take place\n        // but if a parent animation is class-based then that's ok\n        if (!parentAnimationDetected) {\n          var parentElementDisabled = disabledElementsLookup.get(parentElement);\n\n          if (parentElementDisabled === true && elementDisabled !== false) {\n            // disable animations if the user hasn't explicitly enabled animations on the\n            // current element\n            elementDisabled = true;\n            // element is disabled via parent element, no need to check anything else\n            break;\n          } else if (parentElementDisabled === false) {\n            elementDisabled = false;\n          }\n          parentAnimationDetected = details.structural;\n        }\n\n        if (isUndefined(animateChildren) || animateChildren === true) {\n          var value = jqLite.data(parentElement, NG_ANIMATE_CHILDREN_DATA);\n          if (isDefined(value)) {\n            animateChildren = value;\n          }\n        }\n\n        // there is no need to continue traversing at this point\n        if (parentAnimationDetected && animateChildren === false) break;\n\n        if (!bodyElementDetected) {\n          // we also need to ensure that the element is or will be a part of the body element\n          // otherwise it is pointless to even issue an animation to be rendered\n          bodyElementDetected = isMatchingElement(parentElement, bodyElement);\n        }\n\n        if (bodyElementDetected && rootElementDetected) {\n          // If both body and root have been found, any other checks are pointless,\n          // as no animation data should live outside the application\n          break;\n        }\n\n        if (!rootElementDetected) {\n          // If no rootElement is detected, check if the parentElement is pinned to another element\n          parentHost = jqLite.data(parentElement, NG_ANIMATE_PIN_DATA);\n          if (parentHost) {\n            // The pin target element becomes the next parent element\n            parentElement = getDomNode(parentHost);\n            continue;\n          }\n        }\n\n        parentElement = parentElement.parentNode;\n      }\n\n      var allowAnimation = (!parentAnimationDetected || animateChildren) && elementDisabled !== true;\n      return allowAnimation && rootElementDetected && bodyElementDetected;\n    }\n\n    function markElementAnimationState(element, state, details) {\n      details = details || {};\n      details.state = state;\n\n      var node = getDomNode(element);\n      node.setAttribute(NG_ANIMATE_ATTR_NAME, state);\n\n      var oldValue = activeAnimationsLookup.get(node);\n      var newValue = oldValue\n          ? extend(oldValue, details)\n          : details;\n      activeAnimationsLookup.put(node, newValue);\n    }\n  }];\n}];\n\nvar $$AnimationProvider = ['$animateProvider', function($animateProvider) {\n  var NG_ANIMATE_REF_ATTR = 'ng-animate-ref';\n\n  var drivers = this.drivers = [];\n\n  var RUNNER_STORAGE_KEY = '$$animationRunner';\n\n  function setRunner(element, runner) {\n    element.data(RUNNER_STORAGE_KEY, runner);\n  }\n\n  function removeRunner(element) {\n    element.removeData(RUNNER_STORAGE_KEY);\n  }\n\n  function getRunner(element) {\n    return element.data(RUNNER_STORAGE_KEY);\n  }\n\n  this.$get = ['$$jqLite', '$rootScope', '$injector', '$$AnimateRunner', '$$HashMap', '$$rAFScheduler',\n       function($$jqLite,   $rootScope,   $injector,   $$AnimateRunner,   $$HashMap,   $$rAFScheduler) {\n\n    var animationQueue = [];\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    function sortAnimations(animations) {\n      var tree = { children: [] };\n      var i, lookup = new $$HashMap();\n\n      // this is done first beforehand so that the hashmap\n      // is filled with a list of the elements that will be animated\n      for (i = 0; i < animations.length; i++) {\n        var animation = animations[i];\n        lookup.put(animation.domNode, animations[i] = {\n          domNode: animation.domNode,\n          fn: animation.fn,\n          children: []\n        });\n      }\n\n      for (i = 0; i < animations.length; i++) {\n        processNode(animations[i]);\n      }\n\n      return flatten(tree);\n\n      function processNode(entry) {\n        if (entry.processed) return entry;\n        entry.processed = true;\n\n        var elementNode = entry.domNode;\n        var parentNode = elementNode.parentNode;\n        lookup.put(elementNode, entry);\n\n        var parentEntry;\n        while (parentNode) {\n          parentEntry = lookup.get(parentNode);\n          if (parentEntry) {\n            if (!parentEntry.processed) {\n              parentEntry = processNode(parentEntry);\n            }\n            break;\n          }\n          parentNode = parentNode.parentNode;\n        }\n\n        (parentEntry || tree).children.push(entry);\n        return entry;\n      }\n\n      function flatten(tree) {\n        var result = [];\n        var queue = [];\n        var i;\n\n        for (i = 0; i < tree.children.length; i++) {\n          queue.push(tree.children[i]);\n        }\n\n        var remainingLevelEntries = queue.length;\n        var nextLevelEntries = 0;\n        var row = [];\n\n        for (i = 0; i < queue.length; i++) {\n          var entry = queue[i];\n          if (remainingLevelEntries <= 0) {\n            remainingLevelEntries = nextLevelEntries;\n            nextLevelEntries = 0;\n            result.push(row);\n            row = [];\n          }\n          row.push(entry.fn);\n          entry.children.forEach(function(childEntry) {\n            nextLevelEntries++;\n            queue.push(childEntry);\n          });\n          remainingLevelEntries--;\n        }\n\n        if (row.length) {\n          result.push(row);\n        }\n\n        return result;\n      }\n    }\n\n    // TODO(matsko): document the signature in a better way\n    return function(element, event, options) {\n      options = prepareAnimationOptions(options);\n      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;\n\n      // there is no animation at the current moment, however\n      // these runner methods will get later updated with the\n      // methods leading into the driver's end/cancel methods\n      // for now they just stop the animation from starting\n      var runner = new $$AnimateRunner({\n        end: function() { close(); },\n        cancel: function() { close(true); }\n      });\n\n      if (!drivers.length) {\n        close();\n        return runner;\n      }\n\n      setRunner(element, runner);\n\n      var classes = mergeClasses(element.attr('class'), mergeClasses(options.addClass, options.removeClass));\n      var tempClasses = options.tempClasses;\n      if (tempClasses) {\n        classes += ' ' + tempClasses;\n        options.tempClasses = null;\n      }\n\n      var prepareClassName;\n      if (isStructural) {\n        prepareClassName = 'ng-' + event + PREPARE_CLASS_SUFFIX;\n        $$jqLite.addClass(element, prepareClassName);\n      }\n\n      animationQueue.push({\n        // this data is used by the postDigest code and passed into\n        // the driver step function\n        element: element,\n        classes: classes,\n        event: event,\n        structural: isStructural,\n        options: options,\n        beforeStart: beforeStart,\n        close: close\n      });\n\n      element.on('$destroy', handleDestroyedElement);\n\n      // we only want there to be one function called within the post digest\n      // block. This way we can group animations for all the animations that\n      // were apart of the same postDigest flush call.\n      if (animationQueue.length > 1) return runner;\n\n      $rootScope.$$postDigest(function() {\n        var animations = [];\n        forEach(animationQueue, function(entry) {\n          // the element was destroyed early on which removed the runner\n          // form its storage. This means we can't animate this element\n          // at all and it already has been closed due to destruction.\n          if (getRunner(entry.element)) {\n            animations.push(entry);\n          } else {\n            entry.close();\n          }\n        });\n\n        // now any future animations will be in another postDigest\n        animationQueue.length = 0;\n\n        var groupedAnimations = groupAnimations(animations);\n        var toBeSortedAnimations = [];\n\n        forEach(groupedAnimations, function(animationEntry) {\n          toBeSortedAnimations.push({\n            domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),\n            fn: function triggerAnimationStart() {\n              // it's important that we apply the `ng-animate` CSS class and the\n              // temporary classes before we do any driver invoking since these\n              // CSS classes may be required for proper CSS detection.\n              animationEntry.beforeStart();\n\n              var startAnimationFn, closeFn = animationEntry.close;\n\n              // in the event that the element was removed before the digest runs or\n              // during the RAF sequencing then we should not trigger the animation.\n              var targetElement = animationEntry.anchors\n                  ? (animationEntry.from.element || animationEntry.to.element)\n                  : animationEntry.element;\n\n              if (getRunner(targetElement)) {\n                var operation = invokeFirstDriver(animationEntry);\n                if (operation) {\n                  startAnimationFn = operation.start;\n                }\n              }\n\n              if (!startAnimationFn) {\n                closeFn();\n              } else {\n                var animationRunner = startAnimationFn();\n                animationRunner.done(function(status) {\n                  closeFn(!status);\n                });\n                updateAnimationRunners(animationEntry, animationRunner);\n              }\n            }\n          });\n        });\n\n        // we need to sort each of the animations in order of parent to child\n        // relationships. This ensures that the child classes are applied at the\n        // right time.\n        $$rAFScheduler(sortAnimations(toBeSortedAnimations));\n      });\n\n      return runner;\n\n      // TODO(matsko): change to reference nodes\n      function getAnchorNodes(node) {\n        var SELECTOR = '[' + NG_ANIMATE_REF_ATTR + ']';\n        var items = node.hasAttribute(NG_ANIMATE_REF_ATTR)\n              ? [node]\n              : node.querySelectorAll(SELECTOR);\n        var anchors = [];\n        forEach(items, function(node) {\n          var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);\n          if (attr && attr.length) {\n            anchors.push(node);\n          }\n        });\n        return anchors;\n      }\n\n      function groupAnimations(animations) {\n        var preparedAnimations = [];\n        var refLookup = {};\n        forEach(animations, function(animation, index) {\n          var element = animation.element;\n          var node = getDomNode(element);\n          var event = animation.event;\n          var enterOrMove = ['enter', 'move'].indexOf(event) >= 0;\n          var anchorNodes = animation.structural ? getAnchorNodes(node) : [];\n\n          if (anchorNodes.length) {\n            var direction = enterOrMove ? 'to' : 'from';\n\n            forEach(anchorNodes, function(anchor) {\n              var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);\n              refLookup[key] = refLookup[key] || {};\n              refLookup[key][direction] = {\n                animationID: index,\n                element: jqLite(anchor)\n              };\n            });\n          } else {\n            preparedAnimations.push(animation);\n          }\n        });\n\n        var usedIndicesLookup = {};\n        var anchorGroups = {};\n        forEach(refLookup, function(operations, key) {\n          var from = operations.from;\n          var to = operations.to;\n\n          if (!from || !to) {\n            // only one of these is set therefore we can't have an\n            // anchor animation since all three pieces are required\n            var index = from ? from.animationID : to.animationID;\n            var indexKey = index.toString();\n            if (!usedIndicesLookup[indexKey]) {\n              usedIndicesLookup[indexKey] = true;\n              preparedAnimations.push(animations[index]);\n            }\n            return;\n          }\n\n          var fromAnimation = animations[from.animationID];\n          var toAnimation = animations[to.animationID];\n          var lookupKey = from.animationID.toString();\n          if (!anchorGroups[lookupKey]) {\n            var group = anchorGroups[lookupKey] = {\n              structural: true,\n              beforeStart: function() {\n                fromAnimation.beforeStart();\n                toAnimation.beforeStart();\n              },\n              close: function() {\n                fromAnimation.close();\n                toAnimation.close();\n              },\n              classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),\n              from: fromAnimation,\n              to: toAnimation,\n              anchors: [] // TODO(matsko): change to reference nodes\n            };\n\n            // the anchor animations require that the from and to elements both have at least\n            // one shared CSS class which effectively marries the two elements together to use\n            // the same animation driver and to properly sequence the anchor animation.\n            if (group.classes.length) {\n              preparedAnimations.push(group);\n            } else {\n              preparedAnimations.push(fromAnimation);\n              preparedAnimations.push(toAnimation);\n            }\n          }\n\n          anchorGroups[lookupKey].anchors.push({\n            'out': from.element, 'in': to.element\n          });\n        });\n\n        return preparedAnimations;\n      }\n\n      function cssClassesIntersection(a,b) {\n        a = a.split(' ');\n        b = b.split(' ');\n        var matches = [];\n\n        for (var i = 0; i < a.length; i++) {\n          var aa = a[i];\n          if (aa.substring(0,3) === 'ng-') continue;\n\n          for (var j = 0; j < b.length; j++) {\n            if (aa === b[j]) {\n              matches.push(aa);\n              break;\n            }\n          }\n        }\n\n        return matches.join(' ');\n      }\n\n      function invokeFirstDriver(animationDetails) {\n        // we loop in reverse order since the more general drivers (like CSS and JS)\n        // may attempt more elements, but custom drivers are more particular\n        for (var i = drivers.length - 1; i >= 0; i--) {\n          var driverName = drivers[i];\n          var factory = $injector.get(driverName);\n          var driver = factory(animationDetails);\n          if (driver) {\n            return driver;\n          }\n        }\n      }\n\n      function beforeStart() {\n        element.addClass(NG_ANIMATE_CLASSNAME);\n        if (tempClasses) {\n          $$jqLite.addClass(element, tempClasses);\n        }\n        if (prepareClassName) {\n          $$jqLite.removeClass(element, prepareClassName);\n          prepareClassName = null;\n        }\n      }\n\n      function updateAnimationRunners(animation, newRunner) {\n        if (animation.from && animation.to) {\n          update(animation.from.element);\n          update(animation.to.element);\n        } else {\n          update(animation.element);\n        }\n\n        function update(element) {\n          var runner = getRunner(element);\n          if (runner) runner.setHost(newRunner);\n        }\n      }\n\n      function handleDestroyedElement() {\n        var runner = getRunner(element);\n        if (runner && (event !== 'leave' || !options.$$domOperationFired)) {\n          runner.end();\n        }\n      }\n\n      function close(rejected) { // jshint ignore:line\n        element.off('$destroy', handleDestroyedElement);\n        removeRunner(element);\n\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n        options.domOperation();\n\n        if (tempClasses) {\n          $$jqLite.removeClass(element, tempClasses);\n        }\n\n        element.removeClass(NG_ANIMATE_CLASSNAME);\n        runner.complete(!rejected);\n      }\n    };\n  }];\n}];\n\n/**\n * @ngdoc directive\n * @name ngAnimateSwap\n * @restrict A\n * @scope\n *\n * @description\n *\n * ngAnimateSwap is a animation-oriented directive that allows for the container to\n * be removed and entered in whenever the associated expression changes. A\n * common usecase for this directive is a rotating banner or slider component which\n * contains one image being present at a time. When the active image changes\n * then the old image will perform a `leave` animation and the new element\n * will be inserted via an `enter` animation.\n *\n * @animations\n * | Animation                        | Occurs                               |\n * |----------------------------------|--------------------------------------|\n * | {@link ng.$animate#enter enter}  | when the new element is inserted to the DOM  |\n * | {@link ng.$animate#leave leave}  | when the old element is removed from the DOM |\n *\n * @example\n * <example name=\"ngAnimateSwap-directive\" module=\"ngAnimateSwapExample\"\n *          deps=\"angular-animate.js\"\n *          animations=\"true\" fixBase=\"true\">\n *   <file name=\"index.html\">\n *     <div class=\"container\" ng-controller=\"AppCtrl\">\n *       <div ng-animate-swap=\"number\" class=\"cell swap-animation\" ng-class=\"colorClass(number)\">\n *         {{ number }}\n *       </div>\n *     </div>\n *   </file>\n *   <file name=\"script.js\">\n *     angular.module('ngAnimateSwapExample', ['ngAnimate'])\n *       .controller('AppCtrl', ['$scope', '$interval', function($scope, $interval) {\n *         $scope.number = 0;\n *         $interval(function() {\n *           $scope.number++;\n *         }, 1000);\n *\n *         var colors = ['red','blue','green','yellow','orange'];\n *         $scope.colorClass = function(number) {\n *           return colors[number % colors.length];\n *         };\n *       }]);\n *   </file>\n *  <file name=\"animations.css\">\n *  .container {\n *    height:250px;\n *    width:250px;\n *    position:relative;\n *    overflow:hidden;\n *    border:2px solid black;\n *  }\n *  .container .cell {\n *    font-size:150px;\n *    text-align:center;\n *    line-height:250px;\n *    position:absolute;\n *    top:0;\n *    left:0;\n *    right:0;\n *    border-bottom:2px solid black;\n *  }\n *  .swap-animation.ng-enter, .swap-animation.ng-leave {\n *    transition:0.5s linear all;\n *  }\n *  .swap-animation.ng-enter {\n *    top:-250px;\n *  }\n *  .swap-animation.ng-enter-active {\n *    top:0px;\n *  }\n *  .swap-animation.ng-leave {\n *    top:0px;\n *  }\n *  .swap-animation.ng-leave-active {\n *    top:250px;\n *  }\n *  .red { background:red; }\n *  .green { background:green; }\n *  .blue { background:blue; }\n *  .yellow { background:yellow; }\n *  .orange { background:orange; }\n *  </file>\n * </example>\n */\nvar ngAnimateSwapDirective = ['$animate', '$rootScope', function($animate, $rootScope) {\n  return {\n    restrict: 'A',\n    transclude: 'element',\n    terminal: true,\n    priority: 600, // we use 600 here to ensure that the directive is caught before others\n    link: function(scope, $element, attrs, ctrl, $transclude) {\n      var previousElement, previousScope;\n      scope.$watchCollection(attrs.ngAnimateSwap || attrs['for'], function(value) {\n        if (previousElement) {\n          $animate.leave(previousElement);\n        }\n        if (previousScope) {\n          previousScope.$destroy();\n          previousScope = null;\n        }\n        if (value || value === 0) {\n          previousScope = scope.$new();\n          $transclude(previousScope, function(element) {\n            previousElement = element;\n            $animate.enter(element, null, $element);\n          });\n        }\n      });\n    }\n  };\n}];\n\n/* global angularAnimateModule: true,\n\n   ngAnimateSwapDirective,\n   $$AnimateAsyncRunFactory,\n   $$rAFSchedulerFactory,\n   $$AnimateChildrenDirective,\n   $$AnimateQueueProvider,\n   $$AnimationProvider,\n   $AnimateCssProvider,\n   $$AnimateCssDriverProvider,\n   $$AnimateJsProvider,\n   $$AnimateJsDriverProvider,\n*/\n\n/**\n * @ngdoc module\n * @name ngAnimate\n * @description\n *\n * The `ngAnimate` module provides support for CSS-based animations (keyframes and transitions) as well as JavaScript-based animations via\n * callback hooks. Animations are not enabled by default, however, by including `ngAnimate` the animation hooks are enabled for an Angular app.\n *\n * <div doc-module-components=\"ngAnimate\"></div>\n *\n * # Usage\n * Simply put, there are two ways to make use of animations when ngAnimate is used: by using **CSS** and **JavaScript**. The former works purely based\n * using CSS (by using matching CSS selectors/styles) and the latter triggers animations that are registered via `module.animation()`. For\n * both CSS and JS animations the sole requirement is to have a matching `CSS class` that exists both in the registered animation and within\n * the HTML element that the animation will be triggered on.\n *\n * ## Directive Support\n * The following directives are \"animation aware\":\n *\n * | Directive                                                                                                | Supported Animations                                                     |\n * |----------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|\n * | {@link ng.directive:ngRepeat#animations ngRepeat}                                                        | enter, leave and move                                                    |\n * | {@link ngRoute.directive:ngView#animations ngView}                                                       | enter and leave                                                          |\n * | {@link ng.directive:ngInclude#animations ngInclude}                                                      | enter and leave                                                          |\n * | {@link ng.directive:ngSwitch#animations ngSwitch}                                                        | enter and leave                                                          |\n * | {@link ng.directive:ngIf#animations ngIf}                                                                | enter and leave                                                          |\n * | {@link ng.directive:ngClass#animations ngClass}                                                          | add and remove (the CSS class(es) present)                               |\n * | {@link ng.directive:ngShow#animations ngShow} & {@link ng.directive:ngHide#animations ngHide}            | add and remove (the ng-hide class value)                                 |\n * | {@link ng.directive:form#animation-hooks form} & {@link ng.directive:ngModel#animation-hooks ngModel}    | add and remove (dirty, pristine, valid, invalid & all other validations) |\n * | {@link module:ngMessages#animations ngMessages}                                                          | add and remove (ng-active & ng-inactive)                                 |\n * | {@link module:ngMessages#animations ngMessage}                                                           | enter and leave                                                          |\n *\n * (More information can be found by visiting each the documentation associated with each directive.)\n *\n * ## CSS-based Animations\n *\n * CSS-based animations with ngAnimate are unique since they require no JavaScript code at all. By using a CSS class that we reference between our HTML\n * and CSS code we can create an animation that will be picked up by Angular when an the underlying directive performs an operation.\n *\n * The example below shows how an `enter` animation can be made possible on an element using `ng-if`:\n *\n * ```html\n * <div ng-if=\"bool\" class=\"fade\">\n *    Fade me in out\n * </div>\n * <button ng-click=\"bool=true\">Fade In!</button>\n * <button ng-click=\"bool=false\">Fade Out!</button>\n * ```\n *\n * Notice the CSS class **fade**? We can now create the CSS transition code that references this class:\n *\n * ```css\n * /&#42; The starting CSS styles for the enter animation &#42;/\n * .fade.ng-enter {\n *   transition:0.5s linear all;\n *   opacity:0;\n * }\n *\n * /&#42; The finishing CSS styles for the enter animation &#42;/\n * .fade.ng-enter.ng-enter-active {\n *   opacity:1;\n * }\n * ```\n *\n * The key thing to remember here is that, depending on the animation event (which each of the directives above trigger depending on what's going on) two\n * generated CSS classes will be applied to the element; in the example above we have `.ng-enter` and `.ng-enter-active`. For CSS transitions, the transition\n * code **must** be defined within the starting CSS class (in this case `.ng-enter`). The destination class is what the transition will animate towards.\n *\n * If for example we wanted to create animations for `leave` and `move` (ngRepeat triggers move) then we can do so using the same CSS naming conventions:\n *\n * ```css\n * /&#42; now the element will fade out before it is removed from the DOM &#42;/\n * .fade.ng-leave {\n *   transition:0.5s linear all;\n *   opacity:1;\n * }\n * .fade.ng-leave.ng-leave-active {\n *   opacity:0;\n * }\n * ```\n *\n * We can also make use of **CSS Keyframes** by referencing the keyframe animation within the starting CSS class:\n *\n * ```css\n * /&#42; there is no need to define anything inside of the destination\n * CSS class since the keyframe will take charge of the animation &#42;/\n * .fade.ng-leave {\n *   animation: my_fade_animation 0.5s linear;\n *   -webkit-animation: my_fade_animation 0.5s linear;\n * }\n *\n * @keyframes my_fade_animation {\n *   from { opacity:1; }\n *   to { opacity:0; }\n * }\n *\n * @-webkit-keyframes my_fade_animation {\n *   from { opacity:1; }\n *   to { opacity:0; }\n * }\n * ```\n *\n * Feel free also mix transitions and keyframes together as well as any other CSS classes on the same element.\n *\n * ### CSS Class-based Animations\n *\n * Class-based animations (animations that are triggered via `ngClass`, `ngShow`, `ngHide` and some other directives) have a slightly different\n * naming convention. Class-based animations are basic enough that a standard transition or keyframe can be referenced on the class being added\n * and removed.\n *\n * For example if we wanted to do a CSS animation for `ngHide` then we place an animation on the `.ng-hide` CSS class:\n *\n * ```html\n * <div ng-show=\"bool\" class=\"fade\">\n *   Show and hide me\n * </div>\n * <button ng-click=\"bool=!bool\">Toggle</button>\n *\n * <style>\n * .fade.ng-hide {\n *   transition:0.5s linear all;\n *   opacity:0;\n * }\n * </style>\n * ```\n *\n * All that is going on here with ngShow/ngHide behind the scenes is the `.ng-hide` class is added/removed (when the hidden state is valid). Since\n * ngShow and ngHide are animation aware then we can match up a transition and ngAnimate handles the rest.\n *\n * In addition the addition and removal of the CSS class, ngAnimate also provides two helper methods that we can use to further decorate the animation\n * with CSS styles.\n *\n * ```html\n * <div ng-class=\"{on:onOff}\" class=\"highlight\">\n *   Highlight this box\n * </div>\n * <button ng-click=\"onOff=!onOff\">Toggle</button>\n *\n * <style>\n * .highlight {\n *   transition:0.5s linear all;\n * }\n * .highlight.on-add {\n *   background:white;\n * }\n * .highlight.on {\n *   background:yellow;\n * }\n * .highlight.on-remove {\n *   background:black;\n * }\n * </style>\n * ```\n *\n * We can also make use of CSS keyframes by placing them within the CSS classes.\n *\n *\n * ### CSS Staggering Animations\n * A Staggering animation is a collection of animations that are issued with a slight delay in between each successive operation resulting in a\n * curtain-like effect. The ngAnimate module (versions >=1.2) supports staggering animations and the stagger effect can be\n * performed by creating a **ng-EVENT-stagger** CSS class and attaching that class to the base CSS class used for\n * the animation. The style property expected within the stagger class can either be a **transition-delay** or an\n * **animation-delay** property (or both if your animation contains both transitions and keyframe animations).\n *\n * ```css\n * .my-animation.ng-enter {\n *   /&#42; standard transition code &#42;/\n *   transition: 1s linear all;\n *   opacity:0;\n * }\n * .my-animation.ng-enter-stagger {\n *   /&#42; this will have a 100ms delay between each successive leave animation &#42;/\n *   transition-delay: 0.1s;\n *\n *   /&#42; As of 1.4.4, this must always be set: it signals ngAnimate\n *     to not accidentally inherit a delay property from another CSS class &#42;/\n *   transition-duration: 0s;\n * }\n * .my-animation.ng-enter.ng-enter-active {\n *   /&#42; standard transition styles &#42;/\n *   opacity:1;\n * }\n * ```\n *\n * Staggering animations work by default in ngRepeat (so long as the CSS class is defined). Outside of ngRepeat, to use staggering animations\n * on your own, they can be triggered by firing multiple calls to the same event on $animate. However, the restrictions surrounding this\n * are that each of the elements must have the same CSS className value as well as the same parent element. A stagger operation\n * will also be reset if one or more animation frames have passed since the multiple calls to `$animate` were fired.\n *\n * The following code will issue the **ng-leave-stagger** event on the element provided:\n *\n * ```js\n * var kids = parent.children();\n *\n * $animate.leave(kids[0]); //stagger index=0\n * $animate.leave(kids[1]); //stagger index=1\n * $animate.leave(kids[2]); //stagger index=2\n * $animate.leave(kids[3]); //stagger index=3\n * $animate.leave(kids[4]); //stagger index=4\n *\n * window.requestAnimationFrame(function() {\n *   //stagger has reset itself\n *   $animate.leave(kids[5]); //stagger index=0\n *   $animate.leave(kids[6]); //stagger index=1\n *\n *   $scope.$digest();\n * });\n * ```\n *\n * Stagger animations are currently only supported within CSS-defined animations.\n *\n * ### The `ng-animate` CSS class\n *\n * When ngAnimate is animating an element it will apply the `ng-animate` CSS class to the element for the duration of the animation.\n * This is a temporary CSS class and it will be removed once the animation is over (for both JavaScript and CSS-based animations).\n *\n * Therefore, animations can be applied to an element using this temporary class directly via CSS.\n *\n * ```css\n * .zipper.ng-animate {\n *   transition:0.5s linear all;\n * }\n * .zipper.ng-enter {\n *   opacity:0;\n * }\n * .zipper.ng-enter.ng-enter-active {\n *   opacity:1;\n * }\n * .zipper.ng-leave {\n *   opacity:1;\n * }\n * .zipper.ng-leave.ng-leave-active {\n *   opacity:0;\n * }\n * ```\n *\n * (Note that the `ng-animate` CSS class is reserved and it cannot be applied on an element directly since ngAnimate will always remove\n * the CSS class once an animation has completed.)\n *\n *\n * ### The `ng-[event]-prepare` class\n *\n * This is a special class that can be used to prevent unwanted flickering / flash of content before\n * the actual animation starts. The class is added as soon as an animation is initialized, but removed\n * before the actual animation starts (after waiting for a $digest).\n * It is also only added for *structural* animations (`enter`, `move`, and `leave`).\n *\n * In practice, flickering can appear when nesting elements with structural animations such as `ngIf`\n * into elements that have class-based animations such as `ngClass`.\n *\n * ```html\n * <div ng-class=\"{red: myProp}\">\n *   <div ng-class=\"{blue: myProp}\">\n *     <div class=\"message\" ng-if=\"myProp\"></div>\n *   </div>\n * </div>\n * ```\n *\n * It is possible that during the `enter` animation, the `.message` div will be briefly visible before it starts animating.\n * In that case, you can add styles to the CSS that make sure the element stays hidden before the animation starts:\n *\n * ```css\n * .message.ng-enter-prepare {\n *   opacity: 0;\n * }\n *\n * ```\n *\n * ## JavaScript-based Animations\n *\n * ngAnimate also allows for animations to be consumed by JavaScript code. The approach is similar to CSS-based animations (where there is a shared\n * CSS class that is referenced in our HTML code) but in addition we need to register the JavaScript animation on the module. By making use of the\n * `module.animation()` module function we can register the animation.\n *\n * Let's see an example of a enter/leave animation using `ngRepeat`:\n *\n * ```html\n * <div ng-repeat=\"item in items\" class=\"slide\">\n *   {{ item }}\n * </div>\n * ```\n *\n * See the **slide** CSS class? Let's use that class to define an animation that we'll structure in our module code by using `module.animation`:\n *\n * ```js\n * myModule.animation('.slide', [function() {\n *   return {\n *     // make note that other events (like addClass/removeClass)\n *     // have different function input parameters\n *     enter: function(element, doneFn) {\n *       jQuery(element).fadeIn(1000, doneFn);\n *\n *       // remember to call doneFn so that angular\n *       // knows that the animation has concluded\n *     },\n *\n *     move: function(element, doneFn) {\n *       jQuery(element).fadeIn(1000, doneFn);\n *     },\n *\n *     leave: function(element, doneFn) {\n *       jQuery(element).fadeOut(1000, doneFn);\n *     }\n *   }\n * }]);\n * ```\n *\n * The nice thing about JS-based animations is that we can inject other services and make use of advanced animation libraries such as\n * greensock.js and velocity.js.\n *\n * If our animation code class-based (meaning that something like `ngClass`, `ngHide` and `ngShow` triggers it) then we can still define\n * our animations inside of the same registered animation, however, the function input arguments are a bit different:\n *\n * ```html\n * <div ng-class=\"color\" class=\"colorful\">\n *   this box is moody\n * </div>\n * <button ng-click=\"color='red'\">Change to red</button>\n * <button ng-click=\"color='blue'\">Change to blue</button>\n * <button ng-click=\"color='green'\">Change to green</button>\n * ```\n *\n * ```js\n * myModule.animation('.colorful', [function() {\n *   return {\n *     addClass: function(element, className, doneFn) {\n *       // do some cool animation and call the doneFn\n *     },\n *     removeClass: function(element, className, doneFn) {\n *       // do some cool animation and call the doneFn\n *     },\n *     setClass: function(element, addedClass, removedClass, doneFn) {\n *       // do some cool animation and call the doneFn\n *     }\n *   }\n * }]);\n * ```\n *\n * ## CSS + JS Animations Together\n *\n * AngularJS 1.4 and higher has taken steps to make the amalgamation of CSS and JS animations more flexible. However, unlike earlier versions of Angular,\n * defining CSS and JS animations to work off of the same CSS class will not work anymore. Therefore the example below will only result in **JS animations taking\n * charge of the animation**:\n *\n * ```html\n * <div ng-if=\"bool\" class=\"slide\">\n *   Slide in and out\n * </div>\n * ```\n *\n * ```js\n * myModule.animation('.slide', [function() {\n *   return {\n *     enter: function(element, doneFn) {\n *       jQuery(element).slideIn(1000, doneFn);\n *     }\n *   }\n * }]);\n * ```\n *\n * ```css\n * .slide.ng-enter {\n *   transition:0.5s linear all;\n *   transform:translateY(-100px);\n * }\n * .slide.ng-enter.ng-enter-active {\n *   transform:translateY(0);\n * }\n * ```\n *\n * Does this mean that CSS and JS animations cannot be used together? Do JS-based animations always have higher priority? We can make up for the\n * lack of CSS animations by using the `$animateCss` service to trigger our own tweaked-out, CSS-based animations directly from\n * our own JS-based animation code:\n *\n * ```js\n * myModule.animation('.slide', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element) {\n*        // this will trigger `.slide.ng-enter` and `.slide.ng-enter-active`.\n *       return $animateCss(element, {\n *         event: 'enter',\n *         structural: true\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * The nice thing here is that we can save bandwidth by sticking to our CSS-based animation code and we don't need to rely on a 3rd-party animation framework.\n *\n * The `$animateCss` service is very powerful since we can feed in all kinds of extra properties that will be evaluated and fed into a CSS transition or\n * keyframe animation. For example if we wanted to animate the height of an element while adding and removing classes then we can do so by providing that\n * data into `$animateCss` directly:\n *\n * ```js\n * myModule.animation('.slide', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element) {\n *       return $animateCss(element, {\n *         event: 'enter',\n *         structural: true,\n *         addClass: 'maroon-setting',\n *         from: { height:0 },\n *         to: { height: 200 }\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * Now we can fill in the rest via our transition CSS code:\n *\n * ```css\n * /&#42; the transition tells ngAnimate to make the animation happen &#42;/\n * .slide.ng-enter { transition:0.5s linear all; }\n *\n * /&#42; this extra CSS class will be absorbed into the transition\n * since the $animateCss code is adding the class &#42;/\n * .maroon-setting { background:red; }\n * ```\n *\n * And `$animateCss` will figure out the rest. Just make sure to have the `done()` callback fire the `doneFn` function to signal when the animation is over.\n *\n * To learn more about what's possible be sure to visit the {@link ngAnimate.$animateCss $animateCss service}.\n *\n * ## Animation Anchoring (via `ng-animate-ref`)\n *\n * ngAnimate in AngularJS 1.4 comes packed with the ability to cross-animate elements between\n * structural areas of an application (like views) by pairing up elements using an attribute\n * called `ng-animate-ref`.\n *\n * Let's say for example we have two views that are managed by `ng-view` and we want to show\n * that there is a relationship between two components situated in within these views. By using the\n * `ng-animate-ref` attribute we can identify that the two components are paired together and we\n * can then attach an animation, which is triggered when the view changes.\n *\n * Say for example we have the following template code:\n *\n * ```html\n * <!-- index.html -->\n * <div ng-view class=\"view-animation\">\n * </div>\n *\n * <!-- home.html -->\n * <a href=\"#/banner-page\">\n *   <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">\n * </a>\n *\n * <!-- banner-page.html -->\n * <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">\n * ```\n *\n * Now, when the view changes (once the link is clicked), ngAnimate will examine the\n * HTML contents to see if there is a match reference between any components in the view\n * that is leaving and the view that is entering. It will scan both the view which is being\n * removed (leave) and inserted (enter) to see if there are any paired DOM elements that\n * contain a matching ref value.\n *\n * The two images match since they share the same ref value. ngAnimate will now create a\n * transport element (which is a clone of the first image element) and it will then attempt\n * to animate to the position of the second image element in the next view. For the animation to\n * work a special CSS class called `ng-anchor` will be added to the transported element.\n *\n * We can now attach a transition onto the `.banner.ng-anchor` CSS class and then\n * ngAnimate will handle the entire transition for us as well as the addition and removal of\n * any changes of CSS classes between the elements:\n *\n * ```css\n * .banner.ng-anchor {\n *   /&#42; this animation will last for 1 second since there are\n *          two phases to the animation (an `in` and an `out` phase) &#42;/\n *   transition:0.5s linear all;\n * }\n * ```\n *\n * We also **must** include animations for the views that are being entered and removed\n * (otherwise anchoring wouldn't be possible since the new view would be inserted right away).\n *\n * ```css\n * .view-animation.ng-enter, .view-animation.ng-leave {\n *   transition:0.5s linear all;\n *   position:fixed;\n *   left:0;\n *   top:0;\n *   width:100%;\n * }\n * .view-animation.ng-enter {\n *   transform:translateX(100%);\n * }\n * .view-animation.ng-leave,\n * .view-animation.ng-enter.ng-enter-active {\n *   transform:translateX(0%);\n * }\n * .view-animation.ng-leave.ng-leave-active {\n *   transform:translateX(-100%);\n * }\n * ```\n *\n * Now we can jump back to the anchor animation. When the animation happens, there are two stages that occur:\n * an `out` and an `in` stage. The `out` stage happens first and that is when the element is animated away\n * from its origin. Once that animation is over then the `in` stage occurs which animates the\n * element to its destination. The reason why there are two animations is to give enough time\n * for the enter animation on the new element to be ready.\n *\n * The example above sets up a transition for both the in and out phases, but we can also target the out or\n * in phases directly via `ng-anchor-out` and `ng-anchor-in`.\n *\n * ```css\n * .banner.ng-anchor-out {\n *   transition: 0.5s linear all;\n *\n *   /&#42; the scale will be applied during the out animation,\n *          but will be animated away when the in animation runs &#42;/\n *   transform: scale(1.2);\n * }\n *\n * .banner.ng-anchor-in {\n *   transition: 1s linear all;\n * }\n * ```\n *\n *\n *\n *\n * ### Anchoring Demo\n *\n  <example module=\"anchoringExample\"\n           name=\"anchoringExample\"\n           id=\"anchoringExample\"\n           deps=\"angular-animate.js;angular-route.js\"\n           animations=\"true\">\n    <file name=\"index.html\">\n      <a href=\"#/\">Home</a>\n      <hr />\n      <div class=\"view-container\">\n        <div ng-view class=\"view\"></div>\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('anchoringExample', ['ngAnimate', 'ngRoute'])\n        .config(['$routeProvider', function($routeProvider) {\n          $routeProvider.when('/', {\n            templateUrl: 'home.html',\n            controller: 'HomeController as home'\n          });\n          $routeProvider.when('/profile/:id', {\n            templateUrl: 'profile.html',\n            controller: 'ProfileController as profile'\n          });\n        }])\n        .run(['$rootScope', function($rootScope) {\n          $rootScope.records = [\n            { id:1, title: \"Miss Beulah Roob\" },\n            { id:2, title: \"Trent Morissette\" },\n            { id:3, title: \"Miss Ava Pouros\" },\n            { id:4, title: \"Rod Pouros\" },\n            { id:5, title: \"Abdul Rice\" },\n            { id:6, title: \"Laurie Rutherford Sr.\" },\n            { id:7, title: \"Nakia McLaughlin\" },\n            { id:8, title: \"Jordon Blanda DVM\" },\n            { id:9, title: \"Rhoda Hand\" },\n            { id:10, title: \"Alexandrea Sauer\" }\n          ];\n        }])\n        .controller('HomeController', [function() {\n          //empty\n        }])\n        .controller('ProfileController', ['$rootScope', '$routeParams', function($rootScope, $routeParams) {\n          var index = parseInt($routeParams.id, 10);\n          var record = $rootScope.records[index - 1];\n\n          this.title = record.title;\n          this.id = record.id;\n        }]);\n    </file>\n    <file name=\"home.html\">\n      <h2>Welcome to the home page</h1>\n      <p>Please click on an element</p>\n      <a class=\"record\"\n         ng-href=\"#/profile/{{ record.id }}\"\n         ng-animate-ref=\"{{ record.id }}\"\n         ng-repeat=\"record in records\">\n        {{ record.title }}\n      </a>\n    </file>\n    <file name=\"profile.html\">\n      <div class=\"profile record\" ng-animate-ref=\"{{ profile.id }}\">\n        {{ profile.title }}\n      </div>\n    </file>\n    <file name=\"animations.css\">\n      .record {\n        display:block;\n        font-size:20px;\n      }\n      .profile {\n        background:black;\n        color:white;\n        font-size:100px;\n      }\n      .view-container {\n        position:relative;\n      }\n      .view-container > .view.ng-animate {\n        position:absolute;\n        top:0;\n        left:0;\n        width:100%;\n        min-height:500px;\n      }\n      .view.ng-enter, .view.ng-leave,\n      .record.ng-anchor {\n        transition:0.5s linear all;\n      }\n      .view.ng-enter {\n        transform:translateX(100%);\n      }\n      .view.ng-enter.ng-enter-active, .view.ng-leave {\n        transform:translateX(0%);\n      }\n      .view.ng-leave.ng-leave-active {\n        transform:translateX(-100%);\n      }\n      .record.ng-anchor-out {\n        background:red;\n      }\n    </file>\n  </example>\n *\n * ### How is the element transported?\n *\n * When an anchor animation occurs, ngAnimate will clone the starting element and position it exactly where the starting\n * element is located on screen via absolute positioning. The cloned element will be placed inside of the root element\n * of the application (where ng-app was defined) and all of the CSS classes of the starting element will be applied. The\n * element will then animate into the `out` and `in` animations and will eventually reach the coordinates and match\n * the dimensions of the destination element. During the entire animation a CSS class of `.ng-animate-shim` will be applied\n * to both the starting and destination elements in order to hide them from being visible (the CSS styling for the class\n * is: `visibility:hidden`). Once the anchor reaches its destination then it will be removed and the destination element\n * will become visible since the shim class will be removed.\n *\n * ### How is the morphing handled?\n *\n * CSS Anchoring relies on transitions and keyframes and the internal code is intelligent enough to figure out\n * what CSS classes differ between the starting element and the destination element. These different CSS classes\n * will be added/removed on the anchor element and a transition will be applied (the transition that is provided\n * in the anchor class). Long story short, ngAnimate will figure out what classes to add and remove which will\n * make the transition of the element as smooth and automatic as possible. Be sure to use simple CSS classes that\n * do not rely on DOM nesting structure so that the anchor element appears the same as the starting element (since\n * the cloned element is placed inside of root element which is likely close to the body element).\n *\n * Note that if the root element is on the `<html>` element then the cloned node will be placed inside of body.\n *\n *\n * ## Using $animate in your directive code\n *\n * So far we've explored how to feed in animations into an Angular application, but how do we trigger animations within our own directives in our application?\n * By injecting the `$animate` service into our directive code, we can trigger structural and class-based hooks which can then be consumed by animations. Let's\n * imagine we have a greeting box that shows and hides itself when the data changes\n *\n * ```html\n * <greeting-box active=\"onOrOff\">Hi there</greeting-box>\n * ```\n *\n * ```js\n * ngModule.directive('greetingBox', ['$animate', function($animate) {\n *   return function(scope, element, attrs) {\n *     attrs.$observe('active', function(value) {\n *       value ? $animate.addClass(element, 'on') : $animate.removeClass(element, 'on');\n *     });\n *   });\n * }]);\n * ```\n *\n * Now the `on` CSS class is added and removed on the greeting box component. Now if we add a CSS class on top of the greeting box element\n * in our HTML code then we can trigger a CSS or JS animation to happen.\n *\n * ```css\n * /&#42; normally we would create a CSS class to reference on the element &#42;/\n * greeting-box.on { transition:0.5s linear all; background:green; color:white; }\n * ```\n *\n * The `$animate` service contains a variety of other methods like `enter`, `leave`, `animate` and `setClass`. To learn more about what's\n * possible be sure to visit the {@link ng.$animate $animate service API page}.\n *\n *\n * ## Callbacks and Promises\n *\n * When `$animate` is called it returns a promise that can be used to capture when the animation has ended. Therefore if we were to trigger\n * an animation (within our directive code) then we can continue performing directive and scope related activities after the animation has\n * ended by chaining onto the returned promise that animation method returns.\n *\n * ```js\n * // somewhere within the depths of the directive\n * $animate.enter(element, parent).then(function() {\n *   //the animation has completed\n * });\n * ```\n *\n * (Note that earlier versions of Angular prior to v1.4 required the promise code to be wrapped using `$scope.$apply(...)`. This is not the case\n * anymore.)\n *\n * In addition to the animation promise, we can also make use of animation-related callbacks within our directives and controller code by registering\n * an event listener using the `$animate` service. Let's say for example that an animation was triggered on our view\n * routing controller to hook into that:\n *\n * ```js\n * ngModule.controller('HomePageController', ['$animate', function($animate) {\n *   $animate.on('enter', ngViewElement, function(element) {\n *     // the animation for this route has completed\n *   }]);\n * }])\n * ```\n *\n * (Note that you will need to trigger a digest within the callback to get angular to notice any scope-related changes.)\n */\n\n/**\n * @ngdoc service\n * @name $animate\n * @kind object\n *\n * @description\n * The ngAnimate `$animate` service documentation is the same for the core `$animate` service.\n *\n * Click here {@link ng.$animate to learn more about animations with `$animate`}.\n */\nangular.module('ngAnimate', [])\n  .directive('ngAnimateSwap', ngAnimateSwapDirective)\n\n  .directive('ngAnimateChildren', $$AnimateChildrenDirective)\n  .factory('$$rAFScheduler', $$rAFSchedulerFactory)\n\n  .provider('$$animateQueue', $$AnimateQueueProvider)\n  .provider('$$animation', $$AnimationProvider)\n\n  .provider('$animateCss', $AnimateCssProvider)\n  .provider('$$animateCssDriver', $$AnimateCssDriverProvider)\n\n  .provider('$$animateJs', $$AnimateJsProvider)\n  .provider('$$animateJsDriver', $$AnimateJsDriverProvider);\n\n\n})(window, window.angular);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-animate/angular-animate.js\n ** module id = 6\n ** module chunks = 0\n **/","require('./dist/ui-bootstrap-tpls');\n\nmodule.exports = 'ui.bootstrap';\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-ui-bootstrap/index.js\n ** module id = 7\n ** module chunks = 0\n **/","/*\n * angular-ui-bootstrap\n * http://angular-ui.github.io/bootstrap/\n\n * Version: 1.3.3 - 2016-05-22\n * License: MIT\n */angular.module(\"ui.bootstrap\", [\"ui.bootstrap.tpls\", \"ui.bootstrap.collapse\",\"ui.bootstrap.accordion\",\"ui.bootstrap.alert\",\"ui.bootstrap.buttons\",\"ui.bootstrap.carousel\",\"ui.bootstrap.dateparser\",\"ui.bootstrap.isClass\",\"ui.bootstrap.datepicker\",\"ui.bootstrap.position\",\"ui.bootstrap.datepickerPopup\",\"ui.bootstrap.debounce\",\"ui.bootstrap.dropdown\",\"ui.bootstrap.stackedMap\",\"ui.bootstrap.modal\",\"ui.bootstrap.paging\",\"ui.bootstrap.pager\",\"ui.bootstrap.pagination\",\"ui.bootstrap.tooltip\",\"ui.bootstrap.popover\",\"ui.bootstrap.progressbar\",\"ui.bootstrap.rating\",\"ui.bootstrap.tabs\",\"ui.bootstrap.timepicker\",\"ui.bootstrap.typeahead\"]);\nangular.module(\"ui.bootstrap.tpls\", [\"uib/template/accordion/accordion-group.html\",\"uib/template/accordion/accordion.html\",\"uib/template/alert/alert.html\",\"uib/template/carousel/carousel.html\",\"uib/template/carousel/slide.html\",\"uib/template/datepicker/datepicker.html\",\"uib/template/datepicker/day.html\",\"uib/template/datepicker/month.html\",\"uib/template/datepicker/year.html\",\"uib/template/datepickerPopup/popup.html\",\"uib/template/modal/backdrop.html\",\"uib/template/modal/window.html\",\"uib/template/pager/pager.html\",\"uib/template/pagination/pagination.html\",\"uib/template/tooltip/tooltip-html-popup.html\",\"uib/template/tooltip/tooltip-popup.html\",\"uib/template/tooltip/tooltip-template-popup.html\",\"uib/template/popover/popover-html.html\",\"uib/template/popover/popover-template.html\",\"uib/template/popover/popover.html\",\"uib/template/progressbar/bar.html\",\"uib/template/progressbar/progress.html\",\"uib/template/progressbar/progressbar.html\",\"uib/template/rating/rating.html\",\"uib/template/tabs/tab.html\",\"uib/template/tabs/tabset.html\",\"uib/template/timepicker/timepicker.html\",\"uib/template/typeahead/typeahead-match.html\",\"uib/template/typeahead/typeahead-popup.html\"]);\nangular.module('ui.bootstrap.collapse', [])\n\n  .directive('uibCollapse', ['$animate', '$q', '$parse', '$injector', function($animate, $q, $parse, $injector) {\n    var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;\n    return {\n      link: function(scope, element, attrs) {\n        var expandingExpr = $parse(attrs.expanding),\n            expandedExpr = $parse(attrs.expanded),\n            collapsingExpr = $parse(attrs.collapsing),\n            collapsedExpr = $parse(attrs.collapsed);\n\n        if (!scope.$eval(attrs.uibCollapse)) {\n          element.addClass('in')\n            .addClass('collapse')\n            .attr('aria-expanded', true)\n            .attr('aria-hidden', false)\n            .css({height: 'auto'});\n        }\n\n        function expand() {\n          if (element.hasClass('collapse') && element.hasClass('in')) {\n            return;\n          }\n\n          $q.resolve(expandingExpr(scope))\n            .then(function() {\n              element.removeClass('collapse')\n                .addClass('collapsing')\n                .attr('aria-expanded', true)\n                .attr('aria-hidden', false);\n\n              if ($animateCss) {\n                $animateCss(element, {\n                  addClass: 'in',\n                  easing: 'ease',\n                  to: { height: element[0].scrollHeight + 'px' }\n                }).start()['finally'](expandDone);\n              } else {\n                $animate.addClass(element, 'in', {\n                  to: { height: element[0].scrollHeight + 'px' }\n                }).then(expandDone);\n              }\n            });\n        }\n\n        function expandDone() {\n          element.removeClass('collapsing')\n            .addClass('collapse')\n            .css({height: 'auto'});\n          expandedExpr(scope);\n        }\n\n        function collapse() {\n          if (!element.hasClass('collapse') && !element.hasClass('in')) {\n            return collapseDone();\n          }\n\n          $q.resolve(collapsingExpr(scope))\n            .then(function() {\n              element\n                // IMPORTANT: The height must be set before adding \"collapsing\" class.\n                // Otherwise, the browser attempts to animate from height 0 (in\n                // collapsing class) to the given height here.\n                .css({height: element[0].scrollHeight + 'px'})\n                // initially all panel collapse have the collapse class, this removal\n                // prevents the animation from jumping to collapsed state\n                .removeClass('collapse')\n                .addClass('collapsing')\n                .attr('aria-expanded', false)\n                .attr('aria-hidden', true);\n\n              if ($animateCss) {\n                $animateCss(element, {\n                  removeClass: 'in',\n                  to: {height: '0'}\n                }).start()['finally'](collapseDone);\n              } else {\n                $animate.removeClass(element, 'in', {\n                  to: {height: '0'}\n                }).then(collapseDone);\n              }\n            });\n        }\n\n        function collapseDone() {\n          element.css({height: '0'}); // Required so that collapse works when animation is disabled\n          element.removeClass('collapsing')\n            .addClass('collapse');\n          collapsedExpr(scope);\n        }\n\n        scope.$watch(attrs.uibCollapse, function(shouldCollapse) {\n          if (shouldCollapse) {\n            collapse();\n          } else {\n            expand();\n          }\n        });\n      }\n    };\n  }]);\n\nangular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse'])\n\n.constant('uibAccordionConfig', {\n  closeOthers: true\n})\n\n.controller('UibAccordionController', ['$scope', '$attrs', 'uibAccordionConfig', function($scope, $attrs, accordionConfig) {\n  // This array keeps track of the accordion groups\n  this.groups = [];\n\n  // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to\n  this.closeOthers = function(openGroup) {\n    var closeOthers = angular.isDefined($attrs.closeOthers) ?\n      $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;\n    if (closeOthers) {\n      angular.forEach(this.groups, function(group) {\n        if (group !== openGroup) {\n          group.isOpen = false;\n        }\n      });\n    }\n  };\n\n  // This is called from the accordion-group directive to add itself to the accordion\n  this.addGroup = function(groupScope) {\n    var that = this;\n    this.groups.push(groupScope);\n\n    groupScope.$on('$destroy', function(event) {\n      that.removeGroup(groupScope);\n    });\n  };\n\n  // This is called from the accordion-group directive when to remove itself\n  this.removeGroup = function(group) {\n    var index = this.groups.indexOf(group);\n    if (index !== -1) {\n      this.groups.splice(index, 1);\n    }\n  };\n}])\n\n// The accordion directive simply sets up the directive controller\n// and adds an accordion CSS class to itself element.\n.directive('uibAccordion', function() {\n  return {\n    controller: 'UibAccordionController',\n    controllerAs: 'accordion',\n    transclude: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/accordion/accordion.html';\n    }\n  };\n})\n\n// The accordion-group directive indicates a block of html that will expand and collapse in an accordion\n.directive('uibAccordionGroup', function() {\n  return {\n    require: '^uibAccordion',         // We need this directive to be inside an accordion\n    transclude: true,              // It transcludes the contents of the directive into the template\n    replace: true,                // The element containing the directive will be replaced with the template\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/accordion/accordion-group.html';\n    },\n    scope: {\n      heading: '@',               // Interpolate the heading attribute onto this scope\n      panelClass: '@?',           // Ditto with panelClass\n      isOpen: '=?',\n      isDisabled: '=?'\n    },\n    controller: function() {\n      this.setHeading = function(element) {\n        this.heading = element;\n      };\n    },\n    link: function(scope, element, attrs, accordionCtrl) {\n      accordionCtrl.addGroup(scope);\n\n      scope.openClass = attrs.openClass || 'panel-open';\n      scope.panelClass = attrs.panelClass || 'panel-default';\n      scope.$watch('isOpen', function(value) {\n        element.toggleClass(scope.openClass, !!value);\n        if (value) {\n          accordionCtrl.closeOthers(scope);\n        }\n      });\n\n      scope.toggleOpen = function($event) {\n        if (!scope.isDisabled) {\n          if (!$event || $event.which === 32) {\n            scope.isOpen = !scope.isOpen;\n          }\n        }\n      };\n\n      var id = 'accordiongroup-' + scope.$id + '-' + Math.floor(Math.random() * 10000);\n      scope.headingId = id + '-tab';\n      scope.panelId = id + '-panel';\n    }\n  };\n})\n\n// Use accordion-heading below an accordion-group to provide a heading containing HTML\n.directive('uibAccordionHeading', function() {\n  return {\n    transclude: true,   // Grab the contents to be used as the heading\n    template: '',       // In effect remove this element!\n    replace: true,\n    require: '^uibAccordionGroup',\n    link: function(scope, element, attrs, accordionGroupCtrl, transclude) {\n      // Pass the heading to the accordion-group controller\n      // so that it can be transcluded into the right place in the template\n      // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]\n      accordionGroupCtrl.setHeading(transclude(scope, angular.noop));\n    }\n  };\n})\n\n// Use in the accordion-group template to indicate where you want the heading to be transcluded\n// You must provide the property on the accordion-group controller that will hold the transcluded element\n.directive('uibAccordionTransclude', function() {\n  return {\n    require: '^uibAccordionGroup',\n    link: function(scope, element, attrs, controller) {\n      scope.$watch(function() { return controller[attrs.uibAccordionTransclude]; }, function(heading) {\n        if (heading) {\n          var elem = angular.element(element[0].querySelector(getHeaderSelectors()));\n          elem.html('');\n          elem.append(heading);\n        }\n      });\n    }\n  };\n\n  function getHeaderSelectors() {\n      return 'uib-accordion-header,' +\n          'data-uib-accordion-header,' +\n          'x-uib-accordion-header,' +\n          'uib\\\\:accordion-header,' +\n          '[uib-accordion-header],' +\n          '[data-uib-accordion-header],' +\n          '[x-uib-accordion-header]';\n  }\n});\n\nangular.module('ui.bootstrap.alert', [])\n\n.controller('UibAlertController', ['$scope', '$attrs', '$interpolate', '$timeout', function($scope, $attrs, $interpolate, $timeout) {\n  $scope.closeable = !!$attrs.close;\n\n  var dismissOnTimeout = angular.isDefined($attrs.dismissOnTimeout) ?\n    $interpolate($attrs.dismissOnTimeout)($scope.$parent) : null;\n\n  if (dismissOnTimeout) {\n    $timeout(function() {\n      $scope.close();\n    }, parseInt(dismissOnTimeout, 10));\n  }\n}])\n\n.directive('uibAlert', function() {\n  return {\n    controller: 'UibAlertController',\n    controllerAs: 'alert',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/alert/alert.html';\n    },\n    transclude: true,\n    replace: true,\n    scope: {\n      type: '@',\n      close: '&'\n    }\n  };\n});\n\nangular.module('ui.bootstrap.buttons', [])\n\n.constant('uibButtonConfig', {\n  activeClass: 'active',\n  toggleEvent: 'click'\n})\n\n.controller('UibButtonsController', ['uibButtonConfig', function(buttonConfig) {\n  this.activeClass = buttonConfig.activeClass || 'active';\n  this.toggleEvent = buttonConfig.toggleEvent || 'click';\n}])\n\n.directive('uibBtnRadio', ['$parse', function($parse) {\n  return {\n    require: ['uibBtnRadio', 'ngModel'],\n    controller: 'UibButtonsController',\n    controllerAs: 'buttons',\n    link: function(scope, element, attrs, ctrls) {\n      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n      var uncheckableExpr = $parse(attrs.uibUncheckable);\n\n      element.find('input').css({display: 'none'});\n\n      //model -> UI\n      ngModelCtrl.$render = function() {\n        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.uibBtnRadio)));\n      };\n\n      //ui->model\n      element.on(buttonsCtrl.toggleEvent, function() {\n        if (attrs.disabled) {\n          return;\n        }\n\n        var isActive = element.hasClass(buttonsCtrl.activeClass);\n\n        if (!isActive || angular.isDefined(attrs.uncheckable)) {\n          scope.$apply(function() {\n            ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.uibBtnRadio));\n            ngModelCtrl.$render();\n          });\n        }\n      });\n\n      if (attrs.uibUncheckable) {\n        scope.$watch(uncheckableExpr, function(uncheckable) {\n          attrs.$set('uncheckable', uncheckable ? '' : undefined);\n        });\n      }\n    }\n  };\n}])\n\n.directive('uibBtnCheckbox', function() {\n  return {\n    require: ['uibBtnCheckbox', 'ngModel'],\n    controller: 'UibButtonsController',\n    controllerAs: 'button',\n    link: function(scope, element, attrs, ctrls) {\n      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      element.find('input').css({display: 'none'});\n\n      function getTrueValue() {\n        return getCheckboxValue(attrs.btnCheckboxTrue, true);\n      }\n\n      function getFalseValue() {\n        return getCheckboxValue(attrs.btnCheckboxFalse, false);\n      }\n\n      function getCheckboxValue(attribute, defaultValue) {\n        return angular.isDefined(attribute) ? scope.$eval(attribute) : defaultValue;\n      }\n\n      //model -> UI\n      ngModelCtrl.$render = function() {\n        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));\n      };\n\n      //ui->model\n      element.on(buttonsCtrl.toggleEvent, function() {\n        if (attrs.disabled) {\n          return;\n        }\n\n        scope.$apply(function() {\n          ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());\n          ngModelCtrl.$render();\n        });\n      });\n    }\n  };\n});\n\nangular.module('ui.bootstrap.carousel', [])\n\n.controller('UibCarouselController', ['$scope', '$element', '$interval', '$timeout', '$animate', function($scope, $element, $interval, $timeout, $animate) {\n  var self = this,\n    slides = self.slides = $scope.slides = [],\n    SLIDE_DIRECTION = 'uib-slideDirection',\n    currentIndex = $scope.active,\n    currentInterval, isPlaying, bufferedTransitions = [];\n\n  var destroyed = false;\n\n  self.addSlide = function(slide, element) {\n    slides.push({\n      slide: slide,\n      element: element\n    });\n    slides.sort(function(a, b) {\n      return +a.slide.index - +b.slide.index;\n    });\n    //if this is the first slide or the slide is set to active, select it\n    if (slide.index === $scope.active || slides.length === 1 && !angular.isNumber($scope.active)) {\n      if ($scope.$currentTransition) {\n        $scope.$currentTransition = null;\n      }\n\n      currentIndex = slide.index;\n      $scope.active = slide.index;\n      setActive(currentIndex);\n      self.select(slides[findSlideIndex(slide)]);\n      if (slides.length === 1) {\n        $scope.play();\n      }\n    }\n  };\n\n  self.getCurrentIndex = function() {\n    for (var i = 0; i < slides.length; i++) {\n      if (slides[i].slide.index === currentIndex) {\n        return i;\n      }\n    }\n  };\n\n  self.next = $scope.next = function() {\n    var newIndex = (self.getCurrentIndex() + 1) % slides.length;\n\n    if (newIndex === 0 && $scope.noWrap()) {\n      $scope.pause();\n      return;\n    }\n\n    return self.select(slides[newIndex], 'next');\n  };\n\n  self.prev = $scope.prev = function() {\n    var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;\n\n    if ($scope.noWrap() && newIndex === slides.length - 1) {\n      $scope.pause();\n      return;\n    }\n\n    return self.select(slides[newIndex], 'prev');\n  };\n\n  self.removeSlide = function(slide) {\n    var index = findSlideIndex(slide);\n\n    var bufferedIndex = bufferedTransitions.indexOf(slides[index]);\n    if (bufferedIndex !== -1) {\n      bufferedTransitions.splice(bufferedIndex, 1);\n    }\n\n    //get the index of the slide inside the carousel\n    slides.splice(index, 1);\n    if (slides.length > 0 && currentIndex === index) {\n      if (index >= slides.length) {\n        currentIndex = slides.length - 1;\n        $scope.active = currentIndex;\n        setActive(currentIndex);\n        self.select(slides[slides.length - 1]);\n      } else {\n        currentIndex = index;\n        $scope.active = currentIndex;\n        setActive(currentIndex);\n        self.select(slides[index]);\n      }\n    } else if (currentIndex > index) {\n      currentIndex--;\n      $scope.active = currentIndex;\n    }\n\n    //clean the active value when no more slide\n    if (slides.length === 0) {\n      currentIndex = null;\n      $scope.active = null;\n      clearBufferedTransitions();\n    }\n  };\n\n  /* direction: \"prev\" or \"next\" */\n  self.select = $scope.select = function(nextSlide, direction) {\n    var nextIndex = findSlideIndex(nextSlide.slide);\n    //Decide direction if it's not given\n    if (direction === undefined) {\n      direction = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';\n    }\n    //Prevent this user-triggered transition from occurring if there is already one in progress\n    if (nextSlide.slide.index !== currentIndex &&\n      !$scope.$currentTransition) {\n      goNext(nextSlide.slide, nextIndex, direction);\n    } else if (nextSlide && nextSlide.slide.index !== currentIndex && $scope.$currentTransition) {\n      bufferedTransitions.push(slides[nextIndex]);\n    }\n  };\n\n  /* Allow outside people to call indexOf on slides array */\n  $scope.indexOfSlide = function(slide) {\n    return +slide.slide.index;\n  };\n\n  $scope.isActive = function(slide) {\n    return $scope.active === slide.slide.index;\n  };\n\n  $scope.isPrevDisabled = function() {\n    return $scope.active === 0 && $scope.noWrap();\n  };\n\n  $scope.isNextDisabled = function() {\n    return $scope.active === slides.length - 1 && $scope.noWrap();\n  };\n\n  $scope.pause = function() {\n    if (!$scope.noPause) {\n      isPlaying = false;\n      resetTimer();\n    }\n  };\n\n  $scope.play = function() {\n    if (!isPlaying) {\n      isPlaying = true;\n      restartTimer();\n    }\n  };\n\n  $scope.$on('$destroy', function() {\n    destroyed = true;\n    resetTimer();\n  });\n\n  $scope.$watch('noTransition', function(noTransition) {\n    $animate.enabled($element, !noTransition);\n  });\n\n  $scope.$watch('interval', restartTimer);\n\n  $scope.$watchCollection('slides', resetTransition);\n\n  $scope.$watch('active', function(index) {\n    if (angular.isNumber(index) && currentIndex !== index) {\n      for (var i = 0; i < slides.length; i++) {\n        if (slides[i].slide.index === index) {\n          index = i;\n          break;\n        }\n      }\n\n      var slide = slides[index];\n      if (slide) {\n        setActive(index);\n        self.select(slides[index]);\n        currentIndex = index;\n      }\n    }\n  });\n\n  function clearBufferedTransitions() {\n    while (bufferedTransitions.length) {\n      bufferedTransitions.shift();\n    }\n  }\n\n  function getSlideByIndex(index) {\n    for (var i = 0, l = slides.length; i < l; ++i) {\n      if (slides[i].index === index) {\n        return slides[i];\n      }\n    }\n  }\n\n  function setActive(index) {\n    for (var i = 0; i < slides.length; i++) {\n      slides[i].slide.active = i === index;\n    }\n  }\n\n  function goNext(slide, index, direction) {\n    if (destroyed) {\n      return;\n    }\n\n    angular.extend(slide, {direction: direction});\n    angular.extend(slides[currentIndex].slide || {}, {direction: direction});\n    if ($animate.enabled($element) && !$scope.$currentTransition &&\n      slides[index].element && self.slides.length > 1) {\n      slides[index].element.data(SLIDE_DIRECTION, slide.direction);\n      var currentIdx = self.getCurrentIndex();\n\n      if (angular.isNumber(currentIdx) && slides[currentIdx].element) {\n        slides[currentIdx].element.data(SLIDE_DIRECTION, slide.direction);\n      }\n\n      $scope.$currentTransition = true;\n      $animate.on('addClass', slides[index].element, function(element, phase) {\n        if (phase === 'close') {\n          $scope.$currentTransition = null;\n          $animate.off('addClass', element);\n          if (bufferedTransitions.length) {\n            var nextSlide = bufferedTransitions.pop().slide;\n            var nextIndex = nextSlide.index;\n            var nextDirection = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';\n            clearBufferedTransitions();\n\n            goNext(nextSlide, nextIndex, nextDirection);\n          }\n        }\n      });\n    }\n\n    $scope.active = slide.index;\n    currentIndex = slide.index;\n    setActive(index);\n\n    //every time you change slides, reset the timer\n    restartTimer();\n  }\n\n  function findSlideIndex(slide) {\n    for (var i = 0; i < slides.length; i++) {\n      if (slides[i].slide === slide) {\n        return i;\n      }\n    }\n  }\n\n  function resetTimer() {\n    if (currentInterval) {\n      $interval.cancel(currentInterval);\n      currentInterval = null;\n    }\n  }\n\n  function resetTransition(slides) {\n    if (!slides.length) {\n      $scope.$currentTransition = null;\n      clearBufferedTransitions();\n    }\n  }\n\n  function restartTimer() {\n    resetTimer();\n    var interval = +$scope.interval;\n    if (!isNaN(interval) && interval > 0) {\n      currentInterval = $interval(timerFn, interval);\n    }\n  }\n\n  function timerFn() {\n    var interval = +$scope.interval;\n    if (isPlaying && !isNaN(interval) && interval > 0 && slides.length) {\n      $scope.next();\n    } else {\n      $scope.pause();\n    }\n  }\n}])\n\n.directive('uibCarousel', function() {\n  return {\n    transclude: true,\n    replace: true,\n    controller: 'UibCarouselController',\n    controllerAs: 'carousel',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/carousel/carousel.html';\n    },\n    scope: {\n      active: '=',\n      interval: '=',\n      noTransition: '=',\n      noPause: '=',\n      noWrap: '&'\n    }\n  };\n})\n\n.directive('uibSlide', function() {\n  return {\n    require: '^uibCarousel',\n    transclude: true,\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/carousel/slide.html';\n    },\n    scope: {\n      actual: '=?',\n      index: '=?'\n    },\n    link: function (scope, element, attrs, carouselCtrl) {\n      carouselCtrl.addSlide(scope, element);\n      //when the scope is destroyed then remove the slide from the current slides array\n      scope.$on('$destroy', function() {\n        carouselCtrl.removeSlide(scope);\n      });\n    }\n  };\n})\n\n.animation('.item', ['$animateCss',\nfunction($animateCss) {\n  var SLIDE_DIRECTION = 'uib-slideDirection';\n\n  function removeClass(element, className, callback) {\n    element.removeClass(className);\n    if (callback) {\n      callback();\n    }\n  }\n\n  return {\n    beforeAddClass: function(element, className, done) {\n      if (className === 'active') {\n        var stopped = false;\n        var direction = element.data(SLIDE_DIRECTION);\n        var directionClass = direction === 'next' ? 'left' : 'right';\n        var removeClassFn = removeClass.bind(this, element,\n          directionClass + ' ' + direction, done);\n        element.addClass(direction);\n\n        $animateCss(element, {addClass: directionClass})\n          .start()\n          .done(removeClassFn);\n\n        return function() {\n          stopped = true;\n        };\n      }\n      done();\n    },\n    beforeRemoveClass: function (element, className, done) {\n      if (className === 'active') {\n        var stopped = false;\n        var direction = element.data(SLIDE_DIRECTION);\n        var directionClass = direction === 'next' ? 'left' : 'right';\n        var removeClassFn = removeClass.bind(this, element, directionClass, done);\n\n        $animateCss(element, {addClass: directionClass})\n          .start()\n          .done(removeClassFn);\n\n        return function() {\n          stopped = true;\n        };\n      }\n      done();\n    }\n  };\n}]);\n\nangular.module('ui.bootstrap.dateparser', [])\n\n.service('uibDateParser', ['$log', '$locale', 'dateFilter', 'orderByFilter', function($log, $locale, dateFilter, orderByFilter) {\n  // Pulled from https://github.com/mbostock/d3/blob/master/src/format/requote.js\n  var SPECIAL_CHARACTERS_REGEXP = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n\n  var localeId;\n  var formatCodeToRegex;\n\n  this.init = function() {\n    localeId = $locale.id;\n\n    this.parsers = {};\n    this.formatters = {};\n\n    formatCodeToRegex = [\n      {\n        key: 'yyyy',\n        regex: '\\\\d{4}',\n        apply: function(value) { this.year = +value; },\n        formatter: function(date) {\n          var _date = new Date();\n          _date.setFullYear(Math.abs(date.getFullYear()));\n          return dateFilter(_date, 'yyyy');\n        }\n      },\n      {\n        key: 'yy',\n        regex: '\\\\d{2}',\n        apply: function(value) { value = +value; this.year = value < 69 ? value + 2000 : value + 1900; },\n        formatter: function(date) {\n          var _date = new Date();\n          _date.setFullYear(Math.abs(date.getFullYear()));\n          return dateFilter(_date, 'yy');\n        }\n      },\n      {\n        key: 'y',\n        regex: '\\\\d{1,4}',\n        apply: function(value) { this.year = +value; },\n        formatter: function(date) {\n          var _date = new Date();\n          _date.setFullYear(Math.abs(date.getFullYear()));\n          return dateFilter(_date, 'y');\n        }\n      },\n      {\n        key: 'M!',\n        regex: '0?[1-9]|1[0-2]',\n        apply: function(value) { this.month = value - 1; },\n        formatter: function(date) {\n          var value = date.getMonth();\n          if (/^[0-9]$/.test(value)) {\n            return dateFilter(date, 'MM');\n          }\n\n          return dateFilter(date, 'M');\n        }\n      },\n      {\n        key: 'MMMM',\n        regex: $locale.DATETIME_FORMATS.MONTH.join('|'),\n        apply: function(value) { this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value); },\n        formatter: function(date) { return dateFilter(date, 'MMMM'); }\n      },\n      {\n        key: 'MMM',\n        regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\n        apply: function(value) { this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value); },\n        formatter: function(date) { return dateFilter(date, 'MMM'); }\n      },\n      {\n        key: 'MM',\n        regex: '0[1-9]|1[0-2]',\n        apply: function(value) { this.month = value - 1; },\n        formatter: function(date) { return dateFilter(date, 'MM'); }\n      },\n      {\n        key: 'M',\n        regex: '[1-9]|1[0-2]',\n        apply: function(value) { this.month = value - 1; },\n        formatter: function(date) { return dateFilter(date, 'M'); }\n      },\n      {\n        key: 'd!',\n        regex: '[0-2]?[0-9]{1}|3[0-1]{1}',\n        apply: function(value) { this.date = +value; },\n        formatter: function(date) {\n          var value = date.getDate();\n          if (/^[1-9]$/.test(value)) {\n            return dateFilter(date, 'dd');\n          }\n\n          return dateFilter(date, 'd');\n        }\n      },\n      {\n        key: 'dd',\n        regex: '[0-2][0-9]{1}|3[0-1]{1}',\n        apply: function(value) { this.date = +value; },\n        formatter: function(date) { return dateFilter(date, 'dd'); }\n      },\n      {\n        key: 'd',\n        regex: '[1-2]?[0-9]{1}|3[0-1]{1}',\n        apply: function(value) { this.date = +value; },\n        formatter: function(date) { return dateFilter(date, 'd'); }\n      },\n      {\n        key: 'EEEE',\n        regex: $locale.DATETIME_FORMATS.DAY.join('|'),\n        formatter: function(date) { return dateFilter(date, 'EEEE'); }\n      },\n      {\n        key: 'EEE',\n        regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|'),\n        formatter: function(date) { return dateFilter(date, 'EEE'); }\n      },\n      {\n        key: 'HH',\n        regex: '(?:0|1)[0-9]|2[0-3]',\n        apply: function(value) { this.hours = +value; },\n        formatter: function(date) { return dateFilter(date, 'HH'); }\n      },\n      {\n        key: 'hh',\n        regex: '0[0-9]|1[0-2]',\n        apply: function(value) { this.hours = +value; },\n        formatter: function(date) { return dateFilter(date, 'hh'); }\n      },\n      {\n        key: 'H',\n        regex: '1?[0-9]|2[0-3]',\n        apply: function(value) { this.hours = +value; },\n        formatter: function(date) { return dateFilter(date, 'H'); }\n      },\n      {\n        key: 'h',\n        regex: '[0-9]|1[0-2]',\n        apply: function(value) { this.hours = +value; },\n        formatter: function(date) { return dateFilter(date, 'h'); }\n      },\n      {\n        key: 'mm',\n        regex: '[0-5][0-9]',\n        apply: function(value) { this.minutes = +value; },\n        formatter: function(date) { return dateFilter(date, 'mm'); }\n      },\n      {\n        key: 'm',\n        regex: '[0-9]|[1-5][0-9]',\n        apply: function(value) { this.minutes = +value; },\n        formatter: function(date) { return dateFilter(date, 'm'); }\n      },\n      {\n        key: 'sss',\n        regex: '[0-9][0-9][0-9]',\n        apply: function(value) { this.milliseconds = +value; },\n        formatter: function(date) { return dateFilter(date, 'sss'); }\n      },\n      {\n        key: 'ss',\n        regex: '[0-5][0-9]',\n        apply: function(value) { this.seconds = +value; },\n        formatter: function(date) { return dateFilter(date, 'ss'); }\n      },\n      {\n        key: 's',\n        regex: '[0-9]|[1-5][0-9]',\n        apply: function(value) { this.seconds = +value; },\n        formatter: function(date) { return dateFilter(date, 's'); }\n      },\n      {\n        key: 'a',\n        regex: $locale.DATETIME_FORMATS.AMPMS.join('|'),\n        apply: function(value) {\n          if (this.hours === 12) {\n            this.hours = 0;\n          }\n\n          if (value === 'PM') {\n            this.hours += 12;\n          }\n        },\n        formatter: function(date) { return dateFilter(date, 'a'); }\n      },\n      {\n        key: 'Z',\n        regex: '[+-]\\\\d{4}',\n        apply: function(value) {\n          var matches = value.match(/([+-])(\\d{2})(\\d{2})/),\n            sign = matches[1],\n            hours = matches[2],\n            minutes = matches[3];\n          this.hours += toInt(sign + hours);\n          this.minutes += toInt(sign + minutes);\n        },\n        formatter: function(date) {\n          return dateFilter(date, 'Z');\n        }\n      },\n      {\n        key: 'ww',\n        regex: '[0-4][0-9]|5[0-3]',\n        formatter: function(date) { return dateFilter(date, 'ww'); }\n      },\n      {\n        key: 'w',\n        regex: '[0-9]|[1-4][0-9]|5[0-3]',\n        formatter: function(date) { return dateFilter(date, 'w'); }\n      },\n      {\n        key: 'GGGG',\n        regex: $locale.DATETIME_FORMATS.ERANAMES.join('|').replace(/\\s/g, '\\\\s'),\n        formatter: function(date) { return dateFilter(date, 'GGGG'); }\n      },\n      {\n        key: 'GGG',\n        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),\n        formatter: function(date) { return dateFilter(date, 'GGG'); }\n      },\n      {\n        key: 'GG',\n        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),\n        formatter: function(date) { return dateFilter(date, 'GG'); }\n      },\n      {\n        key: 'G',\n        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),\n        formatter: function(date) { return dateFilter(date, 'G'); }\n      }\n    ];\n  };\n\n  this.init();\n\n  function createParser(format, func) {\n    var map = [], regex = format.split('');\n\n    // check for literal values\n    var quoteIndex = format.indexOf('\\'');\n    if (quoteIndex > -1) {\n      var inLiteral = false;\n      format = format.split('');\n      for (var i = quoteIndex; i < format.length; i++) {\n        if (inLiteral) {\n          if (format[i] === '\\'') {\n            if (i + 1 < format.length && format[i+1] === '\\'') { // escaped single quote\n              format[i+1] = '$';\n              regex[i+1] = '';\n            } else { // end of literal\n              regex[i] = '';\n              inLiteral = false;\n            }\n          }\n          format[i] = '$';\n        } else {\n          if (format[i] === '\\'') { // start of literal\n            format[i] = '$';\n            regex[i] = '';\n            inLiteral = true;\n          }\n        }\n      }\n\n      format = format.join('');\n    }\n\n    angular.forEach(formatCodeToRegex, function(data) {\n      var index = format.indexOf(data.key);\n\n      if (index > -1) {\n        format = format.split('');\n\n        regex[index] = '(' + data.regex + ')';\n        format[index] = '$'; // Custom symbol to define consumed part of format\n        for (var i = index + 1, n = index + data.key.length; i < n; i++) {\n          regex[i] = '';\n          format[i] = '$';\n        }\n        format = format.join('');\n\n        map.push({\n          index: index,\n          key: data.key,\n          apply: data[func],\n          matcher: data.regex\n        });\n      }\n    });\n\n    return {\n      regex: new RegExp('^' + regex.join('') + '$'),\n      map: orderByFilter(map, 'index')\n    };\n  }\n\n  this.filter = function(date, format) {\n    if (!angular.isDate(date) || isNaN(date) || !format) {\n      return '';\n    }\n\n    format = $locale.DATETIME_FORMATS[format] || format;\n\n    if ($locale.id !== localeId) {\n      this.init();\n    }\n\n    if (!this.formatters[format]) {\n      this.formatters[format] = createParser(format, 'formatter');\n    }\n\n    var parser = this.formatters[format],\n      map = parser.map;\n\n    var _format = format;\n\n    return map.reduce(function(str, mapper, i) {\n      var match = _format.match(new RegExp('(.*)' + mapper.key));\n      if (match && angular.isString(match[1])) {\n        str += match[1];\n        _format = _format.replace(match[1] + mapper.key, '');\n      }\n\n      var endStr = i === map.length - 1 ? _format : '';\n\n      if (mapper.apply) {\n        return str + mapper.apply.call(null, date) + endStr;\n      }\n\n      return str + endStr;\n    }, '');\n  };\n\n  this.parse = function(input, format, baseDate) {\n    if (!angular.isString(input) || !format) {\n      return input;\n    }\n\n    format = $locale.DATETIME_FORMATS[format] || format;\n    format = format.replace(SPECIAL_CHARACTERS_REGEXP, '\\\\$&');\n\n    if ($locale.id !== localeId) {\n      this.init();\n    }\n\n    if (!this.parsers[format]) {\n      this.parsers[format] = createParser(format, 'apply');\n    }\n\n    var parser = this.parsers[format],\n        regex = parser.regex,\n        map = parser.map,\n        results = input.match(regex),\n        tzOffset = false;\n    if (results && results.length) {\n      var fields, dt;\n      if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {\n        fields = {\n          year: baseDate.getFullYear(),\n          month: baseDate.getMonth(),\n          date: baseDate.getDate(),\n          hours: baseDate.getHours(),\n          minutes: baseDate.getMinutes(),\n          seconds: baseDate.getSeconds(),\n          milliseconds: baseDate.getMilliseconds()\n        };\n      } else {\n        if (baseDate) {\n          $log.warn('dateparser:', 'baseDate is not a valid date');\n        }\n        fields = { year: 1900, month: 0, date: 1, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 };\n      }\n\n      for (var i = 1, n = results.length; i < n; i++) {\n        var mapper = map[i - 1];\n        if (mapper.matcher === 'Z') {\n          tzOffset = true;\n        }\n\n        if (mapper.apply) {\n          mapper.apply.call(fields, results[i]);\n        }\n      }\n\n      var datesetter = tzOffset ? Date.prototype.setUTCFullYear :\n        Date.prototype.setFullYear;\n      var timesetter = tzOffset ? Date.prototype.setUTCHours :\n        Date.prototype.setHours;\n\n      if (isValid(fields.year, fields.month, fields.date)) {\n        if (angular.isDate(baseDate) && !isNaN(baseDate.getTime()) && !tzOffset) {\n          dt = new Date(baseDate);\n          datesetter.call(dt, fields.year, fields.month, fields.date);\n          timesetter.call(dt, fields.hours, fields.minutes,\n            fields.seconds, fields.milliseconds);\n        } else {\n          dt = new Date(0);\n          datesetter.call(dt, fields.year, fields.month, fields.date);\n          timesetter.call(dt, fields.hours || 0, fields.minutes || 0,\n            fields.seconds || 0, fields.milliseconds || 0);\n        }\n      }\n\n      return dt;\n    }\n  };\n\n  // Check if date is valid for specific month (and year for February).\n  // Month: 0 = Jan, 1 = Feb, etc\n  function isValid(year, month, date) {\n    if (date < 1) {\n      return false;\n    }\n\n    if (month === 1 && date > 28) {\n      return date === 29 && (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0);\n    }\n\n    if (month === 3 || month === 5 || month === 8 || month === 10) {\n      return date < 31;\n    }\n\n    return true;\n  }\n\n  function toInt(str) {\n    return parseInt(str, 10);\n  }\n\n  this.toTimezone = toTimezone;\n  this.fromTimezone = fromTimezone;\n  this.timezoneToOffset = timezoneToOffset;\n  this.addDateMinutes = addDateMinutes;\n  this.convertTimezoneToLocal = convertTimezoneToLocal;\n\n  function toTimezone(date, timezone) {\n    return date && timezone ? convertTimezoneToLocal(date, timezone) : date;\n  }\n\n  function fromTimezone(date, timezone) {\n    return date && timezone ? convertTimezoneToLocal(date, timezone, true) : date;\n  }\n\n  //https://github.com/angular/angular.js/blob/622c42169699ec07fc6daaa19fe6d224e5d2f70e/src/Angular.js#L1207\n  function timezoneToOffset(timezone, fallback) {\n    timezone = timezone.replace(/:/g, '');\n    var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;\n    return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;\n  }\n\n  function addDateMinutes(date, minutes) {\n    date = new Date(date.getTime());\n    date.setMinutes(date.getMinutes() + minutes);\n    return date;\n  }\n\n  function convertTimezoneToLocal(date, timezone, reverse) {\n    reverse = reverse ? -1 : 1;\n    var dateTimezoneOffset = date.getTimezoneOffset();\n    var timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);\n    return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));\n  }\n}]);\n\n// Avoiding use of ng-class as it creates a lot of watchers when a class is to be applied to\n// at most one element.\nangular.module('ui.bootstrap.isClass', [])\n.directive('uibIsClass', [\n         '$animate',\nfunction ($animate) {\n  //                    11111111          22222222\n  var ON_REGEXP = /^\\s*([\\s\\S]+?)\\s+on\\s+([\\s\\S]+?)\\s*$/;\n  //                    11111111           22222222\n  var IS_REGEXP = /^\\s*([\\s\\S]+?)\\s+for\\s+([\\s\\S]+?)\\s*$/;\n\n  var dataPerTracked = {};\n\n  return {\n    restrict: 'A',\n    compile: function(tElement, tAttrs) {\n      var linkedScopes = [];\n      var instances = [];\n      var expToData = {};\n      var lastActivated = null;\n      var onExpMatches = tAttrs.uibIsClass.match(ON_REGEXP);\n      var onExp = onExpMatches[2];\n      var expsStr = onExpMatches[1];\n      var exps = expsStr.split(',');\n\n      return linkFn;\n\n      function linkFn(scope, element, attrs) {\n        linkedScopes.push(scope);\n        instances.push({\n          scope: scope,\n          element: element\n        });\n\n        exps.forEach(function(exp, k) {\n          addForExp(exp, scope);\n        });\n\n        scope.$on('$destroy', removeScope);\n      }\n\n      function addForExp(exp, scope) {\n        var matches = exp.match(IS_REGEXP);\n        var clazz = scope.$eval(matches[1]);\n        var compareWithExp = matches[2];\n        var data = expToData[exp];\n        if (!data) {\n          var watchFn = function(compareWithVal) {\n            var newActivated = null;\n            instances.some(function(instance) {\n              var thisVal = instance.scope.$eval(onExp);\n              if (thisVal === compareWithVal) {\n                newActivated = instance;\n                return true;\n              }\n            });\n            if (data.lastActivated !== newActivated) {\n              if (data.lastActivated) {\n                $animate.removeClass(data.lastActivated.element, clazz);\n              }\n              if (newActivated) {\n                $animate.addClass(newActivated.element, clazz);\n              }\n              data.lastActivated = newActivated;\n            }\n          };\n          expToData[exp] = data = {\n            lastActivated: null,\n            scope: scope,\n            watchFn: watchFn,\n            compareWithExp: compareWithExp,\n            watcher: scope.$watch(compareWithExp, watchFn)\n          };\n        }\n        data.watchFn(scope.$eval(compareWithExp));\n      }\n\n      function removeScope(e) {\n        var removedScope = e.targetScope;\n        var index = linkedScopes.indexOf(removedScope);\n        linkedScopes.splice(index, 1);\n        instances.splice(index, 1);\n        if (linkedScopes.length) {\n          var newWatchScope = linkedScopes[0];\n          angular.forEach(expToData, function(data) {\n            if (data.scope === removedScope) {\n              data.watcher = newWatchScope.$watch(data.compareWithExp, data.watchFn);\n              data.scope = newWatchScope;\n            }\n          });\n        } else {\n          expToData = {};\n        }\n      }\n    }\n  };\n}]);\nangular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.isClass'])\n\n.value('$datepickerSuppressError', false)\n\n.value('$datepickerLiteralWarning', true)\n\n.constant('uibDatepickerConfig', {\n  datepickerMode: 'day',\n  formatDay: 'dd',\n  formatMonth: 'MMMM',\n  formatYear: 'yyyy',\n  formatDayHeader: 'EEE',\n  formatDayTitle: 'MMMM yyyy',\n  formatMonthTitle: 'yyyy',\n  maxDate: null,\n  maxMode: 'year',\n  minDate: null,\n  minMode: 'day',\n  ngModelOptions: {},\n  shortcutPropagation: false,\n  showWeeks: true,\n  yearColumns: 5,\n  yearRows: 4\n})\n\n.controller('UibDatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$locale', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerLiteralWarning', '$datepickerSuppressError', 'uibDateParser',\n  function($scope, $attrs, $parse, $interpolate, $locale, $log, dateFilter, datepickerConfig, $datepickerLiteralWarning, $datepickerSuppressError, dateParser) {\n  var self = this,\n      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl;\n      ngModelOptions = {},\n      watchListeners = [],\n      optionsUsed = !!$attrs.datepickerOptions;\n\n  if (!$scope.datepickerOptions) {\n    $scope.datepickerOptions = {};\n  }\n\n  // Modes chain\n  this.modes = ['day', 'month', 'year'];\n\n  [\n    'customClass',\n    'dateDisabled',\n    'datepickerMode',\n    'formatDay',\n    'formatDayHeader',\n    'formatDayTitle',\n    'formatMonth',\n    'formatMonthTitle',\n    'formatYear',\n    'maxDate',\n    'maxMode',\n    'minDate',\n    'minMode',\n    'showWeeks',\n    'shortcutPropagation',\n    'startingDay',\n    'yearColumns',\n    'yearRows'\n  ].forEach(function(key) {\n    switch (key) {\n      case 'customClass':\n      case 'dateDisabled':\n        $scope[key] = $scope.datepickerOptions[key] || angular.noop;\n        break;\n      case 'datepickerMode':\n        $scope.datepickerMode = angular.isDefined($scope.datepickerOptions.datepickerMode) ?\n          $scope.datepickerOptions.datepickerMode : datepickerConfig.datepickerMode;\n        break;\n      case 'formatDay':\n      case 'formatDayHeader':\n      case 'formatDayTitle':\n      case 'formatMonth':\n      case 'formatMonthTitle':\n      case 'formatYear':\n        self[key] = angular.isDefined($scope.datepickerOptions[key]) ?\n          $interpolate($scope.datepickerOptions[key])($scope.$parent) :\n          datepickerConfig[key];\n        break;\n      case 'showWeeks':\n      case 'shortcutPropagation':\n      case 'yearColumns':\n      case 'yearRows':\n        self[key] = angular.isDefined($scope.datepickerOptions[key]) ?\n          $scope.datepickerOptions[key] : datepickerConfig[key];\n        break;\n      case 'startingDay':\n        if (angular.isDefined($scope.datepickerOptions.startingDay)) {\n          self.startingDay = $scope.datepickerOptions.startingDay;\n        } else if (angular.isNumber(datepickerConfig.startingDay)) {\n          self.startingDay = datepickerConfig.startingDay;\n        } else {\n          self.startingDay = ($locale.DATETIME_FORMATS.FIRSTDAYOFWEEK + 8) % 7;\n        }\n\n        break;\n      case 'maxDate':\n      case 'minDate':\n        $scope.$watch('datepickerOptions.' + key, function(value) {\n          if (value) {\n            if (angular.isDate(value)) {\n              self[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.timezone);\n            } else {\n              if ($datepickerLiteralWarning) {\n                $log.warn('Literal date support has been deprecated, please switch to date object usage');\n              }\n\n              self[key] = new Date(dateFilter(value, 'medium'));\n            }\n          } else {\n            self[key] = datepickerConfig[key] ?\n              dateParser.fromTimezone(new Date(datepickerConfig[key]), ngModelOptions.timezone) :\n              null;\n          }\n\n          self.refreshView();\n        });\n\n        break;\n      case 'maxMode':\n      case 'minMode':\n        if ($scope.datepickerOptions[key]) {\n          $scope.$watch(function() { return $scope.datepickerOptions[key]; }, function(value) {\n            self[key] = $scope[key] = angular.isDefined(value) ? value : datepickerOptions[key];\n            if (key === 'minMode' && self.modes.indexOf($scope.datepickerOptions.datepickerMode) < self.modes.indexOf(self[key]) ||\n              key === 'maxMode' && self.modes.indexOf($scope.datepickerOptions.datepickerMode) > self.modes.indexOf(self[key])) {\n              $scope.datepickerMode = self[key];\n              $scope.datepickerOptions.datepickerMode = self[key];\n            }\n          });\n        } else {\n          self[key] = $scope[key] = datepickerConfig[key] || null;\n        }\n\n        break;\n    }\n  });\n\n  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);\n\n  $scope.disabled = angular.isDefined($attrs.disabled) || false;\n  if (angular.isDefined($attrs.ngDisabled)) {\n    watchListeners.push($scope.$parent.$watch($attrs.ngDisabled, function(disabled) {\n      $scope.disabled = disabled;\n      self.refreshView();\n    }));\n  }\n\n  $scope.isActive = function(dateObject) {\n    if (self.compare(dateObject.date, self.activeDate) === 0) {\n      $scope.activeDateId = dateObject.uid;\n      return true;\n    }\n    return false;\n  };\n\n  this.init = function(ngModelCtrl_) {\n    ngModelCtrl = ngModelCtrl_;\n    ngModelOptions = ngModelCtrl_.$options || datepickerConfig.ngModelOptions;\n    if ($scope.datepickerOptions.initDate) {\n      self.activeDate = dateParser.fromTimezone($scope.datepickerOptions.initDate, ngModelOptions.timezone) || new Date();\n      $scope.$watch('datepickerOptions.initDate', function(initDate) {\n        if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {\n          self.activeDate = dateParser.fromTimezone(initDate, ngModelOptions.timezone);\n          self.refreshView();\n        }\n      });\n    } else {\n      self.activeDate = new Date();\n    }\n\n    var date = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : new Date();\n    this.activeDate = !isNaN(date) ?\n      dateParser.fromTimezone(date, ngModelOptions.timezone) :\n      dateParser.fromTimezone(new Date(), ngModelOptions.timezone);\n\n    ngModelCtrl.$render = function() {\n      self.render();\n    };\n  };\n\n  this.render = function() {\n    if (ngModelCtrl.$viewValue) {\n      var date = new Date(ngModelCtrl.$viewValue),\n          isValid = !isNaN(date);\n\n      if (isValid) {\n        this.activeDate = dateParser.fromTimezone(date, ngModelOptions.timezone);\n      } else if (!$datepickerSuppressError) {\n        $log.error('Datepicker directive: \"ng-model\" value must be a Date object');\n      }\n    }\n    this.refreshView();\n  };\n\n  this.refreshView = function() {\n    if (this.element) {\n      $scope.selectedDt = null;\n      this._refreshView();\n      if ($scope.activeDt) {\n        $scope.activeDateId = $scope.activeDt.uid;\n      }\n\n      var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n      date = dateParser.fromTimezone(date, ngModelOptions.timezone);\n      ngModelCtrl.$setValidity('dateDisabled', !date ||\n        this.element && !this.isDisabled(date));\n    }\n  };\n\n  this.createDateObject = function(date, format) {\n    var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n    model = dateParser.fromTimezone(model, ngModelOptions.timezone);\n    var today = new Date();\n    today = dateParser.fromTimezone(today, ngModelOptions.timezone);\n    var time = this.compare(date, today);\n    var dt = {\n      date: date,\n      label: dateParser.filter(date, format),\n      selected: model && this.compare(date, model) === 0,\n      disabled: this.isDisabled(date),\n      past: time < 0,\n      current: time === 0,\n      future: time > 0,\n      customClass: this.customClass(date) || null\n    };\n\n    if (model && this.compare(date, model) === 0) {\n      $scope.selectedDt = dt;\n    }\n\n    if (self.activeDate && this.compare(dt.date, self.activeDate) === 0) {\n      $scope.activeDt = dt;\n    }\n\n    return dt;\n  };\n\n  this.isDisabled = function(date) {\n    return $scope.disabled ||\n      this.minDate && this.compare(date, this.minDate) < 0 ||\n      this.maxDate && this.compare(date, this.maxDate) > 0 ||\n      $scope.dateDisabled && $scope.dateDisabled({date: date, mode: $scope.datepickerMode});\n  };\n\n  this.customClass = function(date) {\n    return $scope.customClass({date: date, mode: $scope.datepickerMode});\n  };\n\n  // Split array into smaller arrays\n  this.split = function(arr, size) {\n    var arrays = [];\n    while (arr.length > 0) {\n      arrays.push(arr.splice(0, size));\n    }\n    return arrays;\n  };\n\n  $scope.select = function(date) {\n    if ($scope.datepickerMode === self.minMode) {\n      var dt = ngModelCtrl.$viewValue ? dateParser.fromTimezone(new Date(ngModelCtrl.$viewValue), ngModelOptions.timezone) : new Date(0, 0, 0, 0, 0, 0, 0);\n      dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());\n      dt = dateParser.toTimezone(dt, ngModelOptions.timezone);\n      ngModelCtrl.$setViewValue(dt);\n      ngModelCtrl.$render();\n    } else {\n      self.activeDate = date;\n      setMode(self.modes[self.modes.indexOf($scope.datepickerMode) - 1]);\n\n      $scope.$emit('uib:datepicker.mode');\n    }\n\n    $scope.$broadcast('uib:datepicker.focus');\n  };\n\n  $scope.move = function(direction) {\n    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),\n        month = self.activeDate.getMonth() + direction * (self.step.months || 0);\n    self.activeDate.setFullYear(year, month, 1);\n    self.refreshView();\n  };\n\n  $scope.toggleMode = function(direction) {\n    direction = direction || 1;\n\n    if ($scope.datepickerMode === self.maxMode && direction === 1 ||\n      $scope.datepickerMode === self.minMode && direction === -1) {\n      return;\n    }\n\n    setMode(self.modes[self.modes.indexOf($scope.datepickerMode) + direction]);\n\n    $scope.$emit('uib:datepicker.mode');\n  };\n\n  // Key event mapper\n  $scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };\n\n  var focusElement = function() {\n    self.element[0].focus();\n  };\n\n  // Listen for focus requests from popup directive\n  $scope.$on('uib:datepicker.focus', focusElement);\n\n  $scope.keydown = function(evt) {\n    var key = $scope.keys[evt.which];\n\n    if (!key || evt.shiftKey || evt.altKey || $scope.disabled) {\n      return;\n    }\n\n    evt.preventDefault();\n    if (!self.shortcutPropagation) {\n      evt.stopPropagation();\n    }\n\n    if (key === 'enter' || key === 'space') {\n      if (self.isDisabled(self.activeDate)) {\n        return; // do nothing\n      }\n      $scope.select(self.activeDate);\n    } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {\n      $scope.toggleMode(key === 'up' ? 1 : -1);\n    } else {\n      self.handleKeyDown(key, evt);\n      self.refreshView();\n    }\n  };\n\n  $scope.$on('$destroy', function() {\n    //Clear all watch listeners on destroy\n    while (watchListeners.length) {\n      watchListeners.shift()();\n    }\n  });\n\n  function setMode(mode) {\n    $scope.datepickerMode = mode;\n    $scope.datepickerOptions.datepickerMode = mode;\n  }\n}])\n\n.controller('UibDaypickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\n  var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n  this.step = { months: 1 };\n  this.element = $element;\n  function getDaysInMonth(year, month) {\n    return month === 1 && year % 4 === 0 &&\n      (year % 100 !== 0 || year % 400 === 0) ? 29 : DAYS_IN_MONTH[month];\n  }\n\n  this.init = function(ctrl) {\n    angular.extend(ctrl, this);\n    scope.showWeeks = ctrl.showWeeks;\n    ctrl.refreshView();\n  };\n\n  this.getDates = function(startDate, n) {\n    var dates = new Array(n), current = new Date(startDate), i = 0, date;\n    while (i < n) {\n      date = new Date(current);\n      dates[i++] = date;\n      current.setDate(current.getDate() + 1);\n    }\n    return dates;\n  };\n\n  this._refreshView = function() {\n    var year = this.activeDate.getFullYear(),\n      month = this.activeDate.getMonth(),\n      firstDayOfMonth = new Date(this.activeDate);\n\n    firstDayOfMonth.setFullYear(year, month, 1);\n\n    var difference = this.startingDay - firstDayOfMonth.getDay(),\n      numDisplayedFromPreviousMonth = difference > 0 ?\n        7 - difference : - difference,\n      firstDate = new Date(firstDayOfMonth);\n\n    if (numDisplayedFromPreviousMonth > 0) {\n      firstDate.setDate(-numDisplayedFromPreviousMonth + 1);\n    }\n\n    // 42 is the number of days on a six-week calendar\n    var days = this.getDates(firstDate, 42);\n    for (var i = 0; i < 42; i ++) {\n      days[i] = angular.extend(this.createDateObject(days[i], this.formatDay), {\n        secondary: days[i].getMonth() !== month,\n        uid: scope.uniqueId + '-' + i\n      });\n    }\n\n    scope.labels = new Array(7);\n    for (var j = 0; j < 7; j++) {\n      scope.labels[j] = {\n        abbr: dateFilter(days[j].date, this.formatDayHeader),\n        full: dateFilter(days[j].date, 'EEEE')\n      };\n    }\n\n    scope.title = dateFilter(this.activeDate, this.formatDayTitle);\n    scope.rows = this.split(days, 7);\n\n    if (scope.showWeeks) {\n      scope.weekNumbers = [];\n      var thursdayIndex = (4 + 7 - this.startingDay) % 7,\n          numWeeks = scope.rows.length;\n      for (var curWeek = 0; curWeek < numWeeks; curWeek++) {\n        scope.weekNumbers.push(\n          getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));\n      }\n    }\n  };\n\n  this.compare = function(date1, date2) {\n    var _date1 = new Date(date1.getFullYear(), date1.getMonth(), date1.getDate());\n    var _date2 = new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());\n    _date1.setFullYear(date1.getFullYear());\n    _date2.setFullYear(date2.getFullYear());\n    return _date1 - _date2;\n  };\n\n  function getISO8601WeekNumber(date) {\n    var checkDate = new Date(date);\n    checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday\n    var time = checkDate.getTime();\n    checkDate.setMonth(0); // Compare with Jan 1\n    checkDate.setDate(1);\n    return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;\n  }\n\n  this.handleKeyDown = function(key, evt) {\n    var date = this.activeDate.getDate();\n\n    if (key === 'left') {\n      date = date - 1;\n    } else if (key === 'up') {\n      date = date - 7;\n    } else if (key === 'right') {\n      date = date + 1;\n    } else if (key === 'down') {\n      date = date + 7;\n    } else if (key === 'pageup' || key === 'pagedown') {\n      var month = this.activeDate.getMonth() + (key === 'pageup' ? - 1 : 1);\n      this.activeDate.setMonth(month, 1);\n      date = Math.min(getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()), date);\n    } else if (key === 'home') {\n      date = 1;\n    } else if (key === 'end') {\n      date = getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth());\n    }\n    this.activeDate.setDate(date);\n  };\n}])\n\n.controller('UibMonthpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\n  this.step = { years: 1 };\n  this.element = $element;\n\n  this.init = function(ctrl) {\n    angular.extend(ctrl, this);\n    ctrl.refreshView();\n  };\n\n  this._refreshView = function() {\n    var months = new Array(12),\n        year = this.activeDate.getFullYear(),\n        date;\n\n    for (var i = 0; i < 12; i++) {\n      date = new Date(this.activeDate);\n      date.setFullYear(year, i, 1);\n      months[i] = angular.extend(this.createDateObject(date, this.formatMonth), {\n        uid: scope.uniqueId + '-' + i\n      });\n    }\n\n    scope.title = dateFilter(this.activeDate, this.formatMonthTitle);\n    scope.rows = this.split(months, 3);\n  };\n\n  this.compare = function(date1, date2) {\n    var _date1 = new Date(date1.getFullYear(), date1.getMonth());\n    var _date2 = new Date(date2.getFullYear(), date2.getMonth());\n    _date1.setFullYear(date1.getFullYear());\n    _date2.setFullYear(date2.getFullYear());\n    return _date1 - _date2;\n  };\n\n  this.handleKeyDown = function(key, evt) {\n    var date = this.activeDate.getMonth();\n\n    if (key === 'left') {\n      date = date - 1;\n    } else if (key === 'up') {\n      date = date - 3;\n    } else if (key === 'right') {\n      date = date + 1;\n    } else if (key === 'down') {\n      date = date + 3;\n    } else if (key === 'pageup' || key === 'pagedown') {\n      var year = this.activeDate.getFullYear() + (key === 'pageup' ? - 1 : 1);\n      this.activeDate.setFullYear(year);\n    } else if (key === 'home') {\n      date = 0;\n    } else if (key === 'end') {\n      date = 11;\n    }\n    this.activeDate.setMonth(date);\n  };\n}])\n\n.controller('UibYearpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\n  var columns, range;\n  this.element = $element;\n\n  function getStartingYear(year) {\n    return parseInt((year - 1) / range, 10) * range + 1;\n  }\n\n  this.yearpickerInit = function() {\n    columns = this.yearColumns;\n    range = this.yearRows * columns;\n    this.step = { years: range };\n  };\n\n  this._refreshView = function() {\n    var years = new Array(range), date;\n\n    for (var i = 0, start = getStartingYear(this.activeDate.getFullYear()); i < range; i++) {\n      date = new Date(this.activeDate);\n      date.setFullYear(start + i, 0, 1);\n      years[i] = angular.extend(this.createDateObject(date, this.formatYear), {\n        uid: scope.uniqueId + '-' + i\n      });\n    }\n\n    scope.title = [years[0].label, years[range - 1].label].join(' - ');\n    scope.rows = this.split(years, columns);\n    scope.columns = columns;\n  };\n\n  this.compare = function(date1, date2) {\n    return date1.getFullYear() - date2.getFullYear();\n  };\n\n  this.handleKeyDown = function(key, evt) {\n    var date = this.activeDate.getFullYear();\n\n    if (key === 'left') {\n      date = date - 1;\n    } else if (key === 'up') {\n      date = date - columns;\n    } else if (key === 'right') {\n      date = date + 1;\n    } else if (key === 'down') {\n      date = date + columns;\n    } else if (key === 'pageup' || key === 'pagedown') {\n      date += (key === 'pageup' ? - 1 : 1) * range;\n    } else if (key === 'home') {\n      date = getStartingYear(this.activeDate.getFullYear());\n    } else if (key === 'end') {\n      date = getStartingYear(this.activeDate.getFullYear()) + range - 1;\n    }\n    this.activeDate.setFullYear(date);\n  };\n}])\n\n.directive('uibDatepicker', function() {\n  return {\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/datepicker/datepicker.html';\n    },\n    scope: {\n      datepickerOptions: '=?'\n    },\n    require: ['uibDatepicker', '^ngModel'],\n    controller: 'UibDatepickerController',\n    controllerAs: 'datepicker',\n    link: function(scope, element, attrs, ctrls) {\n      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      datepickerCtrl.init(ngModelCtrl);\n    }\n  };\n})\n\n.directive('uibDaypicker', function() {\n  return {\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/datepicker/day.html';\n    },\n    require: ['^uibDatepicker', 'uibDaypicker'],\n    controller: 'UibDaypickerController',\n    link: function(scope, element, attrs, ctrls) {\n      var datepickerCtrl = ctrls[0],\n        daypickerCtrl = ctrls[1];\n\n      daypickerCtrl.init(datepickerCtrl);\n    }\n  };\n})\n\n.directive('uibMonthpicker', function() {\n  return {\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/datepicker/month.html';\n    },\n    require: ['^uibDatepicker', 'uibMonthpicker'],\n    controller: 'UibMonthpickerController',\n    link: function(scope, element, attrs, ctrls) {\n      var datepickerCtrl = ctrls[0],\n        monthpickerCtrl = ctrls[1];\n\n      monthpickerCtrl.init(datepickerCtrl);\n    }\n  };\n})\n\n.directive('uibYearpicker', function() {\n  return {\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/datepicker/year.html';\n    },\n    require: ['^uibDatepicker', 'uibYearpicker'],\n    controller: 'UibYearpickerController',\n    link: function(scope, element, attrs, ctrls) {\n      var ctrl = ctrls[0];\n      angular.extend(ctrl, ctrls[1]);\n      ctrl.yearpickerInit();\n\n      ctrl.refreshView();\n    }\n  };\n});\n\nangular.module('ui.bootstrap.position', [])\n\n/**\n * A set of utility methods for working with the DOM.\n * It is meant to be used where we need to absolute-position elements in\n * relation to another element (this is the case for tooltips, popovers,\n * typeahead suggestions etc.).\n */\n  .factory('$uibPosition', ['$document', '$window', function($document, $window) {\n    /**\n     * Used by scrollbarWidth() function to cache scrollbar's width.\n     * Do not access this variable directly, use scrollbarWidth() instead.\n     */\n    var SCROLLBAR_WIDTH;\n    /**\n     * scrollbar on body and html element in IE and Edge overlay\n     * content and should be considered 0 width.\n     */\n    var BODY_SCROLLBAR_WIDTH;\n    var OVERFLOW_REGEX = {\n      normal: /(auto|scroll)/,\n      hidden: /(auto|scroll|hidden)/\n    };\n    var PLACEMENT_REGEX = {\n      auto: /\\s?auto?\\s?/i,\n      primary: /^(top|bottom|left|right)$/,\n      secondary: /^(top|bottom|left|right|center)$/,\n      vertical: /^(top|bottom)$/\n    };\n    var BODY_REGEX = /(HTML|BODY)/;\n\n    return {\n\n      /**\n       * Provides a raw DOM element from a jQuery/jQLite element.\n       *\n       * @param {element} elem - The element to convert.\n       *\n       * @returns {element} A HTML element.\n       */\n      getRawNode: function(elem) {\n        return elem.nodeName ? elem : elem[0] || elem;\n      },\n\n      /**\n       * Provides a parsed number for a style property.  Strips\n       * units and casts invalid numbers to 0.\n       *\n       * @param {string} value - The style value to parse.\n       *\n       * @returns {number} A valid number.\n       */\n      parseStyle: function(value) {\n        value = parseFloat(value);\n        return isFinite(value) ? value : 0;\n      },\n\n      /**\n       * Provides the closest positioned ancestor.\n       *\n       * @param {element} element - The element to get the offest parent for.\n       *\n       * @returns {element} The closest positioned ancestor.\n       */\n      offsetParent: function(elem) {\n        elem = this.getRawNode(elem);\n\n        var offsetParent = elem.offsetParent || $document[0].documentElement;\n\n        function isStaticPositioned(el) {\n          return ($window.getComputedStyle(el).position || 'static') === 'static';\n        }\n\n        while (offsetParent && offsetParent !== $document[0].documentElement && isStaticPositioned(offsetParent)) {\n          offsetParent = offsetParent.offsetParent;\n        }\n\n        return offsetParent || $document[0].documentElement;\n      },\n\n      /**\n       * Provides the scrollbar width, concept from TWBS measureScrollbar()\n       * function in https://github.com/twbs/bootstrap/blob/master/js/modal.js\n       * In IE and Edge, scollbar on body and html element overlay and should\n       * return a width of 0.\n       *\n       * @returns {number} The width of the browser scollbar.\n       */\n      scrollbarWidth: function(isBody) {\n        if (isBody) {\n          if (angular.isUndefined(BODY_SCROLLBAR_WIDTH)) {\n            var bodyElem = $document.find('body');\n            bodyElem.addClass('uib-position-body-scrollbar-measure');\n            BODY_SCROLLBAR_WIDTH = $window.innerWidth - bodyElem[0].clientWidth;\n            BODY_SCROLLBAR_WIDTH = isFinite(BODY_SCROLLBAR_WIDTH) ? BODY_SCROLLBAR_WIDTH : 0;\n            bodyElem.removeClass('uib-position-body-scrollbar-measure');\n          }\n          return BODY_SCROLLBAR_WIDTH;\n        }\n\n        if (angular.isUndefined(SCROLLBAR_WIDTH)) {\n          var scrollElem = angular.element('<div class=\"uib-position-scrollbar-measure\"></div>');\n          $document.find('body').append(scrollElem);\n          SCROLLBAR_WIDTH = scrollElem[0].offsetWidth - scrollElem[0].clientWidth;\n          SCROLLBAR_WIDTH = isFinite(SCROLLBAR_WIDTH) ? SCROLLBAR_WIDTH : 0;\n          scrollElem.remove();\n        }\n\n        return SCROLLBAR_WIDTH;\n      },\n\n      /**\n       * Provides the padding required on an element to replace the scrollbar.\n       *\n       * @returns {object} An object with the following properties:\n       *   <ul>\n       *     <li>**scrollbarWidth**: the width of the scrollbar</li>\n       *     <li>**widthOverflow**: whether the the width is overflowing</li>\n       *     <li>**right**: the amount of right padding on the element needed to replace the scrollbar</li>\n       *     <li>**rightOriginal**: the amount of right padding currently on the element</li>\n       *     <li>**heightOverflow**: whether the the height is overflowing</li>\n       *     <li>**bottom**: the amount of bottom padding on the element needed to replace the scrollbar</li>\n       *     <li>**bottomOriginal**: the amount of bottom padding currently on the element</li>\n       *   </ul>\n       */\n      scrollbarPadding: function(elem) {\n        elem = this.getRawNode(elem);\n\n        var elemStyle = $window.getComputedStyle(elem);\n        var paddingRight = this.parseStyle(elemStyle.paddingRight);\n        var paddingBottom = this.parseStyle(elemStyle.paddingBottom);\n        var scrollParent = this.scrollParent(elem, false, true);\n        var scrollbarWidth = this.scrollbarWidth(scrollParent, BODY_REGEX.test(scrollParent.tagName));\n\n        return {\n          scrollbarWidth: scrollbarWidth,\n          widthOverflow: scrollParent.scrollWidth > scrollParent.clientWidth,\n          right: paddingRight + scrollbarWidth,\n          originalRight: paddingRight,\n          heightOverflow: scrollParent.scrollHeight > scrollParent.clientHeight,\n          bottom: paddingBottom + scrollbarWidth,\n          originalBottom: paddingBottom\n         };\n      },\n\n      /**\n       * Checks to see if the element is scrollable.\n       *\n       * @param {element} elem - The element to check.\n       * @param {boolean=} [includeHidden=false] - Should scroll style of 'hidden' be considered,\n       *   default is false.\n       *\n       * @returns {boolean} Whether the element is scrollable.\n       */\n      isScrollable: function(elem, includeHidden) {\n        elem = this.getRawNode(elem);\n\n        var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;\n        var elemStyle = $window.getComputedStyle(elem);\n        return overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX);\n      },\n\n      /**\n       * Provides the closest scrollable ancestor.\n       * A port of the jQuery UI scrollParent method:\n       * https://github.com/jquery/jquery-ui/blob/master/ui/scroll-parent.js\n       *\n       * @param {element} elem - The element to find the scroll parent of.\n       * @param {boolean=} [includeHidden=false] - Should scroll style of 'hidden' be considered,\n       *   default is false.\n       * @param {boolean=} [includeSelf=false] - Should the element being passed be\n       * included in the scrollable llokup.\n       *\n       * @returns {element} A HTML element.\n       */\n      scrollParent: function(elem, includeHidden, includeSelf) {\n        elem = this.getRawNode(elem);\n\n        var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;\n        var documentEl = $document[0].documentElement;\n        var elemStyle = $window.getComputedStyle(elem);\n        if (includeSelf && overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX)) {\n          return elem;\n        }\n        var excludeStatic = elemStyle.position === 'absolute';\n        var scrollParent = elem.parentElement || documentEl;\n\n        if (scrollParent === documentEl || elemStyle.position === 'fixed') {\n          return documentEl;\n        }\n\n        while (scrollParent.parentElement && scrollParent !== documentEl) {\n          var spStyle = $window.getComputedStyle(scrollParent);\n          if (excludeStatic && spStyle.position !== 'static') {\n            excludeStatic = false;\n          }\n\n          if (!excludeStatic && overflowRegex.test(spStyle.overflow + spStyle.overflowY + spStyle.overflowX)) {\n            break;\n          }\n          scrollParent = scrollParent.parentElement;\n        }\n\n        return scrollParent;\n      },\n\n      /**\n       * Provides read-only equivalent of jQuery's position function:\n       * http://api.jquery.com/position/ - distance to closest positioned\n       * ancestor.  Does not account for margins by default like jQuery position.\n       *\n       * @param {element} elem - The element to caclulate the position on.\n       * @param {boolean=} [includeMargins=false] - Should margins be accounted\n       * for, default is false.\n       *\n       * @returns {object} An object with the following properties:\n       *   <ul>\n       *     <li>**width**: the width of the element</li>\n       *     <li>**height**: the height of the element</li>\n       *     <li>**top**: distance to top edge of offset parent</li>\n       *     <li>**left**: distance to left edge of offset parent</li>\n       *   </ul>\n       */\n      position: function(elem, includeMagins) {\n        elem = this.getRawNode(elem);\n\n        var elemOffset = this.offset(elem);\n        if (includeMagins) {\n          var elemStyle = $window.getComputedStyle(elem);\n          elemOffset.top -= this.parseStyle(elemStyle.marginTop);\n          elemOffset.left -= this.parseStyle(elemStyle.marginLeft);\n        }\n        var parent = this.offsetParent(elem);\n        var parentOffset = {top: 0, left: 0};\n\n        if (parent !== $document[0].documentElement) {\n          parentOffset = this.offset(parent);\n          parentOffset.top += parent.clientTop - parent.scrollTop;\n          parentOffset.left += parent.clientLeft - parent.scrollLeft;\n        }\n\n        return {\n          width: Math.round(angular.isNumber(elemOffset.width) ? elemOffset.width : elem.offsetWidth),\n          height: Math.round(angular.isNumber(elemOffset.height) ? elemOffset.height : elem.offsetHeight),\n          top: Math.round(elemOffset.top - parentOffset.top),\n          left: Math.round(elemOffset.left - parentOffset.left)\n        };\n      },\n\n      /**\n       * Provides read-only equivalent of jQuery's offset function:\n       * http://api.jquery.com/offset/ - distance to viewport.  Does\n       * not account for borders, margins, or padding on the body\n       * element.\n       *\n       * @param {element} elem - The element to calculate the offset on.\n       *\n       * @returns {object} An object with the following properties:\n       *   <ul>\n       *     <li>**width**: the width of the element</li>\n       *     <li>**height**: the height of the element</li>\n       *     <li>**top**: distance to top edge of viewport</li>\n       *     <li>**right**: distance to bottom edge of viewport</li>\n       *   </ul>\n       */\n      offset: function(elem) {\n        elem = this.getRawNode(elem);\n\n        var elemBCR = elem.getBoundingClientRect();\n        return {\n          width: Math.round(angular.isNumber(elemBCR.width) ? elemBCR.width : elem.offsetWidth),\n          height: Math.round(angular.isNumber(elemBCR.height) ? elemBCR.height : elem.offsetHeight),\n          top: Math.round(elemBCR.top + ($window.pageYOffset || $document[0].documentElement.scrollTop)),\n          left: Math.round(elemBCR.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft))\n        };\n      },\n\n      /**\n       * Provides offset distance to the closest scrollable ancestor\n       * or viewport.  Accounts for border and scrollbar width.\n       *\n       * Right and bottom dimensions represent the distance to the\n       * respective edge of the viewport element.  If the element\n       * edge extends beyond the viewport, a negative value will be\n       * reported.\n       *\n       * @param {element} elem - The element to get the viewport offset for.\n       * @param {boolean=} [useDocument=false] - Should the viewport be the document element instead\n       * of the first scrollable element, default is false.\n       * @param {boolean=} [includePadding=true] - Should the padding on the offset parent element\n       * be accounted for, default is true.\n       *\n       * @returns {object} An object with the following properties:\n       *   <ul>\n       *     <li>**top**: distance to the top content edge of viewport element</li>\n       *     <li>**bottom**: distance to the bottom content edge of viewport element</li>\n       *     <li>**left**: distance to the left content edge of viewport element</li>\n       *     <li>**right**: distance to the right content edge of viewport element</li>\n       *   </ul>\n       */\n      viewportOffset: function(elem, useDocument, includePadding) {\n        elem = this.getRawNode(elem);\n        includePadding = includePadding !== false ? true : false;\n\n        var elemBCR = elem.getBoundingClientRect();\n        var offsetBCR = {top: 0, left: 0, bottom: 0, right: 0};\n\n        var offsetParent = useDocument ? $document[0].documentElement : this.scrollParent(elem);\n        var offsetParentBCR = offsetParent.getBoundingClientRect();\n\n        offsetBCR.top = offsetParentBCR.top + offsetParent.clientTop;\n        offsetBCR.left = offsetParentBCR.left + offsetParent.clientLeft;\n        if (offsetParent === $document[0].documentElement) {\n          offsetBCR.top += $window.pageYOffset;\n          offsetBCR.left += $window.pageXOffset;\n        }\n        offsetBCR.bottom = offsetBCR.top + offsetParent.clientHeight;\n        offsetBCR.right = offsetBCR.left + offsetParent.clientWidth;\n\n        if (includePadding) {\n          var offsetParentStyle = $window.getComputedStyle(offsetParent);\n          offsetBCR.top += this.parseStyle(offsetParentStyle.paddingTop);\n          offsetBCR.bottom -= this.parseStyle(offsetParentStyle.paddingBottom);\n          offsetBCR.left += this.parseStyle(offsetParentStyle.paddingLeft);\n          offsetBCR.right -= this.parseStyle(offsetParentStyle.paddingRight);\n        }\n\n        return {\n          top: Math.round(elemBCR.top - offsetBCR.top),\n          bottom: Math.round(offsetBCR.bottom - elemBCR.bottom),\n          left: Math.round(elemBCR.left - offsetBCR.left),\n          right: Math.round(offsetBCR.right - elemBCR.right)\n        };\n      },\n\n      /**\n       * Provides an array of placement values parsed from a placement string.\n       * Along with the 'auto' indicator, supported placement strings are:\n       *   <ul>\n       *     <li>top: element on top, horizontally centered on host element.</li>\n       *     <li>top-left: element on top, left edge aligned with host element left edge.</li>\n       *     <li>top-right: element on top, lerightft edge aligned with host element right edge.</li>\n       *     <li>bottom: element on bottom, horizontally centered on host element.</li>\n       *     <li>bottom-left: element on bottom, left edge aligned with host element left edge.</li>\n       *     <li>bottom-right: element on bottom, right edge aligned with host element right edge.</li>\n       *     <li>left: element on left, vertically centered on host element.</li>\n       *     <li>left-top: element on left, top edge aligned with host element top edge.</li>\n       *     <li>left-bottom: element on left, bottom edge aligned with host element bottom edge.</li>\n       *     <li>right: element on right, vertically centered on host element.</li>\n       *     <li>right-top: element on right, top edge aligned with host element top edge.</li>\n       *     <li>right-bottom: element on right, bottom edge aligned with host element bottom edge.</li>\n       *   </ul>\n       * A placement string with an 'auto' indicator is expected to be\n       * space separated from the placement, i.e: 'auto bottom-left'  If\n       * the primary and secondary placement values do not match 'top,\n       * bottom, left, right' then 'top' will be the primary placement and\n       * 'center' will be the secondary placement.  If 'auto' is passed, true\n       * will be returned as the 3rd value of the array.\n       *\n       * @param {string} placement - The placement string to parse.\n       *\n       * @returns {array} An array with the following values\n       * <ul>\n       *   <li>**[0]**: The primary placement.</li>\n       *   <li>**[1]**: The secondary placement.</li>\n       *   <li>**[2]**: If auto is passed: true, else undefined.</li>\n       * </ul>\n       */\n      parsePlacement: function(placement) {\n        var autoPlace = PLACEMENT_REGEX.auto.test(placement);\n        if (autoPlace) {\n          placement = placement.replace(PLACEMENT_REGEX.auto, '');\n        }\n\n        placement = placement.split('-');\n\n        placement[0] = placement[0] || 'top';\n        if (!PLACEMENT_REGEX.primary.test(placement[0])) {\n          placement[0] = 'top';\n        }\n\n        placement[1] = placement[1] || 'center';\n        if (!PLACEMENT_REGEX.secondary.test(placement[1])) {\n          placement[1] = 'center';\n        }\n\n        if (autoPlace) {\n          placement[2] = true;\n        } else {\n          placement[2] = false;\n        }\n\n        return placement;\n      },\n\n      /**\n       * Provides coordinates for an element to be positioned relative to\n       * another element.  Passing 'auto' as part of the placement parameter\n       * will enable smart placement - where the element fits. i.e:\n       * 'auto left-top' will check to see if there is enough space to the left\n       * of the hostElem to fit the targetElem, if not place right (same for secondary\n       * top placement).  Available space is calculated using the viewportOffset\n       * function.\n       *\n       * @param {element} hostElem - The element to position against.\n       * @param {element} targetElem - The element to position.\n       * @param {string=} [placement=top] - The placement for the targetElem,\n       *   default is 'top'. 'center' is assumed as secondary placement for\n       *   'top', 'left', 'right', and 'bottom' placements.  Available placements are:\n       *   <ul>\n       *     <li>top</li>\n       *     <li>top-right</li>\n       *     <li>top-left</li>\n       *     <li>bottom</li>\n       *     <li>bottom-left</li>\n       *     <li>bottom-right</li>\n       *     <li>left</li>\n       *     <li>left-top</li>\n       *     <li>left-bottom</li>\n       *     <li>right</li>\n       *     <li>right-top</li>\n       *     <li>right-bottom</li>\n       *   </ul>\n       * @param {boolean=} [appendToBody=false] - Should the top and left values returned\n       *   be calculated from the body element, default is false.\n       *\n       * @returns {object} An object with the following properties:\n       *   <ul>\n       *     <li>**top**: Value for targetElem top.</li>\n       *     <li>**left**: Value for targetElem left.</li>\n       *     <li>**placement**: The resolved placement.</li>\n       *   </ul>\n       */\n      positionElements: function(hostElem, targetElem, placement, appendToBody) {\n        hostElem = this.getRawNode(hostElem);\n        targetElem = this.getRawNode(targetElem);\n\n        // need to read from prop to support tests.\n        var targetWidth = angular.isDefined(targetElem.offsetWidth) ? targetElem.offsetWidth : targetElem.prop('offsetWidth');\n        var targetHeight = angular.isDefined(targetElem.offsetHeight) ? targetElem.offsetHeight : targetElem.prop('offsetHeight');\n\n        placement = this.parsePlacement(placement);\n\n        var hostElemPos = appendToBody ? this.offset(hostElem) : this.position(hostElem);\n        var targetElemPos = {top: 0, left: 0, placement: ''};\n\n        if (placement[2]) {\n          var viewportOffset = this.viewportOffset(hostElem, appendToBody);\n\n          var targetElemStyle = $window.getComputedStyle(targetElem);\n          var adjustedSize = {\n            width: targetWidth + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginLeft) + this.parseStyle(targetElemStyle.marginRight))),\n            height: targetHeight + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginTop) + this.parseStyle(targetElemStyle.marginBottom)))\n          };\n\n          placement[0] = placement[0] === 'top' && adjustedSize.height > viewportOffset.top && adjustedSize.height <= viewportOffset.bottom ? 'bottom' :\n                         placement[0] === 'bottom' && adjustedSize.height > viewportOffset.bottom && adjustedSize.height <= viewportOffset.top ? 'top' :\n                         placement[0] === 'left' && adjustedSize.width > viewportOffset.left && adjustedSize.width <= viewportOffset.right ? 'right' :\n                         placement[0] === 'right' && adjustedSize.width > viewportOffset.right && adjustedSize.width <= viewportOffset.left ? 'left' :\n                         placement[0];\n\n          placement[1] = placement[1] === 'top' && adjustedSize.height - hostElemPos.height > viewportOffset.bottom && adjustedSize.height - hostElemPos.height <= viewportOffset.top ? 'bottom' :\n                         placement[1] === 'bottom' && adjustedSize.height - hostElemPos.height > viewportOffset.top && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom ? 'top' :\n                         placement[1] === 'left' && adjustedSize.width - hostElemPos.width > viewportOffset.right && adjustedSize.width - hostElemPos.width <= viewportOffset.left ? 'right' :\n                         placement[1] === 'right' && adjustedSize.width - hostElemPos.width > viewportOffset.left && adjustedSize.width - hostElemPos.width <= viewportOffset.right ? 'left' :\n                         placement[1];\n\n          if (placement[1] === 'center') {\n            if (PLACEMENT_REGEX.vertical.test(placement[0])) {\n              var xOverflow = hostElemPos.width / 2 - targetWidth / 2;\n              if (viewportOffset.left + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.right) {\n                placement[1] = 'left';\n              } else if (viewportOffset.right + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.left) {\n                placement[1] = 'right';\n              }\n            } else {\n              var yOverflow = hostElemPos.height / 2 - adjustedSize.height / 2;\n              if (viewportOffset.top + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom) {\n                placement[1] = 'top';\n              } else if (viewportOffset.bottom + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.top) {\n                placement[1] = 'bottom';\n              }\n            }\n          }\n        }\n\n        switch (placement[0]) {\n          case 'top':\n            targetElemPos.top = hostElemPos.top - targetHeight;\n            break;\n          case 'bottom':\n            targetElemPos.top = hostElemPos.top + hostElemPos.height;\n            break;\n          case 'left':\n            targetElemPos.left = hostElemPos.left - targetWidth;\n            break;\n          case 'right':\n            targetElemPos.left = hostElemPos.left + hostElemPos.width;\n            break;\n        }\n\n        switch (placement[1]) {\n          case 'top':\n            targetElemPos.top = hostElemPos.top;\n            break;\n          case 'bottom':\n            targetElemPos.top = hostElemPos.top + hostElemPos.height - targetHeight;\n            break;\n          case 'left':\n            targetElemPos.left = hostElemPos.left;\n            break;\n          case 'right':\n            targetElemPos.left = hostElemPos.left + hostElemPos.width - targetWidth;\n            break;\n          case 'center':\n            if (PLACEMENT_REGEX.vertical.test(placement[0])) {\n              targetElemPos.left = hostElemPos.left + hostElemPos.width / 2 - targetWidth / 2;\n            } else {\n              targetElemPos.top = hostElemPos.top + hostElemPos.height / 2 - targetHeight / 2;\n            }\n            break;\n        }\n\n        targetElemPos.top = Math.round(targetElemPos.top);\n        targetElemPos.left = Math.round(targetElemPos.left);\n        targetElemPos.placement = placement[1] === 'center' ? placement[0] : placement[0] + '-' + placement[1];\n\n        return targetElemPos;\n      },\n\n      /**\n      * Provides a way for positioning tooltip & dropdown\n      * arrows when using placement options beyond the standard\n      * left, right, top, or bottom.\n      *\n      * @param {element} elem - The tooltip/dropdown element.\n      * @param {string} placement - The placement for the elem.\n      */\n      positionArrow: function(elem, placement) {\n        elem = this.getRawNode(elem);\n\n        var innerElem = elem.querySelector('.tooltip-inner, .popover-inner');\n        if (!innerElem) {\n          return;\n        }\n\n        var isTooltip = angular.element(innerElem).hasClass('tooltip-inner');\n\n        var arrowElem = isTooltip ? elem.querySelector('.tooltip-arrow') : elem.querySelector('.arrow');\n        if (!arrowElem) {\n          return;\n        }\n\n        var arrowCss = {\n          top: '',\n          bottom: '',\n          left: '',\n          right: ''\n        };\n\n        placement = this.parsePlacement(placement);\n        if (placement[1] === 'center') {\n          // no adjustment necessary - just reset styles\n          angular.element(arrowElem).css(arrowCss);\n          return;\n        }\n\n        var borderProp = 'border-' + placement[0] + '-width';\n        var borderWidth = $window.getComputedStyle(arrowElem)[borderProp];\n\n        var borderRadiusProp = 'border-';\n        if (PLACEMENT_REGEX.vertical.test(placement[0])) {\n          borderRadiusProp += placement[0] + '-' + placement[1];\n        } else {\n          borderRadiusProp += placement[1] + '-' + placement[0];\n        }\n        borderRadiusProp += '-radius';\n        var borderRadius = $window.getComputedStyle(isTooltip ? innerElem : elem)[borderRadiusProp];\n\n        switch (placement[0]) {\n          case 'top':\n            arrowCss.bottom = isTooltip ? '0' : '-' + borderWidth;\n            break;\n          case 'bottom':\n            arrowCss.top = isTooltip ? '0' : '-' + borderWidth;\n            break;\n          case 'left':\n            arrowCss.right = isTooltip ? '0' : '-' + borderWidth;\n            break;\n          case 'right':\n            arrowCss.left = isTooltip ? '0' : '-' + borderWidth;\n            break;\n        }\n\n        arrowCss[placement[1]] = borderRadius;\n\n        angular.element(arrowElem).css(arrowCss);\n      }\n    };\n  }]);\n\nangular.module('ui.bootstrap.datepickerPopup', ['ui.bootstrap.datepicker', 'ui.bootstrap.position'])\n\n.value('$datepickerPopupLiteralWarning', true)\n\n.constant('uibDatepickerPopupConfig', {\n  altInputFormats: [],\n  appendToBody: false,\n  clearText: 'Clear',\n  closeOnDateSelection: true,\n  closeText: 'Done',\n  currentText: 'Today',\n  datepickerPopup: 'yyyy-MM-dd',\n  datepickerPopupTemplateUrl: 'uib/template/datepickerPopup/popup.html',\n  datepickerTemplateUrl: 'uib/template/datepicker/datepicker.html',\n  html5Types: {\n    date: 'yyyy-MM-dd',\n    'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss',\n    'month': 'yyyy-MM'\n  },\n  onOpenFocus: true,\n  showButtonBar: true,\n  placement: 'auto bottom-left'\n})\n\n.controller('UibDatepickerPopupController', ['$scope', '$element', '$attrs', '$compile', '$log', '$parse', '$window', '$document', '$rootScope', '$uibPosition', 'dateFilter', 'uibDateParser', 'uibDatepickerPopupConfig', '$timeout', 'uibDatepickerConfig', '$datepickerPopupLiteralWarning',\nfunction($scope, $element, $attrs, $compile, $log, $parse, $window, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout, datepickerConfig, $datepickerPopupLiteralWarning) {\n  var cache = {},\n    isHtml5DateInput = false;\n  var dateFormat, closeOnDateSelection, appendToBody, onOpenFocus,\n    datepickerPopupTemplateUrl, datepickerTemplateUrl, popupEl, datepickerEl, scrollParentEl,\n    ngModel, ngModelOptions, $popup, altInputFormats, watchListeners = [],\n    timezone;\n\n  this.init = function(_ngModel_) {\n    ngModel = _ngModel_;\n    ngModelOptions = _ngModel_.$options;\n    closeOnDateSelection = angular.isDefined($attrs.closeOnDateSelection) ?\n      $scope.$parent.$eval($attrs.closeOnDateSelection) :\n      datepickerPopupConfig.closeOnDateSelection;\n    appendToBody = angular.isDefined($attrs.datepickerAppendToBody) ?\n      $scope.$parent.$eval($attrs.datepickerAppendToBody) :\n      datepickerPopupConfig.appendToBody;\n    onOpenFocus = angular.isDefined($attrs.onOpenFocus) ?\n      $scope.$parent.$eval($attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus;\n    datepickerPopupTemplateUrl = angular.isDefined($attrs.datepickerPopupTemplateUrl) ?\n      $attrs.datepickerPopupTemplateUrl :\n      datepickerPopupConfig.datepickerPopupTemplateUrl;\n    datepickerTemplateUrl = angular.isDefined($attrs.datepickerTemplateUrl) ?\n      $attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl;\n    altInputFormats = angular.isDefined($attrs.altInputFormats) ?\n      $scope.$parent.$eval($attrs.altInputFormats) :\n      datepickerPopupConfig.altInputFormats;\n\n    $scope.showButtonBar = angular.isDefined($attrs.showButtonBar) ?\n      $scope.$parent.$eval($attrs.showButtonBar) :\n      datepickerPopupConfig.showButtonBar;\n\n    if (datepickerPopupConfig.html5Types[$attrs.type]) {\n      dateFormat = datepickerPopupConfig.html5Types[$attrs.type];\n      isHtml5DateInput = true;\n    } else {\n      dateFormat = $attrs.uibDatepickerPopup || datepickerPopupConfig.datepickerPopup;\n      $attrs.$observe('uibDatepickerPopup', function(value, oldValue) {\n        var newDateFormat = value || datepickerPopupConfig.datepickerPopup;\n        // Invalidate the $modelValue to ensure that formatters re-run\n        // FIXME: Refactor when PR is merged: https://github.com/angular/angular.js/pull/10764\n        if (newDateFormat !== dateFormat) {\n          dateFormat = newDateFormat;\n          ngModel.$modelValue = null;\n\n          if (!dateFormat) {\n            throw new Error('uibDatepickerPopup must have a date format specified.');\n          }\n        }\n      });\n    }\n\n    if (!dateFormat) {\n      throw new Error('uibDatepickerPopup must have a date format specified.');\n    }\n\n    if (isHtml5DateInput && $attrs.uibDatepickerPopup) {\n      throw new Error('HTML5 date input types do not support custom formats.');\n    }\n\n    // popup element used to display calendar\n    popupEl = angular.element('<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>');\n    if (ngModelOptions) {\n      timezone = ngModelOptions.timezone;\n      $scope.ngModelOptions = angular.copy(ngModelOptions);\n      $scope.ngModelOptions.timezone = null;\n      if ($scope.ngModelOptions.updateOnDefault === true) {\n        $scope.ngModelOptions.updateOn = $scope.ngModelOptions.updateOn ?\n          $scope.ngModelOptions.updateOn + ' default' : 'default';\n      }\n\n      popupEl.attr('ng-model-options', 'ngModelOptions');\n    } else {\n      timezone = null;\n    }\n\n    popupEl.attr({\n      'ng-model': 'date',\n      'ng-change': 'dateSelection(date)',\n      'template-url': datepickerPopupTemplateUrl\n    });\n\n    // datepicker element\n    datepickerEl = angular.element(popupEl.children()[0]);\n    datepickerEl.attr('template-url', datepickerTemplateUrl);\n\n    if (!$scope.datepickerOptions) {\n      $scope.datepickerOptions = {};\n    }\n\n    if (isHtml5DateInput) {\n      if ($attrs.type === 'month') {\n        $scope.datepickerOptions.datepickerMode = 'month';\n        $scope.datepickerOptions.minMode = 'month';\n      }\n    }\n\n    datepickerEl.attr('datepicker-options', 'datepickerOptions');\n\n    if (!isHtml5DateInput) {\n      // Internal API to maintain the correct ng-invalid-[key] class\n      ngModel.$$parserName = 'date';\n      ngModel.$validators.date = validator;\n      ngModel.$parsers.unshift(parseDate);\n      ngModel.$formatters.push(function(value) {\n        if (ngModel.$isEmpty(value)) {\n          $scope.date = value;\n          return value;\n        }\n\n        if (angular.isNumber(value)) {\n          value = new Date(value);\n        }\n\n        $scope.date = dateParser.fromTimezone(value, timezone);\n\n        return dateParser.filter($scope.date, dateFormat);\n      });\n    } else {\n      ngModel.$formatters.push(function(value) {\n        $scope.date = dateParser.fromTimezone(value, timezone);\n        return value;\n      });\n    }\n\n    // Detect changes in the view from the text box\n    ngModel.$viewChangeListeners.push(function() {\n      $scope.date = parseDateString(ngModel.$viewValue);\n    });\n\n    $element.on('keydown', inputKeydownBind);\n\n    $popup = $compile(popupEl)($scope);\n    // Prevent jQuery cache memory leak (template is now redundant after linking)\n    popupEl.remove();\n\n    if (appendToBody) {\n      $document.find('body').append($popup);\n    } else {\n      $element.after($popup);\n    }\n\n    $scope.$on('$destroy', function() {\n      if ($scope.isOpen === true) {\n        if (!$rootScope.$$phase) {\n          $scope.$apply(function() {\n            $scope.isOpen = false;\n          });\n        }\n      }\n\n      $popup.remove();\n      $element.off('keydown', inputKeydownBind);\n      $document.off('click', documentClickBind);\n      if (scrollParentEl) {\n        scrollParentEl.off('scroll', positionPopup);\n      }\n      angular.element($window).off('resize', positionPopup);\n\n      //Clear all watch listeners on destroy\n      while (watchListeners.length) {\n        watchListeners.shift()();\n      }\n    });\n  };\n\n  $scope.getText = function(key) {\n    return $scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];\n  };\n\n  $scope.isDisabled = function(date) {\n    if (date === 'today') {\n      date = dateParser.fromTimezone(new Date(), timezone);\n    }\n\n    var dates = {};\n    angular.forEach(['minDate', 'maxDate'], function(key) {\n      if (!$scope.datepickerOptions[key]) {\n        dates[key] = null;\n      } else if (angular.isDate($scope.datepickerOptions[key])) {\n        dates[key] = dateParser.fromTimezone(new Date($scope.datepickerOptions[key]), timezone);\n      } else {\n        if ($datepickerPopupLiteralWarning) {\n          $log.warn('Literal date support has been deprecated, please switch to date object usage');\n        }\n\n        dates[key] = new Date(dateFilter($scope.datepickerOptions[key], 'medium'));\n      }\n    });\n\n    return $scope.datepickerOptions &&\n      dates.minDate && $scope.compare(date, dates.minDate) < 0 ||\n      dates.maxDate && $scope.compare(date, dates.maxDate) > 0;\n  };\n\n  $scope.compare = function(date1, date2) {\n    return new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());\n  };\n\n  // Inner change\n  $scope.dateSelection = function(dt) {\n    if (angular.isDefined(dt)) {\n      $scope.date = dt;\n    }\n    var date = $scope.date ? dateParser.filter($scope.date, dateFormat) : null; // Setting to NULL is necessary for form validators to function\n    $element.val(date);\n    ngModel.$setViewValue(date);\n\n    if (closeOnDateSelection) {\n      $scope.isOpen = false;\n      $element[0].focus();\n    }\n  };\n\n  $scope.keydown = function(evt) {\n    if (evt.which === 27) {\n      evt.stopPropagation();\n      $scope.isOpen = false;\n      $element[0].focus();\n    }\n  };\n\n  $scope.select = function(date, evt) {\n    evt.stopPropagation();\n\n    if (date === 'today') {\n      var today = new Date();\n      if (angular.isDate($scope.date)) {\n        date = new Date($scope.date);\n        date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());\n      } else {\n        date = new Date(today.setHours(0, 0, 0, 0));\n      }\n    }\n    $scope.dateSelection(date);\n  };\n\n  $scope.close = function(evt) {\n    evt.stopPropagation();\n\n    $scope.isOpen = false;\n    $element[0].focus();\n  };\n\n  $scope.disabled = angular.isDefined($attrs.disabled) || false;\n  if ($attrs.ngDisabled) {\n    watchListeners.push($scope.$parent.$watch($parse($attrs.ngDisabled), function(disabled) {\n      $scope.disabled = disabled;\n    }));\n  }\n\n  $scope.$watch('isOpen', function(value) {\n    if (value) {\n      if (!$scope.disabled) {\n        $timeout(function() {\n          positionPopup();\n\n          if (onOpenFocus) {\n            $scope.$broadcast('uib:datepicker.focus');\n          }\n\n          $document.on('click', documentClickBind);\n\n          var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;\n          if (appendToBody || $position.parsePlacement(placement)[2]) {\n            scrollParentEl = scrollParentEl || angular.element($position.scrollParent($element));\n            if (scrollParentEl) {\n              scrollParentEl.on('scroll', positionPopup);\n            }\n          } else {\n            scrollParentEl = null;\n          }\n\n          angular.element($window).on('resize', positionPopup);\n        }, 0, false);\n      } else {\n        $scope.isOpen = false;\n      }\n    } else {\n      $document.off('click', documentClickBind);\n      if (scrollParentEl) {\n        scrollParentEl.off('scroll', positionPopup);\n      }\n      angular.element($window).off('resize', positionPopup);\n    }\n  });\n\n  function cameltoDash(string) {\n    return string.replace(/([A-Z])/g, function($1) { return '-' + $1.toLowerCase(); });\n  }\n\n  function parseDateString(viewValue) {\n    var date = dateParser.parse(viewValue, dateFormat, $scope.date);\n    if (isNaN(date)) {\n      for (var i = 0; i < altInputFormats.length; i++) {\n        date = dateParser.parse(viewValue, altInputFormats[i], $scope.date);\n        if (!isNaN(date)) {\n          return date;\n        }\n      }\n    }\n    return date;\n  }\n\n  function parseDate(viewValue) {\n    if (angular.isNumber(viewValue)) {\n      // presumably timestamp to date object\n      viewValue = new Date(viewValue);\n    }\n\n    if (!viewValue) {\n      return null;\n    }\n\n    if (angular.isDate(viewValue) && !isNaN(viewValue)) {\n      return viewValue;\n    }\n\n    if (angular.isString(viewValue)) {\n      var date = parseDateString(viewValue);\n      if (!isNaN(date)) {\n        return dateParser.toTimezone(date, timezone);\n      }\n    }\n\n    return ngModel.$options && ngModel.$options.allowInvalid ? viewValue : undefined;\n  }\n\n  function validator(modelValue, viewValue) {\n    var value = modelValue || viewValue;\n\n    if (!$attrs.ngRequired && !value) {\n      return true;\n    }\n\n    if (angular.isNumber(value)) {\n      value = new Date(value);\n    }\n\n    if (!value) {\n      return true;\n    }\n\n    if (angular.isDate(value) && !isNaN(value)) {\n      return true;\n    }\n\n    if (angular.isString(value)) {\n      return !isNaN(parseDateString(viewValue));\n    }\n\n    return false;\n  }\n\n  function documentClickBind(event) {\n    if (!$scope.isOpen && $scope.disabled) {\n      return;\n    }\n\n    var popup = $popup[0];\n    var dpContainsTarget = $element[0].contains(event.target);\n    // The popup node may not be an element node\n    // In some browsers (IE) only element nodes have the 'contains' function\n    var popupContainsTarget = popup.contains !== undefined && popup.contains(event.target);\n    if ($scope.isOpen && !(dpContainsTarget || popupContainsTarget)) {\n      $scope.$apply(function() {\n        $scope.isOpen = false;\n      });\n    }\n  }\n\n  function inputKeydownBind(evt) {\n    if (evt.which === 27 && $scope.isOpen) {\n      evt.preventDefault();\n      evt.stopPropagation();\n      $scope.$apply(function() {\n        $scope.isOpen = false;\n      });\n      $element[0].focus();\n    } else if (evt.which === 40 && !$scope.isOpen) {\n      evt.preventDefault();\n      evt.stopPropagation();\n      $scope.$apply(function() {\n        $scope.isOpen = true;\n      });\n    }\n  }\n\n  function positionPopup() {\n    if ($scope.isOpen) {\n      var dpElement = angular.element($popup[0].querySelector('.uib-datepicker-popup'));\n      var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;\n      var position = $position.positionElements($element, dpElement, placement, appendToBody);\n      dpElement.css({top: position.top + 'px', left: position.left + 'px'});\n      if (dpElement.hasClass('uib-position-measure')) {\n        dpElement.removeClass('uib-position-measure');\n      }\n    }\n  }\n\n  $scope.$on('uib:datepicker.mode', function() {\n    $timeout(positionPopup, 0, false);\n  });\n}])\n\n.directive('uibDatepickerPopup', function() {\n  return {\n    require: ['ngModel', 'uibDatepickerPopup'],\n    controller: 'UibDatepickerPopupController',\n    scope: {\n      datepickerOptions: '=?',\n      isOpen: '=?',\n      currentText: '@',\n      clearText: '@',\n      closeText: '@'\n    },\n    link: function(scope, element, attrs, ctrls) {\n      var ngModel = ctrls[0],\n        ctrl = ctrls[1];\n\n      ctrl.init(ngModel);\n    }\n  };\n})\n\n.directive('uibDatepickerPopupWrap', function() {\n  return {\n    replace: true,\n    transclude: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/datepickerPopup/popup.html';\n    }\n  };\n});\n\nangular.module('ui.bootstrap.debounce', [])\n/**\n * A helper, internal service that debounces a function\n */\n  .factory('$$debounce', ['$timeout', function($timeout) {\n    return function(callback, debounceTime) {\n      var timeoutPromise;\n\n      return function() {\n        var self = this;\n        var args = Array.prototype.slice.call(arguments);\n        if (timeoutPromise) {\n          $timeout.cancel(timeoutPromise);\n        }\n\n        timeoutPromise = $timeout(function() {\n          callback.apply(self, args);\n        }, debounceTime);\n      };\n    };\n  }]);\n\nangular.module('ui.bootstrap.dropdown', ['ui.bootstrap.position'])\n\n.constant('uibDropdownConfig', {\n  appendToOpenClass: 'uib-dropdown-open',\n  openClass: 'open'\n})\n\n.service('uibDropdownService', ['$document', '$rootScope', function($document, $rootScope) {\n  var openScope = null;\n\n  this.open = function(dropdownScope, element) {\n    if (!openScope) {\n      $document.on('click', closeDropdown);\n      element.on('keydown', keybindFilter);\n    }\n\n    if (openScope && openScope !== dropdownScope) {\n      openScope.isOpen = false;\n    }\n\n    openScope = dropdownScope;\n  };\n\n  this.close = function(dropdownScope, element) {\n    if (openScope === dropdownScope) {\n      openScope = null;\n      $document.off('click', closeDropdown);\n      element.off('keydown', keybindFilter);\n    }\n  };\n\n  var closeDropdown = function(evt) {\n    // This method may still be called during the same mouse event that\n    // unbound this event handler. So check openScope before proceeding.\n    if (!openScope) { return; }\n\n    if (evt && openScope.getAutoClose() === 'disabled') { return; }\n\n    if (evt && evt.which === 3) { return; }\n\n    var toggleElement = openScope.getToggleElement();\n    if (evt && toggleElement && toggleElement[0].contains(evt.target)) {\n      return;\n    }\n\n    var dropdownElement = openScope.getDropdownElement();\n    if (evt && openScope.getAutoClose() === 'outsideClick' &&\n      dropdownElement && dropdownElement[0].contains(evt.target)) {\n      return;\n    }\n\n    openScope.isOpen = false;\n\n    if (!$rootScope.$$phase) {\n      openScope.$apply();\n    }\n  };\n\n  var keybindFilter = function(evt) {\n    if (evt.which === 27) {\n      evt.stopPropagation();\n      openScope.focusToggleElement();\n      closeDropdown();\n    } else if (openScope.isKeynavEnabled() && [38, 40].indexOf(evt.which) !== -1 && openScope.isOpen) {\n      evt.preventDefault();\n      evt.stopPropagation();\n      openScope.focusDropdownEntry(evt.which);\n    }\n  };\n}])\n\n.controller('UibDropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest) {\n  var self = this,\n    scope = $scope.$new(), // create a child scope so we are not polluting original one\n    templateScope,\n    appendToOpenClass = dropdownConfig.appendToOpenClass,\n    openClass = dropdownConfig.openClass,\n    getIsOpen,\n    setIsOpen = angular.noop,\n    toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,\n    appendToBody = false,\n    appendTo = null,\n    keynavEnabled = false,\n    selectedOption = null,\n    body = $document.find('body');\n\n  $element.addClass('dropdown');\n\n  this.init = function() {\n    if ($attrs.isOpen) {\n      getIsOpen = $parse($attrs.isOpen);\n      setIsOpen = getIsOpen.assign;\n\n      $scope.$watch(getIsOpen, function(value) {\n        scope.isOpen = !!value;\n      });\n    }\n\n    if (angular.isDefined($attrs.dropdownAppendTo)) {\n      var appendToEl = $parse($attrs.dropdownAppendTo)(scope);\n      if (appendToEl) {\n        appendTo = angular.element(appendToEl);\n      }\n    }\n\n    appendToBody = angular.isDefined($attrs.dropdownAppendToBody);\n    keynavEnabled = angular.isDefined($attrs.keyboardNav);\n\n    if (appendToBody && !appendTo) {\n      appendTo = body;\n    }\n\n    if (appendTo && self.dropdownMenu) {\n      appendTo.append(self.dropdownMenu);\n      $element.on('$destroy', function handleDestroyEvent() {\n        self.dropdownMenu.remove();\n      });\n    }\n  };\n\n  this.toggle = function(open) {\n    scope.isOpen = arguments.length ? !!open : !scope.isOpen;\n    if (angular.isFunction(setIsOpen)) {\n      setIsOpen(scope, scope.isOpen);\n    }\n\n    return scope.isOpen;\n  };\n\n  // Allow other directives to watch status\n  this.isOpen = function() {\n    return scope.isOpen;\n  };\n\n  scope.getToggleElement = function() {\n    return self.toggleElement;\n  };\n\n  scope.getAutoClose = function() {\n    return $attrs.autoClose || 'always'; //or 'outsideClick' or 'disabled'\n  };\n\n  scope.getElement = function() {\n    return $element;\n  };\n\n  scope.isKeynavEnabled = function() {\n    return keynavEnabled;\n  };\n\n  scope.focusDropdownEntry = function(keyCode) {\n    var elems = self.dropdownMenu ? //If append to body is used.\n      angular.element(self.dropdownMenu).find('a') :\n      $element.find('ul').eq(0).find('a');\n\n    switch (keyCode) {\n      case 40: {\n        if (!angular.isNumber(self.selectedOption)) {\n          self.selectedOption = 0;\n        } else {\n          self.selectedOption = self.selectedOption === elems.length - 1 ?\n            self.selectedOption :\n            self.selectedOption + 1;\n        }\n        break;\n      }\n      case 38: {\n        if (!angular.isNumber(self.selectedOption)) {\n          self.selectedOption = elems.length - 1;\n        } else {\n          self.selectedOption = self.selectedOption === 0 ?\n            0 : self.selectedOption - 1;\n        }\n        break;\n      }\n    }\n    elems[self.selectedOption].focus();\n  };\n\n  scope.getDropdownElement = function() {\n    return self.dropdownMenu;\n  };\n\n  scope.focusToggleElement = function() {\n    if (self.toggleElement) {\n      self.toggleElement[0].focus();\n    }\n  };\n\n  scope.$watch('isOpen', function(isOpen, wasOpen) {\n    if (appendTo && self.dropdownMenu) {\n      var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true),\n        css,\n        rightalign,\n        scrollbarWidth;\n\n      css = {\n        top: pos.top + 'px',\n        display: isOpen ? 'block' : 'none'\n      };\n\n      rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');\n      if (!rightalign) {\n        css.left = pos.left + 'px';\n        css.right = 'auto';\n      } else {\n        css.left = 'auto';\n        scrollbarWidth = $position.scrollbarWidth(true);\n        css.right = window.innerWidth - scrollbarWidth -\n          (pos.left + $element.prop('offsetWidth')) + 'px';\n      }\n\n      // Need to adjust our positioning to be relative to the appendTo container\n      // if it's not the body element\n      if (!appendToBody) {\n        var appendOffset = $position.offset(appendTo);\n\n        css.top = pos.top - appendOffset.top + 'px';\n\n        if (!rightalign) {\n          css.left = pos.left - appendOffset.left + 'px';\n        } else {\n          css.right = window.innerWidth -\n            (pos.left - appendOffset.left + $element.prop('offsetWidth')) + 'px';\n        }\n      }\n\n      self.dropdownMenu.css(css);\n    }\n\n    var openContainer = appendTo ? appendTo : $element;\n    var hasOpenClass = openContainer.hasClass(appendTo ? appendToOpenClass : openClass);\n\n    if (hasOpenClass === !isOpen) {\n      $animate[isOpen ? 'addClass' : 'removeClass'](openContainer, appendTo ? appendToOpenClass : openClass).then(function() {\n        if (angular.isDefined(isOpen) && isOpen !== wasOpen) {\n          toggleInvoker($scope, { open: !!isOpen });\n        }\n      });\n    }\n\n    if (isOpen) {\n      if (self.dropdownMenuTemplateUrl) {\n        $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {\n          templateScope = scope.$new();\n          $compile(tplContent.trim())(templateScope, function(dropdownElement) {\n            var newEl = dropdownElement;\n            self.dropdownMenu.replaceWith(newEl);\n            self.dropdownMenu = newEl;\n          });\n        });\n      }\n\n      scope.focusToggleElement();\n      uibDropdownService.open(scope, $element);\n    } else {\n      if (self.dropdownMenuTemplateUrl) {\n        if (templateScope) {\n          templateScope.$destroy();\n        }\n        var newEl = angular.element('<ul class=\"dropdown-menu\"></ul>');\n        self.dropdownMenu.replaceWith(newEl);\n        self.dropdownMenu = newEl;\n      }\n\n      uibDropdownService.close(scope, $element);\n      self.selectedOption = null;\n    }\n\n    if (angular.isFunction(setIsOpen)) {\n      setIsOpen($scope, isOpen);\n    }\n  });\n}])\n\n.directive('uibDropdown', function() {\n  return {\n    controller: 'UibDropdownController',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      dropdownCtrl.init();\n    }\n  };\n})\n\n.directive('uibDropdownMenu', function() {\n  return {\n    restrict: 'A',\n    require: '?^uibDropdown',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {\n        return;\n      }\n\n      element.addClass('dropdown-menu');\n\n      var tplUrl = attrs.templateUrl;\n      if (tplUrl) {\n        dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;\n      }\n\n      if (!dropdownCtrl.dropdownMenu) {\n        dropdownCtrl.dropdownMenu = element;\n      }\n    }\n  };\n})\n\n.directive('uibDropdownToggle', function() {\n  return {\n    require: '?^uibDropdown',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      if (!dropdownCtrl) {\n        return;\n      }\n\n      element.addClass('dropdown-toggle');\n\n      dropdownCtrl.toggleElement = element;\n\n      var toggleDropdown = function(event) {\n        event.preventDefault();\n\n        if (!element.hasClass('disabled') && !attrs.disabled) {\n          scope.$apply(function() {\n            dropdownCtrl.toggle();\n          });\n        }\n      };\n\n      element.bind('click', toggleDropdown);\n\n      // WAI-ARIA\n      element.attr({ 'aria-haspopup': true, 'aria-expanded': false });\n      scope.$watch(dropdownCtrl.isOpen, function(isOpen) {\n        element.attr('aria-expanded', !!isOpen);\n      });\n\n      scope.$on('$destroy', function() {\n        element.unbind('click', toggleDropdown);\n      });\n    }\n  };\n});\n\nangular.module('ui.bootstrap.stackedMap', [])\n/**\n * A helper, internal data structure that acts as a map but also allows getting / removing\n * elements in the LIFO order\n */\n  .factory('$$stackedMap', function() {\n    return {\n      createNew: function() {\n        var stack = [];\n\n        return {\n          add: function(key, value) {\n            stack.push({\n              key: key,\n              value: value\n            });\n          },\n          get: function(key) {\n            for (var i = 0; i < stack.length; i++) {\n              if (key === stack[i].key) {\n                return stack[i];\n              }\n            }\n          },\n          keys: function() {\n            var keys = [];\n            for (var i = 0; i < stack.length; i++) {\n              keys.push(stack[i].key);\n            }\n            return keys;\n          },\n          top: function() {\n            return stack[stack.length - 1];\n          },\n          remove: function(key) {\n            var idx = -1;\n            for (var i = 0; i < stack.length; i++) {\n              if (key === stack[i].key) {\n                idx = i;\n                break;\n              }\n            }\n            return stack.splice(idx, 1)[0];\n          },\n          removeTop: function() {\n            return stack.splice(stack.length - 1, 1)[0];\n          },\n          length: function() {\n            return stack.length;\n          }\n        };\n      }\n    };\n  });\nangular.module('ui.bootstrap.modal', ['ui.bootstrap.stackedMap', 'ui.bootstrap.position'])\n/**\n * A helper, internal data structure that stores all references attached to key\n */\n  .factory('$$multiMap', function() {\n    return {\n      createNew: function() {\n        var map = {};\n\n        return {\n          entries: function() {\n            return Object.keys(map).map(function(key) {\n              return {\n                key: key,\n                value: map[key]\n              };\n            });\n          },\n          get: function(key) {\n            return map[key];\n          },\n          hasKey: function(key) {\n            return !!map[key];\n          },\n          keys: function() {\n            return Object.keys(map);\n          },\n          put: function(key, value) {\n            if (!map[key]) {\n              map[key] = [];\n            }\n\n            map[key].push(value);\n          },\n          remove: function(key, value) {\n            var values = map[key];\n\n            if (!values) {\n              return;\n            }\n\n            var idx = values.indexOf(value);\n\n            if (idx !== -1) {\n              values.splice(idx, 1);\n            }\n\n            if (!values.length) {\n              delete map[key];\n            }\n          }\n        };\n      }\n    };\n  })\n\n/**\n * Pluggable resolve mechanism for the modal resolve resolution\n * Supports UI Router's $resolve service\n */\n  .provider('$uibResolve', function() {\n    var resolve = this;\n    this.resolver = null;\n\n    this.setResolver = function(resolver) {\n      this.resolver = resolver;\n    };\n\n    this.$get = ['$injector', '$q', function($injector, $q) {\n      var resolver = resolve.resolver ? $injector.get(resolve.resolver) : null;\n      return {\n        resolve: function(invocables, locals, parent, self) {\n          if (resolver) {\n            return resolver.resolve(invocables, locals, parent, self);\n          }\n\n          var promises = [];\n\n          angular.forEach(invocables, function(value) {\n            if (angular.isFunction(value) || angular.isArray(value)) {\n              promises.push($q.resolve($injector.invoke(value)));\n            } else if (angular.isString(value)) {\n              promises.push($q.resolve($injector.get(value)));\n            } else {\n              promises.push($q.resolve(value));\n            }\n          });\n\n          return $q.all(promises).then(function(resolves) {\n            var resolveObj = {};\n            var resolveIter = 0;\n            angular.forEach(invocables, function(value, key) {\n              resolveObj[key] = resolves[resolveIter++];\n            });\n\n            return resolveObj;\n          });\n        }\n      };\n    }];\n  })\n\n/**\n * A helper directive for the $modal service. It creates a backdrop element.\n */\n  .directive('uibModalBackdrop', ['$animate', '$injector', '$uibModalStack',\n  function($animate, $injector, $modalStack) {\n    return {\n      replace: true,\n      templateUrl: 'uib/template/modal/backdrop.html',\n      compile: function(tElement, tAttrs) {\n        tElement.addClass(tAttrs.backdropClass);\n        return linkFn;\n      }\n    };\n\n    function linkFn(scope, element, attrs) {\n      if (attrs.modalInClass) {\n        $animate.addClass(element, attrs.modalInClass);\n\n        scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n          var done = setIsAsync();\n          if (scope.modalOptions.animation) {\n            $animate.removeClass(element, attrs.modalInClass).then(done);\n          } else {\n            done();\n          }\n        });\n      }\n    }\n  }])\n\n  .directive('uibModalWindow', ['$uibModalStack', '$q', '$animateCss', '$document',\n  function($modalStack, $q, $animateCss, $document) {\n    return {\n      scope: {\n        index: '@'\n      },\n      replace: true,\n      transclude: true,\n      templateUrl: function(tElement, tAttrs) {\n        return tAttrs.templateUrl || 'uib/template/modal/window.html';\n      },\n      link: function(scope, element, attrs) {\n        element.addClass(attrs.windowClass || '');\n        element.addClass(attrs.windowTopClass || '');\n        scope.size = attrs.size;\n\n        scope.close = function(evt) {\n          var modal = $modalStack.getTop();\n          if (modal && modal.value.backdrop &&\n            modal.value.backdrop !== 'static' &&\n            evt.target === evt.currentTarget) {\n            evt.preventDefault();\n            evt.stopPropagation();\n            $modalStack.dismiss(modal.key, 'backdrop click');\n          }\n        };\n\n        // moved from template to fix issue #2280\n        element.on('click', scope.close);\n\n        // This property is only added to the scope for the purpose of detecting when this directive is rendered.\n        // We can detect that by using this property in the template associated with this directive and then use\n        // {@link Attribute#$observe} on it. For more details please see {@link TableColumnResize}.\n        scope.$isRendered = true;\n\n        // Deferred object that will be resolved when this modal is render.\n        var modalRenderDeferObj = $q.defer();\n        // Observe function will be called on next digest cycle after compilation, ensuring that the DOM is ready.\n        // In order to use this way of finding whether DOM is ready, we need to observe a scope property used in modal's template.\n        attrs.$observe('modalRender', function(value) {\n          if (value === 'true') {\n            modalRenderDeferObj.resolve();\n          }\n        });\n\n        modalRenderDeferObj.promise.then(function() {\n          var animationPromise = null;\n\n          if (attrs.modalInClass) {\n            animationPromise = $animateCss(element, {\n              addClass: attrs.modalInClass\n            }).start();\n\n            scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n              var done = setIsAsync();\n              $animateCss(element, {\n                removeClass: attrs.modalInClass\n              }).start().then(done);\n            });\n          }\n\n\n          $q.when(animationPromise).then(function() {\n            // Notify {@link $modalStack} that modal is rendered.\n            var modal = $modalStack.getTop();\n            if (modal) {\n              $modalStack.modalRendered(modal.key);\n            }\n\n            /**\n             * If something within the freshly-opened modal already has focus (perhaps via a\n             * directive that causes focus). then no need to try and focus anything.\n             */\n            if (!($document[0].activeElement && element[0].contains($document[0].activeElement))) {\n              var inputWithAutofocus = element[0].querySelector('[autofocus]');\n              /**\n               * Auto-focusing of a freshly-opened modal element causes any child elements\n               * with the autofocus attribute to lose focus. This is an issue on touch\n               * based devices which will show and then hide the onscreen keyboard.\n               * Attempts to refocus the autofocus element via JavaScript will not reopen\n               * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus\n               * the modal element if the modal does not contain an autofocus element.\n               */\n              if (inputWithAutofocus) {\n                inputWithAutofocus.focus();\n              } else {\n                element[0].focus();\n              }\n            }\n          });\n        });\n      }\n    };\n  }])\n\n  .directive('uibModalAnimationClass', function() {\n    return {\n      compile: function(tElement, tAttrs) {\n        if (tAttrs.modalAnimation) {\n          tElement.addClass(tAttrs.uibModalAnimationClass);\n        }\n      }\n    };\n  })\n\n  .directive('uibModalTransclude', function() {\n    return {\n      link: function(scope, element, attrs, controller, transclude) {\n        transclude(scope.$parent, function(clone) {\n          element.empty();\n          element.append(clone);\n        });\n      }\n    };\n  })\n\n  .factory('$uibModalStack', ['$animate', '$animateCss', '$document',\n    '$compile', '$rootScope', '$q', '$$multiMap', '$$stackedMap', '$uibPosition',\n    function($animate, $animateCss, $document, $compile, $rootScope, $q, $$multiMap, $$stackedMap, $uibPosition) {\n      var OPENED_MODAL_CLASS = 'modal-open';\n\n      var backdropDomEl, backdropScope;\n      var openedWindows = $$stackedMap.createNew();\n      var openedClasses = $$multiMap.createNew();\n      var $modalStack = {\n        NOW_CLOSING_EVENT: 'modal.stack.now-closing'\n      };\n      var topModalIndex = 0;\n      var previousTopOpenedModal = null;\n\n      //Modal focus behavior\n      var tabableSelector = 'a[href], area[href], input:not([disabled]), ' +\n        'button:not([disabled]),select:not([disabled]), textarea:not([disabled]), ' +\n        'iframe, object, embed, *[tabindex], *[contenteditable=true]';\n      var scrollbarPadding;\n\n      function isVisible(element) {\n        return !!(element.offsetWidth ||\n          element.offsetHeight ||\n          element.getClientRects().length);\n      }\n\n      function backdropIndex() {\n        var topBackdropIndex = -1;\n        var opened = openedWindows.keys();\n        for (var i = 0; i < opened.length; i++) {\n          if (openedWindows.get(opened[i]).value.backdrop) {\n            topBackdropIndex = i;\n          }\n        }\n\n        // If any backdrop exist, ensure that it's index is always\n        // right below the top modal\n        if (topBackdropIndex > -1 && topBackdropIndex < topModalIndex) {\n          topBackdropIndex = topModalIndex;\n        }\n        return topBackdropIndex;\n      }\n\n      $rootScope.$watch(backdropIndex, function(newBackdropIndex) {\n        if (backdropScope) {\n          backdropScope.index = newBackdropIndex;\n        }\n      });\n\n      function removeModalWindow(modalInstance, elementToReceiveFocus) {\n        var modalWindow = openedWindows.get(modalInstance).value;\n        var appendToElement = modalWindow.appendTo;\n\n        //clean up the stack\n        openedWindows.remove(modalInstance);\n        previousTopOpenedModal = openedWindows.top();\n        if (previousTopOpenedModal) {\n          topModalIndex = parseInt(previousTopOpenedModal.value.modalDomEl.attr('index'), 10);\n        }\n\n        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function() {\n          var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;\n          openedClasses.remove(modalBodyClass, modalInstance);\n          var areAnyOpen = openedClasses.hasKey(modalBodyClass);\n          appendToElement.toggleClass(modalBodyClass, areAnyOpen);\n          if (!areAnyOpen && scrollbarPadding && scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {\n            if (scrollbarPadding.originalRight) {\n              appendToElement.css({paddingRight: scrollbarPadding.originalRight + 'px'});\n            } else {\n              appendToElement.css({paddingRight: ''});\n            }\n            scrollbarPadding = null;\n          }\n          toggleTopWindowClass(true);\n        }, modalWindow.closedDeferred);\n        checkRemoveBackdrop();\n\n        //move focus to specified element if available, or else to body\n        if (elementToReceiveFocus && elementToReceiveFocus.focus) {\n          elementToReceiveFocus.focus();\n        } else if (appendToElement.focus) {\n          appendToElement.focus();\n        }\n      }\n\n      // Add or remove \"windowTopClass\" from the top window in the stack\n      function toggleTopWindowClass(toggleSwitch) {\n        var modalWindow;\n\n        if (openedWindows.length() > 0) {\n          modalWindow = openedWindows.top().value;\n          modalWindow.modalDomEl.toggleClass(modalWindow.windowTopClass || '', toggleSwitch);\n        }\n      }\n\n      function checkRemoveBackdrop() {\n        //remove backdrop if no longer needed\n        if (backdropDomEl && backdropIndex() === -1) {\n          var backdropScopeRef = backdropScope;\n          removeAfterAnimate(backdropDomEl, backdropScope, function() {\n            backdropScopeRef = null;\n          });\n          backdropDomEl = undefined;\n          backdropScope = undefined;\n        }\n      }\n\n      function removeAfterAnimate(domEl, scope, done, closedDeferred) {\n        var asyncDeferred;\n        var asyncPromise = null;\n        var setIsAsync = function() {\n          if (!asyncDeferred) {\n            asyncDeferred = $q.defer();\n            asyncPromise = asyncDeferred.promise;\n          }\n\n          return function asyncDone() {\n            asyncDeferred.resolve();\n          };\n        };\n        scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);\n\n        // Note that it's intentional that asyncPromise might be null.\n        // That's when setIsAsync has not been called during the\n        // NOW_CLOSING_EVENT broadcast.\n        return $q.when(asyncPromise).then(afterAnimating);\n\n        function afterAnimating() {\n          if (afterAnimating.done) {\n            return;\n          }\n          afterAnimating.done = true;\n\n          $animate.leave(domEl).then(function() {\n            domEl.remove();\n            if (closedDeferred) {\n              closedDeferred.resolve();\n            }\n          });\n\n          scope.$destroy();\n          if (done) {\n            done();\n          }\n        }\n      }\n\n      $document.on('keydown', keydownListener);\n\n      $rootScope.$on('$destroy', function() {\n        $document.off('keydown', keydownListener);\n      });\n\n      function keydownListener(evt) {\n        if (evt.isDefaultPrevented()) {\n          return evt;\n        }\n\n        var modal = openedWindows.top();\n        if (modal) {\n          switch (evt.which) {\n            case 27: {\n              if (modal.value.keyboard) {\n                evt.preventDefault();\n                $rootScope.$apply(function() {\n                  $modalStack.dismiss(modal.key, 'escape key press');\n                });\n              }\n              break;\n            }\n            case 9: {\n              var list = $modalStack.loadFocusElementList(modal);\n              var focusChanged = false;\n              if (evt.shiftKey) {\n                if ($modalStack.isFocusInFirstItem(evt, list) || $modalStack.isModalFocused(evt, modal)) {\n                  focusChanged = $modalStack.focusLastFocusableElement(list);\n                }\n              } else {\n                if ($modalStack.isFocusInLastItem(evt, list)) {\n                  focusChanged = $modalStack.focusFirstFocusableElement(list);\n                }\n              }\n\n              if (focusChanged) {\n                evt.preventDefault();\n                evt.stopPropagation();\n              }\n\n              break;\n            }\n          }\n        }\n      }\n\n      $modalStack.open = function(modalInstance, modal) {\n        var modalOpener = $document[0].activeElement,\n          modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;\n\n        toggleTopWindowClass(false);\n\n        // Store the current top first, to determine what index we ought to use\n        // for the current top modal\n        previousTopOpenedModal = openedWindows.top();\n\n        openedWindows.add(modalInstance, {\n          deferred: modal.deferred,\n          renderDeferred: modal.renderDeferred,\n          closedDeferred: modal.closedDeferred,\n          modalScope: modal.scope,\n          backdrop: modal.backdrop,\n          keyboard: modal.keyboard,\n          openedClass: modal.openedClass,\n          windowTopClass: modal.windowTopClass,\n          animation: modal.animation,\n          appendTo: modal.appendTo\n        });\n\n        openedClasses.put(modalBodyClass, modalInstance);\n\n        var appendToElement = modal.appendTo,\n            currBackdropIndex = backdropIndex();\n\n        if (!appendToElement.length) {\n          throw new Error('appendTo element not found. Make sure that the element passed is in DOM.');\n        }\n\n        if (currBackdropIndex >= 0 && !backdropDomEl) {\n          backdropScope = $rootScope.$new(true);\n          backdropScope.modalOptions = modal;\n          backdropScope.index = currBackdropIndex;\n          backdropDomEl = angular.element('<div uib-modal-backdrop=\"modal-backdrop\"></div>');\n          backdropDomEl.attr('backdrop-class', modal.backdropClass);\n          if (modal.animation) {\n            backdropDomEl.attr('modal-animation', 'true');\n          }\n          $compile(backdropDomEl)(backdropScope);\n          $animate.enter(backdropDomEl, appendToElement);\n          scrollbarPadding = $uibPosition.scrollbarPadding(appendToElement);\n          if (scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {\n            appendToElement.css({paddingRight: scrollbarPadding.right + 'px'});\n          }\n        }\n\n        // Set the top modal index based on the index of the previous top modal\n        topModalIndex = previousTopOpenedModal ? parseInt(previousTopOpenedModal.value.modalDomEl.attr('index'), 10) + 1 : 0;\n        var angularDomEl = angular.element('<div uib-modal-window=\"modal-window\"></div>');\n        angularDomEl.attr({\n          'template-url': modal.windowTemplateUrl,\n          'window-class': modal.windowClass,\n          'window-top-class': modal.windowTopClass,\n          'size': modal.size,\n          'index': topModalIndex,\n          'animate': 'animate'\n        }).html(modal.content);\n        if (modal.animation) {\n          angularDomEl.attr('modal-animation', 'true');\n        }\n\n        appendToElement.addClass(modalBodyClass);\n        $animate.enter($compile(angularDomEl)(modal.scope), appendToElement);\n\n        openedWindows.top().value.modalDomEl = angularDomEl;\n        openedWindows.top().value.modalOpener = modalOpener;\n      };\n\n      function broadcastClosing(modalWindow, resultOrReason, closing) {\n        return !modalWindow.value.modalScope.$broadcast('modal.closing', resultOrReason, closing).defaultPrevented;\n      }\n\n      $modalStack.close = function(modalInstance, result) {\n        var modalWindow = openedWindows.get(modalInstance);\n        if (modalWindow && broadcastClosing(modalWindow, result, true)) {\n          modalWindow.value.modalScope.$$uibDestructionScheduled = true;\n          modalWindow.value.deferred.resolve(result);\n          removeModalWindow(modalInstance, modalWindow.value.modalOpener);\n          return true;\n        }\n        return !modalWindow;\n      };\n\n      $modalStack.dismiss = function(modalInstance, reason) {\n        var modalWindow = openedWindows.get(modalInstance);\n        if (modalWindow && broadcastClosing(modalWindow, reason, false)) {\n          modalWindow.value.modalScope.$$uibDestructionScheduled = true;\n          modalWindow.value.deferred.reject(reason);\n          removeModalWindow(modalInstance, modalWindow.value.modalOpener);\n          return true;\n        }\n        return !modalWindow;\n      };\n\n      $modalStack.dismissAll = function(reason) {\n        var topModal = this.getTop();\n        while (topModal && this.dismiss(topModal.key, reason)) {\n          topModal = this.getTop();\n        }\n      };\n\n      $modalStack.getTop = function() {\n        return openedWindows.top();\n      };\n\n      $modalStack.modalRendered = function(modalInstance) {\n        var modalWindow = openedWindows.get(modalInstance);\n        if (modalWindow) {\n          modalWindow.value.renderDeferred.resolve();\n        }\n      };\n\n      $modalStack.focusFirstFocusableElement = function(list) {\n        if (list.length > 0) {\n          list[0].focus();\n          return true;\n        }\n        return false;\n      };\n\n      $modalStack.focusLastFocusableElement = function(list) {\n        if (list.length > 0) {\n          list[list.length - 1].focus();\n          return true;\n        }\n        return false;\n      };\n\n      $modalStack.isModalFocused = function(evt, modalWindow) {\n        if (evt && modalWindow) {\n          var modalDomEl = modalWindow.value.modalDomEl;\n          if (modalDomEl && modalDomEl.length) {\n            return (evt.target || evt.srcElement) === modalDomEl[0];\n          }\n        }\n        return false;\n      };\n\n      $modalStack.isFocusInFirstItem = function(evt, list) {\n        if (list.length > 0) {\n          return (evt.target || evt.srcElement) === list[0];\n        }\n        return false;\n      };\n\n      $modalStack.isFocusInLastItem = function(evt, list) {\n        if (list.length > 0) {\n          return (evt.target || evt.srcElement) === list[list.length - 1];\n        }\n        return false;\n      };\n\n      $modalStack.loadFocusElementList = function(modalWindow) {\n        if (modalWindow) {\n          var modalDomE1 = modalWindow.value.modalDomEl;\n          if (modalDomE1 && modalDomE1.length) {\n            var elements = modalDomE1[0].querySelectorAll(tabableSelector);\n            return elements ?\n              Array.prototype.filter.call(elements, function(element) {\n                return isVisible(element);\n              }) : elements;\n          }\n        }\n      };\n\n      return $modalStack;\n    }])\n\n  .provider('$uibModal', function() {\n    var $modalProvider = {\n      options: {\n        animation: true,\n        backdrop: true, //can also be false or 'static'\n        keyboard: true\n      },\n      $get: ['$rootScope', '$q', '$document', '$templateRequest', '$controller', '$uibResolve', '$uibModalStack',\n        function ($rootScope, $q, $document, $templateRequest, $controller, $uibResolve, $modalStack) {\n          var $modal = {};\n\n          function getTemplatePromise(options) {\n            return options.template ? $q.when(options.template) :\n              $templateRequest(angular.isFunction(options.templateUrl) ?\n                options.templateUrl() : options.templateUrl);\n          }\n\n          var promiseChain = null;\n          $modal.getPromiseChain = function() {\n            return promiseChain;\n          };\n\n          $modal.open = function(modalOptions) {\n            var modalResultDeferred = $q.defer();\n            var modalOpenedDeferred = $q.defer();\n            var modalClosedDeferred = $q.defer();\n            var modalRenderDeferred = $q.defer();\n\n            //prepare an instance of a modal to be injected into controllers and returned to a caller\n            var modalInstance = {\n              result: modalResultDeferred.promise,\n              opened: modalOpenedDeferred.promise,\n              closed: modalClosedDeferred.promise,\n              rendered: modalRenderDeferred.promise,\n              close: function (result) {\n                return $modalStack.close(modalInstance, result);\n              },\n              dismiss: function (reason) {\n                return $modalStack.dismiss(modalInstance, reason);\n              }\n            };\n\n            //merge and clean up options\n            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);\n            modalOptions.resolve = modalOptions.resolve || {};\n            modalOptions.appendTo = modalOptions.appendTo || $document.find('body').eq(0);\n\n            //verify options\n            if (!modalOptions.template && !modalOptions.templateUrl) {\n              throw new Error('One of template or templateUrl options is required.');\n            }\n\n            var templateAndResolvePromise =\n              $q.all([getTemplatePromise(modalOptions), $uibResolve.resolve(modalOptions.resolve, {}, null, null)]);\n\n            function resolveWithTemplate() {\n              return templateAndResolvePromise;\n            }\n\n            // Wait for the resolution of the existing promise chain.\n            // Then switch to our own combined promise dependency (regardless of how the previous modal fared).\n            // Then add to $modalStack and resolve opened.\n            // Finally clean up the chain variable if no subsequent modal has overwritten it.\n            var samePromise;\n            samePromise = promiseChain = $q.all([promiseChain])\n              .then(resolveWithTemplate, resolveWithTemplate)\n              .then(function resolveSuccess(tplAndVars) {\n                var providedScope = modalOptions.scope || $rootScope;\n\n                var modalScope = providedScope.$new();\n                modalScope.$close = modalInstance.close;\n                modalScope.$dismiss = modalInstance.dismiss;\n\n                modalScope.$on('$destroy', function() {\n                  if (!modalScope.$$uibDestructionScheduled) {\n                    modalScope.$dismiss('$uibUnscheduledDestruction');\n                  }\n                });\n\n                var ctrlInstance, ctrlInstantiate, ctrlLocals = {};\n\n                //controllers\n                if (modalOptions.controller) {\n                  ctrlLocals.$scope = modalScope;\n                  ctrlLocals.$scope.$resolve = {};\n                  ctrlLocals.$uibModalInstance = modalInstance;\n                  angular.forEach(tplAndVars[1], function(value, key) {\n                    ctrlLocals[key] = value;\n                    ctrlLocals.$scope.$resolve[key] = value;\n                  });\n\n                  // the third param will make the controller instantiate later,private api\n                  // @see https://github.com/angular/angular.js/blob/master/src/ng/controller.js#L126\n                  ctrlInstantiate = $controller(modalOptions.controller, ctrlLocals, true, modalOptions.controllerAs);\n                  if (modalOptions.controllerAs && modalOptions.bindToController) {\n                    ctrlInstance = ctrlInstantiate.instance;\n                    ctrlInstance.$close = modalScope.$close;\n                    ctrlInstance.$dismiss = modalScope.$dismiss;\n                    angular.extend(ctrlInstance, {\n                      $resolve: ctrlLocals.$scope.$resolve\n                    }, providedScope);\n                  }\n\n                  ctrlInstance = ctrlInstantiate();\n\n                  if (angular.isFunction(ctrlInstance.$onInit)) {\n                    ctrlInstance.$onInit();\n                  }\n                }\n\n                $modalStack.open(modalInstance, {\n                  scope: modalScope,\n                  deferred: modalResultDeferred,\n                  renderDeferred: modalRenderDeferred,\n                  closedDeferred: modalClosedDeferred,\n                  content: tplAndVars[0],\n                  animation: modalOptions.animation,\n                  backdrop: modalOptions.backdrop,\n                  keyboard: modalOptions.keyboard,\n                  backdropClass: modalOptions.backdropClass,\n                  windowTopClass: modalOptions.windowTopClass,\n                  windowClass: modalOptions.windowClass,\n                  windowTemplateUrl: modalOptions.windowTemplateUrl,\n                  size: modalOptions.size,\n                  openedClass: modalOptions.openedClass,\n                  appendTo: modalOptions.appendTo\n                });\n                modalOpenedDeferred.resolve(true);\n\n            }, function resolveError(reason) {\n              modalOpenedDeferred.reject(reason);\n              modalResultDeferred.reject(reason);\n            })['finally'](function() {\n              if (promiseChain === samePromise) {\n                promiseChain = null;\n              }\n            });\n\n            return modalInstance;\n          };\n\n          return $modal;\n        }\n      ]\n    };\n\n    return $modalProvider;\n  });\n\nangular.module('ui.bootstrap.paging', [])\n/**\n * Helper internal service for generating common controller code between the\n * pager and pagination components\n */\n.factory('uibPaging', ['$parse', function($parse) {\n  return {\n    create: function(ctrl, $scope, $attrs) {\n      ctrl.setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;\n      ctrl.ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl\n      ctrl._watchers = [];\n\n      ctrl.init = function(ngModelCtrl, config) {\n        ctrl.ngModelCtrl = ngModelCtrl;\n        ctrl.config = config;\n\n        ngModelCtrl.$render = function() {\n          ctrl.render();\n        };\n\n        if ($attrs.itemsPerPage) {\n          ctrl._watchers.push($scope.$parent.$watch($attrs.itemsPerPage, function(value) {\n            ctrl.itemsPerPage = parseInt(value, 10);\n            $scope.totalPages = ctrl.calculateTotalPages();\n            ctrl.updatePage();\n          }));\n        } else {\n          ctrl.itemsPerPage = config.itemsPerPage;\n        }\n\n        $scope.$watch('totalItems', function(newTotal, oldTotal) {\n          if (angular.isDefined(newTotal) || newTotal !== oldTotal) {\n            $scope.totalPages = ctrl.calculateTotalPages();\n            ctrl.updatePage();\n          }\n        });\n      };\n\n      ctrl.calculateTotalPages = function() {\n        var totalPages = ctrl.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / ctrl.itemsPerPage);\n        return Math.max(totalPages || 0, 1);\n      };\n\n      ctrl.render = function() {\n        $scope.page = parseInt(ctrl.ngModelCtrl.$viewValue, 10) || 1;\n      };\n\n      $scope.selectPage = function(page, evt) {\n        if (evt) {\n          evt.preventDefault();\n        }\n\n        var clickAllowed = !$scope.ngDisabled || !evt;\n        if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {\n          if (evt && evt.target) {\n            evt.target.blur();\n          }\n          ctrl.ngModelCtrl.$setViewValue(page);\n          ctrl.ngModelCtrl.$render();\n        }\n      };\n\n      $scope.getText = function(key) {\n        return $scope[key + 'Text'] || ctrl.config[key + 'Text'];\n      };\n\n      $scope.noPrevious = function() {\n        return $scope.page === 1;\n      };\n\n      $scope.noNext = function() {\n        return $scope.page === $scope.totalPages;\n      };\n\n      ctrl.updatePage = function() {\n        ctrl.setNumPages($scope.$parent, $scope.totalPages); // Readonly variable\n\n        if ($scope.page > $scope.totalPages) {\n          $scope.selectPage($scope.totalPages);\n        } else {\n          ctrl.ngModelCtrl.$render();\n        }\n      };\n\n      $scope.$on('$destroy', function() {\n        while (ctrl._watchers.length) {\n          ctrl._watchers.shift()();\n        }\n      });\n    }\n  };\n}]);\n\nangular.module('ui.bootstrap.pager', ['ui.bootstrap.paging'])\n\n.controller('UibPagerController', ['$scope', '$attrs', 'uibPaging', 'uibPagerConfig', function($scope, $attrs, uibPaging, uibPagerConfig) {\n  $scope.align = angular.isDefined($attrs.align) ? $scope.$parent.$eval($attrs.align) : uibPagerConfig.align;\n\n  uibPaging.create(this, $scope, $attrs);\n}])\n\n.constant('uibPagerConfig', {\n  itemsPerPage: 10,\n  previousText: ' Previous',\n  nextText: 'Next ',\n  align: true\n})\n\n.directive('uibPager', ['uibPagerConfig', function(uibPagerConfig) {\n  return {\n    scope: {\n      totalItems: '=',\n      previousText: '@',\n      nextText: '@',\n      ngDisabled: '='\n    },\n    require: ['uibPager', '?ngModel'],\n    controller: 'UibPagerController',\n    controllerAs: 'pager',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/pager/pager.html';\n    },\n    replace: true,\n    link: function(scope, element, attrs, ctrls) {\n      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if (!ngModelCtrl) {\n        return; // do nothing if no ng-model\n      }\n\n      paginationCtrl.init(ngModelCtrl, uibPagerConfig);\n    }\n  };\n}]);\n\nangular.module('ui.bootstrap.pagination', ['ui.bootstrap.paging'])\n.controller('UibPaginationController', ['$scope', '$attrs', '$parse', 'uibPaging', 'uibPaginationConfig', function($scope, $attrs, $parse, uibPaging, uibPaginationConfig) {\n  var ctrl = this;\n  // Setup configuration parameters\n  var maxSize = angular.isDefined($attrs.maxSize) ? $scope.$parent.$eval($attrs.maxSize) : uibPaginationConfig.maxSize,\n    rotate = angular.isDefined($attrs.rotate) ? $scope.$parent.$eval($attrs.rotate) : uibPaginationConfig.rotate,\n    forceEllipses = angular.isDefined($attrs.forceEllipses) ? $scope.$parent.$eval($attrs.forceEllipses) : uibPaginationConfig.forceEllipses,\n    boundaryLinkNumbers = angular.isDefined($attrs.boundaryLinkNumbers) ? $scope.$parent.$eval($attrs.boundaryLinkNumbers) : uibPaginationConfig.boundaryLinkNumbers,\n    pageLabel = angular.isDefined($attrs.pageLabel) ? function(idx) { return $scope.$parent.$eval($attrs.pageLabel, {$page: idx}); } : angular.identity;\n  $scope.boundaryLinks = angular.isDefined($attrs.boundaryLinks) ? $scope.$parent.$eval($attrs.boundaryLinks) : uibPaginationConfig.boundaryLinks;\n  $scope.directionLinks = angular.isDefined($attrs.directionLinks) ? $scope.$parent.$eval($attrs.directionLinks) : uibPaginationConfig.directionLinks;\n\n  uibPaging.create(this, $scope, $attrs);\n\n  if ($attrs.maxSize) {\n    ctrl._watchers.push($scope.$parent.$watch($parse($attrs.maxSize), function(value) {\n      maxSize = parseInt(value, 10);\n      ctrl.render();\n    }));\n  }\n\n  // Create page object used in template\n  function makePage(number, text, isActive) {\n    return {\n      number: number,\n      text: text,\n      active: isActive\n    };\n  }\n\n  function getPages(currentPage, totalPages) {\n    var pages = [];\n\n    // Default page limits\n    var startPage = 1, endPage = totalPages;\n    var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;\n\n    // recompute if maxSize\n    if (isMaxSized) {\n      if (rotate) {\n        // Current page is displayed in the middle of the visible ones\n        startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1);\n        endPage = startPage + maxSize - 1;\n\n        // Adjust if limit is exceeded\n        if (endPage > totalPages) {\n          endPage = totalPages;\n          startPage = endPage - maxSize + 1;\n        }\n      } else {\n        // Visible pages are paginated with maxSize\n        startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1;\n\n        // Adjust last page if limit is exceeded\n        endPage = Math.min(startPage + maxSize - 1, totalPages);\n      }\n    }\n\n    // Add page number links\n    for (var number = startPage; number <= endPage; number++) {\n      var page = makePage(number, pageLabel(number), number === currentPage);\n      pages.push(page);\n    }\n\n    // Add links to move between page sets\n    if (isMaxSized && maxSize > 0 && (!rotate || forceEllipses || boundaryLinkNumbers)) {\n      if (startPage > 1) {\n        if (!boundaryLinkNumbers || startPage > 3) { //need ellipsis for all options unless range is too close to beginning\n        var previousPageSet = makePage(startPage - 1, '...', false);\n        pages.unshift(previousPageSet);\n      }\n        if (boundaryLinkNumbers) {\n          if (startPage === 3) { //need to replace ellipsis when the buttons would be sequential\n            var secondPageLink = makePage(2, '2', false);\n            pages.unshift(secondPageLink);\n          }\n          //add the first page\n          var firstPageLink = makePage(1, '1', false);\n          pages.unshift(firstPageLink);\n        }\n      }\n\n      if (endPage < totalPages) {\n        if (!boundaryLinkNumbers || endPage < totalPages - 2) { //need ellipsis for all options unless range is too close to end\n        var nextPageSet = makePage(endPage + 1, '...', false);\n        pages.push(nextPageSet);\n      }\n        if (boundaryLinkNumbers) {\n          if (endPage === totalPages - 2) { //need to replace ellipsis when the buttons would be sequential\n            var secondToLastPageLink = makePage(totalPages - 1, totalPages - 1, false);\n            pages.push(secondToLastPageLink);\n          }\n          //add the last page\n          var lastPageLink = makePage(totalPages, totalPages, false);\n          pages.push(lastPageLink);\n        }\n      }\n    }\n    return pages;\n  }\n\n  var originalRender = this.render;\n  this.render = function() {\n    originalRender();\n    if ($scope.page > 0 && $scope.page <= $scope.totalPages) {\n      $scope.pages = getPages($scope.page, $scope.totalPages);\n    }\n  };\n}])\n\n.constant('uibPaginationConfig', {\n  itemsPerPage: 10,\n  boundaryLinks: false,\n  boundaryLinkNumbers: false,\n  directionLinks: true,\n  firstText: 'First',\n  previousText: 'Previous',\n  nextText: 'Next',\n  lastText: 'Last',\n  rotate: true,\n  forceEllipses: false\n})\n\n.directive('uibPagination', ['$parse', 'uibPaginationConfig', function($parse, uibPaginationConfig) {\n  return {\n    scope: {\n      totalItems: '=',\n      firstText: '@',\n      previousText: '@',\n      nextText: '@',\n      lastText: '@',\n      ngDisabled:'='\n    },\n    require: ['uibPagination', '?ngModel'],\n    controller: 'UibPaginationController',\n    controllerAs: 'pagination',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/pagination/pagination.html';\n    },\n    replace: true,\n    link: function(scope, element, attrs, ctrls) {\n      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if (!ngModelCtrl) {\n         return; // do nothing if no ng-model\n      }\n\n      paginationCtrl.init(ngModelCtrl, uibPaginationConfig);\n    }\n  };\n}]);\n\n/**\n * The following features are still outstanding: animation as a\n * function, placement as a function, inside, support for more triggers than\n * just mouse enter/leave, html tooltips, and selector delegation.\n */\nangular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.stackedMap'])\n\n/**\n * The $tooltip service creates tooltip- and popover-like directives as well as\n * houses global options for them.\n */\n.provider('$uibTooltip', function() {\n  // The default options tooltip and popover.\n  var defaultOptions = {\n    placement: 'top',\n    placementClassPrefix: '',\n    animation: true,\n    popupDelay: 0,\n    popupCloseDelay: 0,\n    useContentExp: false\n  };\n\n  // Default hide triggers for each show trigger\n  var triggerMap = {\n    'mouseenter': 'mouseleave',\n    'click': 'click',\n    'outsideClick': 'outsideClick',\n    'focus': 'blur',\n    'none': ''\n  };\n\n  // The options specified to the provider globally.\n  var globalOptions = {};\n\n  /**\n   * `options({})` allows global configuration of all tooltips in the\n   * application.\n   *\n   *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {\n   *     // place tooltips left instead of top by default\n   *     $tooltipProvider.options( { placement: 'left' } );\n   *   });\n   */\n\tthis.options = function(value) {\n\t\tangular.extend(globalOptions, value);\n\t};\n\n  /**\n   * This allows you to extend the set of trigger mappings available. E.g.:\n   *\n   *   $tooltipProvider.setTriggers( { 'openTrigger': 'closeTrigger' } );\n   */\n  this.setTriggers = function setTriggers(triggers) {\n    angular.extend(triggerMap, triggers);\n  };\n\n  /**\n   * This is a helper function for translating camel-case to snake_case.\n   */\n  function snake_case(name) {\n    var regexp = /[A-Z]/g;\n    var separator = '-';\n    return name.replace(regexp, function(letter, pos) {\n      return (pos ? separator : '') + letter.toLowerCase();\n    });\n  }\n\n  /**\n   * Returns the actual instance of the $tooltip service.\n   * TODO support multiple triggers\n   */\n  this.$get = ['$window', '$compile', '$timeout', '$document', '$uibPosition', '$interpolate', '$rootScope', '$parse', '$$stackedMap', function($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse, $$stackedMap) {\n    var openedTooltips = $$stackedMap.createNew();\n    $document.on('keypress', keypressListener);\n\n    $rootScope.$on('$destroy', function() {\n      $document.off('keypress', keypressListener);\n    });\n\n    function keypressListener(e) {\n      if (e.which === 27) {\n        var last = openedTooltips.top();\n        if (last) {\n          last.value.close();\n          openedTooltips.removeTop();\n          last = null;\n        }\n      }\n    }\n\n    return function $tooltip(ttType, prefix, defaultTriggerShow, options) {\n      options = angular.extend({}, defaultOptions, globalOptions, options);\n\n      /**\n       * Returns an object of show and hide triggers.\n       *\n       * If a trigger is supplied,\n       * it is used to show the tooltip; otherwise, it will use the `trigger`\n       * option passed to the `$tooltipProvider.options` method; else it will\n       * default to the trigger supplied to this directive factory.\n       *\n       * The hide trigger is based on the show trigger. If the `trigger` option\n       * was passed to the `$tooltipProvider.options` method, it will use the\n       * mapped trigger from `triggerMap` or the passed trigger if the map is\n       * undefined; otherwise, it uses the `triggerMap` value of the show\n       * trigger; else it will just use the show trigger.\n       */\n      function getTriggers(trigger) {\n        var show = (trigger || options.trigger || defaultTriggerShow).split(' ');\n        var hide = show.map(function(trigger) {\n          return triggerMap[trigger] || trigger;\n        });\n        return {\n          show: show,\n          hide: hide\n        };\n      }\n\n      var directiveName = snake_case(ttType);\n\n      var startSym = $interpolate.startSymbol();\n      var endSym = $interpolate.endSymbol();\n      var template =\n        '<div '+ directiveName + '-popup ' +\n          'uib-title=\"' + startSym + 'title' + endSym + '\" ' +\n          (options.useContentExp ?\n            'content-exp=\"contentExp()\" ' :\n            'content=\"' + startSym + 'content' + endSym + '\" ') +\n          'placement=\"' + startSym + 'placement' + endSym + '\" ' +\n          'popup-class=\"' + startSym + 'popupClass' + endSym + '\" ' +\n          'animation=\"animation\" ' +\n          'is-open=\"isOpen\" ' +\n          'origin-scope=\"origScope\" ' +\n          'class=\"uib-position-measure\"' +\n          '>' +\n        '</div>';\n\n      return {\n        compile: function(tElem, tAttrs) {\n          var tooltipLinker = $compile(template);\n\n          return function link(scope, element, attrs, tooltipCtrl) {\n            var tooltip;\n            var tooltipLinkedScope;\n            var transitionTimeout;\n            var showTimeout;\n            var hideTimeout;\n            var positionTimeout;\n            var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;\n            var triggers = getTriggers(undefined);\n            var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);\n            var ttScope = scope.$new(true);\n            var repositionScheduled = false;\n            var isOpenParse = angular.isDefined(attrs[prefix + 'IsOpen']) ? $parse(attrs[prefix + 'IsOpen']) : false;\n            var contentParse = options.useContentExp ? $parse(attrs[ttType]) : false;\n            var observers = [];\n            var lastPlacement;\n\n            var positionTooltip = function() {\n              // check if tooltip exists and is not empty\n              if (!tooltip || !tooltip.html()) { return; }\n\n              if (!positionTimeout) {\n                positionTimeout = $timeout(function() {\n                  var ttPosition = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);\n                  tooltip.css({ top: ttPosition.top + 'px', left: ttPosition.left + 'px' });\n\n                  if (!tooltip.hasClass(ttPosition.placement.split('-')[0])) {\n                    tooltip.removeClass(lastPlacement.split('-')[0]);\n                    tooltip.addClass(ttPosition.placement.split('-')[0]);\n                  }\n\n                  if (!tooltip.hasClass(options.placementClassPrefix + ttPosition.placement)) {\n                    tooltip.removeClass(options.placementClassPrefix + lastPlacement);\n                    tooltip.addClass(options.placementClassPrefix + ttPosition.placement);\n                  }\n\n                  // first time through tt element will have the\n                  // uib-position-measure class or if the placement\n                  // has changed we need to position the arrow.\n                  if (tooltip.hasClass('uib-position-measure')) {\n                    $position.positionArrow(tooltip, ttPosition.placement);\n                    tooltip.removeClass('uib-position-measure');\n                  } else if (lastPlacement !== ttPosition.placement) {\n                    $position.positionArrow(tooltip, ttPosition.placement);\n                  }\n                  lastPlacement = ttPosition.placement;\n\n                  positionTimeout = null;\n                }, 0, false);\n              }\n            };\n\n            // Set up the correct scope to allow transclusion later\n            ttScope.origScope = scope;\n\n            // By default, the tooltip is not open.\n            // TODO add ability to start tooltip opened\n            ttScope.isOpen = false;\n            openedTooltips.add(ttScope, {\n              close: hide\n            });\n\n            function toggleTooltipBind() {\n              if (!ttScope.isOpen) {\n                showTooltipBind();\n              } else {\n                hideTooltipBind();\n              }\n            }\n\n            // Show the tooltip with delay if specified, otherwise show it immediately\n            function showTooltipBind() {\n              if (hasEnableExp && !scope.$eval(attrs[prefix + 'Enable'])) {\n                return;\n              }\n\n              cancelHide();\n              prepareTooltip();\n\n              if (ttScope.popupDelay) {\n                // Do nothing if the tooltip was already scheduled to pop-up.\n                // This happens if show is triggered multiple times before any hide is triggered.\n                if (!showTimeout) {\n                  showTimeout = $timeout(show, ttScope.popupDelay, false);\n                }\n              } else {\n                show();\n              }\n            }\n\n            function hideTooltipBind() {\n              cancelShow();\n\n              if (ttScope.popupCloseDelay) {\n                if (!hideTimeout) {\n                  hideTimeout = $timeout(hide, ttScope.popupCloseDelay, false);\n                }\n              } else {\n                hide();\n              }\n            }\n\n            // Show the tooltip popup element.\n            function show() {\n              cancelShow();\n              cancelHide();\n\n              // Don't show empty tooltips.\n              if (!ttScope.content) {\n                return angular.noop;\n              }\n\n              createTooltip();\n\n              // And show the tooltip.\n              ttScope.$evalAsync(function() {\n                ttScope.isOpen = true;\n                assignIsOpen(true);\n                positionTooltip();\n              });\n            }\n\n            function cancelShow() {\n              if (showTimeout) {\n                $timeout.cancel(showTimeout);\n                showTimeout = null;\n              }\n\n              if (positionTimeout) {\n                $timeout.cancel(positionTimeout);\n                positionTimeout = null;\n              }\n            }\n\n            // Hide the tooltip popup element.\n            function hide() {\n              if (!ttScope) {\n                return;\n              }\n\n              // First things first: we don't show it anymore.\n              ttScope.$evalAsync(function() {\n                if (ttScope) {\n                  ttScope.isOpen = false;\n                  assignIsOpen(false);\n                  // And now we remove it from the DOM. However, if we have animation, we\n                  // need to wait for it to expire beforehand.\n                  // FIXME: this is a placeholder for a port of the transitions library.\n                  // The fade transition in TWBS is 150ms.\n                  if (ttScope.animation) {\n                    if (!transitionTimeout) {\n                      transitionTimeout = $timeout(removeTooltip, 150, false);\n                    }\n                  } else {\n                    removeTooltip();\n                  }\n                }\n              });\n            }\n\n            function cancelHide() {\n              if (hideTimeout) {\n                $timeout.cancel(hideTimeout);\n                hideTimeout = null;\n              }\n\n              if (transitionTimeout) {\n                $timeout.cancel(transitionTimeout);\n                transitionTimeout = null;\n              }\n            }\n\n            function createTooltip() {\n              // There can only be one tooltip element per directive shown at once.\n              if (tooltip) {\n                return;\n              }\n\n              tooltipLinkedScope = ttScope.$new();\n              tooltip = tooltipLinker(tooltipLinkedScope, function(tooltip) {\n                if (appendToBody) {\n                  $document.find('body').append(tooltip);\n                } else {\n                  element.after(tooltip);\n                }\n              });\n\n              prepObservers();\n            }\n\n            function removeTooltip() {\n              cancelShow();\n              cancelHide();\n              unregisterObservers();\n\n              if (tooltip) {\n                tooltip.remove();\n                tooltip = null;\n              }\n              if (tooltipLinkedScope) {\n                tooltipLinkedScope.$destroy();\n                tooltipLinkedScope = null;\n              }\n            }\n\n            /**\n             * Set the initial scope values. Once\n             * the tooltip is created, the observers\n             * will be added to keep things in sync.\n             */\n            function prepareTooltip() {\n              ttScope.title = attrs[prefix + 'Title'];\n              if (contentParse) {\n                ttScope.content = contentParse(scope);\n              } else {\n                ttScope.content = attrs[ttType];\n              }\n\n              ttScope.popupClass = attrs[prefix + 'Class'];\n              ttScope.placement = angular.isDefined(attrs[prefix + 'Placement']) ? attrs[prefix + 'Placement'] : options.placement;\n              var placement = $position.parsePlacement(ttScope.placement);\n              lastPlacement = placement[1] ? placement[0] + '-' + placement[1] : placement[0];\n\n              var delay = parseInt(attrs[prefix + 'PopupDelay'], 10);\n              var closeDelay = parseInt(attrs[prefix + 'PopupCloseDelay'], 10);\n              ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;\n              ttScope.popupCloseDelay = !isNaN(closeDelay) ? closeDelay : options.popupCloseDelay;\n            }\n\n            function assignIsOpen(isOpen) {\n              if (isOpenParse && angular.isFunction(isOpenParse.assign)) {\n                isOpenParse.assign(scope, isOpen);\n              }\n            }\n\n            ttScope.contentExp = function() {\n              return ttScope.content;\n            };\n\n            /**\n             * Observe the relevant attributes.\n             */\n            attrs.$observe('disabled', function(val) {\n              if (val) {\n                cancelShow();\n              }\n\n              if (val && ttScope.isOpen) {\n                hide();\n              }\n            });\n\n            if (isOpenParse) {\n              scope.$watch(isOpenParse, function(val) {\n                if (ttScope && !val === ttScope.isOpen) {\n                  toggleTooltipBind();\n                }\n              });\n            }\n\n            function prepObservers() {\n              observers.length = 0;\n\n              if (contentParse) {\n                observers.push(\n                  scope.$watch(contentParse, function(val) {\n                    ttScope.content = val;\n                    if (!val && ttScope.isOpen) {\n                      hide();\n                    }\n                  })\n                );\n\n                observers.push(\n                  tooltipLinkedScope.$watch(function() {\n                    if (!repositionScheduled) {\n                      repositionScheduled = true;\n                      tooltipLinkedScope.$$postDigest(function() {\n                        repositionScheduled = false;\n                        if (ttScope && ttScope.isOpen) {\n                          positionTooltip();\n                        }\n                      });\n                    }\n                  })\n                );\n              } else {\n                observers.push(\n                  attrs.$observe(ttType, function(val) {\n                    ttScope.content = val;\n                    if (!val && ttScope.isOpen) {\n                      hide();\n                    } else {\n                      positionTooltip();\n                    }\n                  })\n                );\n              }\n\n              observers.push(\n                attrs.$observe(prefix + 'Title', function(val) {\n                  ttScope.title = val;\n                  if (ttScope.isOpen) {\n                    positionTooltip();\n                  }\n                })\n              );\n\n              observers.push(\n                attrs.$observe(prefix + 'Placement', function(val) {\n                  ttScope.placement = val ? val : options.placement;\n                  if (ttScope.isOpen) {\n                    positionTooltip();\n                  }\n                })\n              );\n            }\n\n            function unregisterObservers() {\n              if (observers.length) {\n                angular.forEach(observers, function(observer) {\n                  observer();\n                });\n                observers.length = 0;\n              }\n            }\n\n            // hide tooltips/popovers for outsideClick trigger\n            function bodyHideTooltipBind(e) {\n              if (!ttScope || !ttScope.isOpen || !tooltip) {\n                return;\n              }\n              // make sure the tooltip/popover link or tool tooltip/popover itself were not clicked\n              if (!element[0].contains(e.target) && !tooltip[0].contains(e.target)) {\n                hideTooltipBind();\n              }\n            }\n\n            var unregisterTriggers = function() {\n              triggers.show.forEach(function(trigger) {\n                if (trigger === 'outsideClick') {\n                  element.off('click', toggleTooltipBind);\n                } else {\n                  element.off(trigger, showTooltipBind);\n                  element.off(trigger, toggleTooltipBind);\n                }\n              });\n              triggers.hide.forEach(function(trigger) {\n                if (trigger === 'outsideClick') {\n                  $document.off('click', bodyHideTooltipBind);\n                } else {\n                  element.off(trigger, hideTooltipBind);\n                }\n              });\n            };\n\n            function prepTriggers() {\n              var val = attrs[prefix + 'Trigger'];\n              unregisterTriggers();\n\n              triggers = getTriggers(val);\n\n              if (triggers.show !== 'none') {\n                triggers.show.forEach(function(trigger, idx) {\n                  if (trigger === 'outsideClick') {\n                    element.on('click', toggleTooltipBind);\n                    $document.on('click', bodyHideTooltipBind);\n                  } else if (trigger === triggers.hide[idx]) {\n                    element.on(trigger, toggleTooltipBind);\n                  } else if (trigger) {\n                    element.on(trigger, showTooltipBind);\n                    element.on(triggers.hide[idx], hideTooltipBind);\n                  }\n\n                  element.on('keypress', function(e) {\n                    if (e.which === 27) {\n                      hideTooltipBind();\n                    }\n                  });\n                });\n              }\n            }\n\n            prepTriggers();\n\n            var animation = scope.$eval(attrs[prefix + 'Animation']);\n            ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;\n\n            var appendToBodyVal;\n            var appendKey = prefix + 'AppendToBody';\n            if (appendKey in attrs && attrs[appendKey] === undefined) {\n              appendToBodyVal = true;\n            } else {\n              appendToBodyVal = scope.$eval(attrs[appendKey]);\n            }\n\n            appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;\n\n            // Make sure tooltip is destroyed and removed.\n            scope.$on('$destroy', function onDestroyTooltip() {\n              unregisterTriggers();\n              removeTooltip();\n              openedTooltips.remove(ttScope);\n              ttScope = null;\n            });\n          };\n        }\n      };\n    };\n  }];\n})\n\n// This is mostly ngInclude code but with a custom scope\n.directive('uibTooltipTemplateTransclude', [\n         '$animate', '$sce', '$compile', '$templateRequest',\nfunction ($animate, $sce, $compile, $templateRequest) {\n  return {\n    link: function(scope, elem, attrs) {\n      var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);\n\n      var changeCounter = 0,\n        currentScope,\n        previousElement,\n        currentElement;\n\n      var cleanupLastIncludeContent = function() {\n        if (previousElement) {\n          previousElement.remove();\n          previousElement = null;\n        }\n\n        if (currentScope) {\n          currentScope.$destroy();\n          currentScope = null;\n        }\n\n        if (currentElement) {\n          $animate.leave(currentElement).then(function() {\n            previousElement = null;\n          });\n          previousElement = currentElement;\n          currentElement = null;\n        }\n      };\n\n      scope.$watch($sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude), function(src) {\n        var thisChangeId = ++changeCounter;\n\n        if (src) {\n          //set the 2nd param to true to ignore the template request error so that the inner\n          //contents and scope can be cleaned up.\n          $templateRequest(src, true).then(function(response) {\n            if (thisChangeId !== changeCounter) { return; }\n            var newScope = origScope.$new();\n            var template = response;\n\n            var clone = $compile(template)(newScope, function(clone) {\n              cleanupLastIncludeContent();\n              $animate.enter(clone, elem);\n            });\n\n            currentScope = newScope;\n            currentElement = clone;\n\n            currentScope.$emit('$includeContentLoaded', src);\n          }, function() {\n            if (thisChangeId === changeCounter) {\n              cleanupLastIncludeContent();\n              scope.$emit('$includeContentError', src);\n            }\n          });\n          scope.$emit('$includeContentRequested', src);\n        } else {\n          cleanupLastIncludeContent();\n        }\n      });\n\n      scope.$on('$destroy', cleanupLastIncludeContent);\n    }\n  };\n}])\n\n/**\n * Note that it's intentional that these classes are *not* applied through $animate.\n * They must not be animated as they're expected to be present on the tooltip on\n * initialization.\n */\n.directive('uibTooltipClasses', ['$uibPosition', function($uibPosition) {\n  return {\n    restrict: 'A',\n    link: function(scope, element, attrs) {\n      // need to set the primary position so the\n      // arrow has space during position measure.\n      // tooltip.positionTooltip()\n      if (scope.placement) {\n        // // There are no top-left etc... classes\n        // // in TWBS, so we need the primary position.\n        var position = $uibPosition.parsePlacement(scope.placement);\n        element.addClass(position[0]);\n      }\n\n      if (scope.popupClass) {\n        element.addClass(scope.popupClass);\n      }\n\n      if (scope.animation()) {\n        element.addClass(attrs.tooltipAnimationClass);\n      }\n    }\n  };\n}])\n\n.directive('uibTooltipPopup', function() {\n  return {\n    replace: true,\n    scope: { content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'uib/template/tooltip/tooltip-popup.html'\n  };\n})\n\n.directive('uibTooltip', [ '$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibTooltip', 'tooltip', 'mouseenter');\n}])\n\n.directive('uibTooltipTemplatePopup', function() {\n  return {\n    replace: true,\n    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',\n      originScope: '&' },\n    templateUrl: 'uib/template/tooltip/tooltip-template-popup.html'\n  };\n})\n\n.directive('uibTooltipTemplate', ['$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibTooltipTemplate', 'tooltip', 'mouseenter', {\n    useContentExp: true\n  });\n}])\n\n.directive('uibTooltipHtmlPopup', function() {\n  return {\n    replace: true,\n    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'uib/template/tooltip/tooltip-html-popup.html'\n  };\n})\n\n.directive('uibTooltipHtml', ['$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibTooltipHtml', 'tooltip', 'mouseenter', {\n    useContentExp: true\n  });\n}]);\n\n/**\n * The following features are still outstanding: popup delay, animation as a\n * function, placement as a function, inside, support for more triggers than\n * just mouse enter/leave, and selector delegatation.\n */\nangular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip'])\n\n.directive('uibPopoverTemplatePopup', function() {\n  return {\n    replace: true,\n    scope: { uibTitle: '@', contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',\n      originScope: '&' },\n    templateUrl: 'uib/template/popover/popover-template.html'\n  };\n})\n\n.directive('uibPopoverTemplate', ['$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibPopoverTemplate', 'popover', 'click', {\n    useContentExp: true\n  });\n}])\n\n.directive('uibPopoverHtmlPopup', function() {\n  return {\n    replace: true,\n    scope: { contentExp: '&', uibTitle: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'uib/template/popover/popover-html.html'\n  };\n})\n\n.directive('uibPopoverHtml', ['$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibPopoverHtml', 'popover', 'click', {\n    useContentExp: true\n  });\n}])\n\n.directive('uibPopoverPopup', function() {\n  return {\n    replace: true,\n    scope: { uibTitle: '@', content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'uib/template/popover/popover.html'\n  };\n})\n\n.directive('uibPopover', ['$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibPopover', 'popover', 'click');\n}]);\n\nangular.module('ui.bootstrap.progressbar', [])\n\n.constant('uibProgressConfig', {\n  animate: true,\n  max: 100\n})\n\n.controller('UibProgressController', ['$scope', '$attrs', 'uibProgressConfig', function($scope, $attrs, progressConfig) {\n  var self = this,\n      animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;\n\n  this.bars = [];\n  $scope.max = getMaxOrDefault();\n\n  this.addBar = function(bar, element, attrs) {\n    if (!animate) {\n      element.css({'transition': 'none'});\n    }\n\n    this.bars.push(bar);\n\n    bar.max = getMaxOrDefault();\n    bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';\n\n    bar.$watch('value', function(value) {\n      bar.recalculatePercentage();\n    });\n\n    bar.recalculatePercentage = function() {\n      var totalPercentage = self.bars.reduce(function(total, bar) {\n        bar.percent = +(100 * bar.value / bar.max).toFixed(2);\n        return total + bar.percent;\n      }, 0);\n\n      if (totalPercentage > 100) {\n        bar.percent -= totalPercentage - 100;\n      }\n    };\n\n    bar.$on('$destroy', function() {\n      element = null;\n      self.removeBar(bar);\n    });\n  };\n\n  this.removeBar = function(bar) {\n    this.bars.splice(this.bars.indexOf(bar), 1);\n    this.bars.forEach(function (bar) {\n      bar.recalculatePercentage();\n    });\n  };\n\n  //$attrs.$observe('maxParam', function(maxParam) {\n  $scope.$watch('maxParam', function(maxParam) {\n    self.bars.forEach(function(bar) {\n      bar.max = getMaxOrDefault();\n      bar.recalculatePercentage();\n    });\n  });\n\n  function getMaxOrDefault () {\n    return angular.isDefined($scope.maxParam) ? $scope.maxParam : progressConfig.max;\n  }\n}])\n\n.directive('uibProgress', function() {\n  return {\n    replace: true,\n    transclude: true,\n    controller: 'UibProgressController',\n    require: 'uibProgress',\n    scope: {\n      maxParam: '=?max'\n    },\n    templateUrl: 'uib/template/progressbar/progress.html'\n  };\n})\n\n.directive('uibBar', function() {\n  return {\n    replace: true,\n    transclude: true,\n    require: '^uibProgress',\n    scope: {\n      value: '=',\n      type: '@'\n    },\n    templateUrl: 'uib/template/progressbar/bar.html',\n    link: function(scope, element, attrs, progressCtrl) {\n      progressCtrl.addBar(scope, element, attrs);\n    }\n  };\n})\n\n.directive('uibProgressbar', function() {\n  return {\n    replace: true,\n    transclude: true,\n    controller: 'UibProgressController',\n    scope: {\n      value: '=',\n      maxParam: '=?max',\n      type: '@'\n    },\n    templateUrl: 'uib/template/progressbar/progressbar.html',\n    link: function(scope, element, attrs, progressCtrl) {\n      progressCtrl.addBar(scope, angular.element(element.children()[0]), {title: attrs.title});\n    }\n  };\n});\n\nangular.module('ui.bootstrap.rating', [])\n\n.constant('uibRatingConfig', {\n  max: 5,\n  stateOn: null,\n  stateOff: null,\n  enableReset: true,\n  titles : ['one', 'two', 'three', 'four', 'five']\n})\n\n.controller('UibRatingController', ['$scope', '$attrs', 'uibRatingConfig', function($scope, $attrs, ratingConfig) {\n  var ngModelCtrl = { $setViewValue: angular.noop },\n    self = this;\n\n  this.init = function(ngModelCtrl_) {\n    ngModelCtrl = ngModelCtrl_;\n    ngModelCtrl.$render = this.render;\n\n    ngModelCtrl.$formatters.push(function(value) {\n      if (angular.isNumber(value) && value << 0 !== value) {\n        value = Math.round(value);\n      }\n\n      return value;\n    });\n\n    this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;\n    this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;\n    this.enableReset = angular.isDefined($attrs.enableReset) ?\n      $scope.$parent.$eval($attrs.enableReset) : ratingConfig.enableReset;\n    var tmpTitles = angular.isDefined($attrs.titles) ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles;\n    this.titles = angular.isArray(tmpTitles) && tmpTitles.length > 0 ?\n      tmpTitles : ratingConfig.titles;\n\n    var ratingStates = angular.isDefined($attrs.ratingStates) ?\n      $scope.$parent.$eval($attrs.ratingStates) :\n      new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);\n    $scope.range = this.buildTemplateObjects(ratingStates);\n  };\n\n  this.buildTemplateObjects = function(states) {\n    for (var i = 0, n = states.length; i < n; i++) {\n      states[i] = angular.extend({ index: i }, { stateOn: this.stateOn, stateOff: this.stateOff, title: this.getTitle(i) }, states[i]);\n    }\n    return states;\n  };\n\n  this.getTitle = function(index) {\n    if (index >= this.titles.length) {\n      return index + 1;\n    }\n\n    return this.titles[index];\n  };\n\n  $scope.rate = function(value) {\n    if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {\n      var newViewValue = self.enableReset && ngModelCtrl.$viewValue === value ? 0 : value;\n      ngModelCtrl.$setViewValue(newViewValue);\n      ngModelCtrl.$render();\n    }\n  };\n\n  $scope.enter = function(value) {\n    if (!$scope.readonly) {\n      $scope.value = value;\n    }\n    $scope.onHover({value: value});\n  };\n\n  $scope.reset = function() {\n    $scope.value = ngModelCtrl.$viewValue;\n    $scope.onLeave();\n  };\n\n  $scope.onKeydown = function(evt) {\n    if (/(37|38|39|40)/.test(evt.which)) {\n      evt.preventDefault();\n      evt.stopPropagation();\n      $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));\n    }\n  };\n\n  this.render = function() {\n    $scope.value = ngModelCtrl.$viewValue;\n    $scope.title = self.getTitle($scope.value - 1);\n  };\n}])\n\n.directive('uibRating', function() {\n  return {\n    require: ['uibRating', 'ngModel'],\n    scope: {\n      readonly: '=?readOnly',\n      onHover: '&',\n      onLeave: '&'\n    },\n    controller: 'UibRatingController',\n    templateUrl: 'uib/template/rating/rating.html',\n    replace: true,\n    link: function(scope, element, attrs, ctrls) {\n      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n      ratingCtrl.init(ngModelCtrl);\n    }\n  };\n});\n\nangular.module('ui.bootstrap.tabs', [])\n\n.controller('UibTabsetController', ['$scope', function ($scope) {\n  var ctrl = this,\n    oldIndex;\n  ctrl.tabs = [];\n\n  ctrl.select = function(index, evt) {\n    if (!destroyed) {\n      var previousIndex = findTabIndex(oldIndex);\n      var previousSelected = ctrl.tabs[previousIndex];\n      if (previousSelected) {\n        previousSelected.tab.onDeselect({\n          $event: evt,\n          $selectedIndex: index\n        });\n        if (evt && evt.isDefaultPrevented()) {\n          return;\n        }\n        previousSelected.tab.active = false;\n      }\n\n      var selected = ctrl.tabs[index];\n      if (selected) {\n        selected.tab.onSelect({\n          $event: evt\n        });\n        selected.tab.active = true;\n        ctrl.active = selected.index;\n        oldIndex = selected.index;\n      } else if (!selected && angular.isDefined(oldIndex)) {\n        ctrl.active = null;\n        oldIndex = null;\n      }\n    }\n  };\n\n  ctrl.addTab = function addTab(tab) {\n    ctrl.tabs.push({\n      tab: tab,\n      index: tab.index\n    });\n    ctrl.tabs.sort(function(t1, t2) {\n      if (t1.index > t2.index) {\n        return 1;\n      }\n\n      if (t1.index < t2.index) {\n        return -1;\n      }\n\n      return 0;\n    });\n\n    if (tab.index === ctrl.active || !angular.isDefined(ctrl.active) && ctrl.tabs.length === 1) {\n      var newActiveIndex = findTabIndex(tab.index);\n      ctrl.select(newActiveIndex);\n    }\n  };\n\n  ctrl.removeTab = function removeTab(tab) {\n    var index;\n    for (var i = 0; i < ctrl.tabs.length; i++) {\n      if (ctrl.tabs[i].tab === tab) {\n        index = i;\n        break;\n      }\n    }\n\n    if (ctrl.tabs[index].index === ctrl.active) {\n      var newActiveTabIndex = index === ctrl.tabs.length - 1 ?\n        index - 1 : index + 1 % ctrl.tabs.length;\n      ctrl.select(newActiveTabIndex);\n    }\n\n    ctrl.tabs.splice(index, 1);\n  };\n\n  $scope.$watch('tabset.active', function(val) {\n    if (angular.isDefined(val) && val !== oldIndex) {\n      ctrl.select(findTabIndex(val));\n    }\n  });\n\n  var destroyed;\n  $scope.$on('$destroy', function() {\n    destroyed = true;\n  });\n\n  function findTabIndex(index) {\n    for (var i = 0; i < ctrl.tabs.length; i++) {\n      if (ctrl.tabs[i].index === index) {\n        return i;\n      }\n    }\n  }\n}])\n\n.directive('uibTabset', function() {\n  return {\n    transclude: true,\n    replace: true,\n    scope: {},\n    bindToController: {\n      active: '=?',\n      type: '@'\n    },\n    controller: 'UibTabsetController',\n    controllerAs: 'tabset',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/tabs/tabset.html';\n    },\n    link: function(scope, element, attrs) {\n      scope.vertical = angular.isDefined(attrs.vertical) ?\n        scope.$parent.$eval(attrs.vertical) : false;\n      scope.justified = angular.isDefined(attrs.justified) ?\n        scope.$parent.$eval(attrs.justified) : false;\n    }\n  };\n})\n\n.directive('uibTab', ['$parse', function($parse) {\n  return {\n    require: '^uibTabset',\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/tabs/tab.html';\n    },\n    transclude: true,\n    scope: {\n      heading: '@',\n      index: '=?',\n      classes: '@?',\n      onSelect: '&select', //This callback is called in contentHeadingTransclude\n                          //once it inserts the tab's content into the dom\n      onDeselect: '&deselect'\n    },\n    controller: function() {\n      //Empty controller so other directives can require being 'under' a tab\n    },\n    controllerAs: 'tab',\n    link: function(scope, elm, attrs, tabsetCtrl, transclude) {\n      scope.disabled = false;\n      if (attrs.disable) {\n        scope.$parent.$watch($parse(attrs.disable), function(value) {\n          scope.disabled = !! value;\n        });\n      }\n\n      if (angular.isUndefined(attrs.index)) {\n        if (tabsetCtrl.tabs && tabsetCtrl.tabs.length) {\n          scope.index = Math.max.apply(null, tabsetCtrl.tabs.map(function(t) { return t.index; })) + 1;\n        } else {\n          scope.index = 0;\n        }\n      }\n\n      if (angular.isUndefined(attrs.classes)) {\n        scope.classes = '';\n      }\n\n      scope.select = function(evt) {\n        if (!scope.disabled) {\n          var index;\n          for (var i = 0; i < tabsetCtrl.tabs.length; i++) {\n            if (tabsetCtrl.tabs[i].tab === scope) {\n              index = i;\n              break;\n            }\n          }\n\n          tabsetCtrl.select(index, evt);\n        }\n      };\n\n      tabsetCtrl.addTab(scope);\n      scope.$on('$destroy', function() {\n        tabsetCtrl.removeTab(scope);\n      });\n\n      //We need to transclude later, once the content container is ready.\n      //when this link happens, we're inside a tab heading.\n      scope.$transcludeFn = transclude;\n    }\n  };\n}])\n\n.directive('uibTabHeadingTransclude', function() {\n  return {\n    restrict: 'A',\n    require: '^uibTab',\n    link: function(scope, elm) {\n      scope.$watch('headingElement', function updateHeadingElement(heading) {\n        if (heading) {\n          elm.html('');\n          elm.append(heading);\n        }\n      });\n    }\n  };\n})\n\n.directive('uibTabContentTransclude', function() {\n  return {\n    restrict: 'A',\n    require: '^uibTabset',\n    link: function(scope, elm, attrs) {\n      var tab = scope.$eval(attrs.uibTabContentTransclude).tab;\n\n      //Now our tab is ready to be transcluded: both the tab heading area\n      //and the tab content area are loaded.  Transclude 'em both.\n      tab.$transcludeFn(tab.$parent, function(contents) {\n        angular.forEach(contents, function(node) {\n          if (isTabHeading(node)) {\n            //Let tabHeadingTransclude know.\n            tab.headingElement = node;\n          } else {\n            elm.append(node);\n          }\n        });\n      });\n    }\n  };\n\n  function isTabHeading(node) {\n    return node.tagName && (\n      node.hasAttribute('uib-tab-heading') ||\n      node.hasAttribute('data-uib-tab-heading') ||\n      node.hasAttribute('x-uib-tab-heading') ||\n      node.tagName.toLowerCase() === 'uib-tab-heading' ||\n      node.tagName.toLowerCase() === 'data-uib-tab-heading' ||\n      node.tagName.toLowerCase() === 'x-uib-tab-heading' ||\n      node.tagName.toLowerCase() === 'uib:tab-heading'\n    );\n  }\n});\n\nangular.module('ui.bootstrap.timepicker', [])\n\n.constant('uibTimepickerConfig', {\n  hourStep: 1,\n  minuteStep: 1,\n  secondStep: 1,\n  showMeridian: true,\n  showSeconds: false,\n  meridians: null,\n  readonlyInput: false,\n  mousewheel: true,\n  arrowkeys: true,\n  showSpinners: true,\n  templateUrl: 'uib/template/timepicker/timepicker.html'\n})\n\n.controller('UibTimepickerController', ['$scope', '$element', '$attrs', '$parse', '$log', '$locale', 'uibTimepickerConfig', function($scope, $element, $attrs, $parse, $log, $locale, timepickerConfig) {\n  var selected = new Date(),\n    watchers = [],\n    ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl\n    meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS,\n    padHours = angular.isDefined($attrs.padHours) ? $scope.$parent.$eval($attrs.padHours) : true;\n\n  $scope.tabindex = angular.isDefined($attrs.tabindex) ? $attrs.tabindex : 0;\n  $element.removeAttr('tabindex');\n\n  this.init = function(ngModelCtrl_, inputs) {\n    ngModelCtrl = ngModelCtrl_;\n    ngModelCtrl.$render = this.render;\n\n    ngModelCtrl.$formatters.unshift(function(modelValue) {\n      return modelValue ? new Date(modelValue) : null;\n    });\n\n    var hoursInputEl = inputs.eq(0),\n        minutesInputEl = inputs.eq(1),\n        secondsInputEl = inputs.eq(2);\n\n    var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;\n\n    if (mousewheel) {\n      this.setupMousewheelEvents(hoursInputEl, minutesInputEl, secondsInputEl);\n    }\n\n    var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;\n    if (arrowkeys) {\n      this.setupArrowkeyEvents(hoursInputEl, minutesInputEl, secondsInputEl);\n    }\n\n    $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;\n    this.setupInputEvents(hoursInputEl, minutesInputEl, secondsInputEl);\n  };\n\n  var hourStep = timepickerConfig.hourStep;\n  if ($attrs.hourStep) {\n    watchers.push($scope.$parent.$watch($parse($attrs.hourStep), function(value) {\n      hourStep = +value;\n    }));\n  }\n\n  var minuteStep = timepickerConfig.minuteStep;\n  if ($attrs.minuteStep) {\n    watchers.push($scope.$parent.$watch($parse($attrs.minuteStep), function(value) {\n      minuteStep = +value;\n    }));\n  }\n\n  var min;\n  watchers.push($scope.$parent.$watch($parse($attrs.min), function(value) {\n    var dt = new Date(value);\n    min = isNaN(dt) ? undefined : dt;\n  }));\n\n  var max;\n  watchers.push($scope.$parent.$watch($parse($attrs.max), function(value) {\n    var dt = new Date(value);\n    max = isNaN(dt) ? undefined : dt;\n  }));\n\n  var disabled = false;\n  if ($attrs.ngDisabled) {\n    watchers.push($scope.$parent.$watch($parse($attrs.ngDisabled), function(value) {\n      disabled = value;\n    }));\n  }\n\n  $scope.noIncrementHours = function() {\n    var incrementedSelected = addMinutes(selected, hourStep * 60);\n    return disabled || incrementedSelected > max ||\n      incrementedSelected < selected && incrementedSelected < min;\n  };\n\n  $scope.noDecrementHours = function() {\n    var decrementedSelected = addMinutes(selected, -hourStep * 60);\n    return disabled || decrementedSelected < min ||\n      decrementedSelected > selected && decrementedSelected > max;\n  };\n\n  $scope.noIncrementMinutes = function() {\n    var incrementedSelected = addMinutes(selected, minuteStep);\n    return disabled || incrementedSelected > max ||\n      incrementedSelected < selected && incrementedSelected < min;\n  };\n\n  $scope.noDecrementMinutes = function() {\n    var decrementedSelected = addMinutes(selected, -minuteStep);\n    return disabled || decrementedSelected < min ||\n      decrementedSelected > selected && decrementedSelected > max;\n  };\n\n  $scope.noIncrementSeconds = function() {\n    var incrementedSelected = addSeconds(selected, secondStep);\n    return disabled || incrementedSelected > max ||\n      incrementedSelected < selected && incrementedSelected < min;\n  };\n\n  $scope.noDecrementSeconds = function() {\n    var decrementedSelected = addSeconds(selected, -secondStep);\n    return disabled || decrementedSelected < min ||\n      decrementedSelected > selected && decrementedSelected > max;\n  };\n\n  $scope.noToggleMeridian = function() {\n    if (selected.getHours() < 12) {\n      return disabled || addMinutes(selected, 12 * 60) > max;\n    }\n\n    return disabled || addMinutes(selected, -12 * 60) < min;\n  };\n\n  var secondStep = timepickerConfig.secondStep;\n  if ($attrs.secondStep) {\n    watchers.push($scope.$parent.$watch($parse($attrs.secondStep), function(value) {\n      secondStep = +value;\n    }));\n  }\n\n  $scope.showSeconds = timepickerConfig.showSeconds;\n  if ($attrs.showSeconds) {\n    watchers.push($scope.$parent.$watch($parse($attrs.showSeconds), function(value) {\n      $scope.showSeconds = !!value;\n    }));\n  }\n\n  // 12H / 24H mode\n  $scope.showMeridian = timepickerConfig.showMeridian;\n  if ($attrs.showMeridian) {\n    watchers.push($scope.$parent.$watch($parse($attrs.showMeridian), function(value) {\n      $scope.showMeridian = !!value;\n\n      if (ngModelCtrl.$error.time) {\n        // Evaluate from template\n        var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();\n        if (angular.isDefined(hours) && angular.isDefined(minutes)) {\n          selected.setHours(hours);\n          refresh();\n        }\n      } else {\n        updateTemplate();\n      }\n    }));\n  }\n\n  // Get $scope.hours in 24H mode if valid\n  function getHoursFromTemplate() {\n    var hours = +$scope.hours;\n    var valid = $scope.showMeridian ? hours > 0 && hours < 13 :\n      hours >= 0 && hours < 24;\n    if (!valid || $scope.hours === '') {\n      return undefined;\n    }\n\n    if ($scope.showMeridian) {\n      if (hours === 12) {\n        hours = 0;\n      }\n      if ($scope.meridian === meridians[1]) {\n        hours = hours + 12;\n      }\n    }\n    return hours;\n  }\n\n  function getMinutesFromTemplate() {\n    var minutes = +$scope.minutes;\n    var valid = minutes >= 0 && minutes < 60;\n    if (!valid || $scope.minutes === '') {\n      return undefined;\n    }\n    return minutes;\n  }\n\n  function getSecondsFromTemplate() {\n    var seconds = +$scope.seconds;\n    return seconds >= 0 && seconds < 60 ? seconds : undefined;\n  }\n\n  function pad(value, noPad) {\n    if (value === null) {\n      return '';\n    }\n\n    return angular.isDefined(value) && value.toString().length < 2 && !noPad ?\n      '0' + value : value.toString();\n  }\n\n  // Respond on mousewheel spin\n  this.setupMousewheelEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {\n    var isScrollingUp = function(e) {\n      if (e.originalEvent) {\n        e = e.originalEvent;\n      }\n      //pick correct delta variable depending on event\n      var delta = e.wheelDelta ? e.wheelDelta : -e.deltaY;\n      return e.detail || delta > 0;\n    };\n\n    hoursInputEl.bind('mousewheel wheel', function(e) {\n      if (!disabled) {\n        $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());\n      }\n      e.preventDefault();\n    });\n\n    minutesInputEl.bind('mousewheel wheel', function(e) {\n      if (!disabled) {\n        $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());\n      }\n      e.preventDefault();\n    });\n\n     secondsInputEl.bind('mousewheel wheel', function(e) {\n      if (!disabled) {\n        $scope.$apply(isScrollingUp(e) ? $scope.incrementSeconds() : $scope.decrementSeconds());\n      }\n      e.preventDefault();\n    });\n  };\n\n  // Respond on up/down arrowkeys\n  this.setupArrowkeyEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {\n    hoursInputEl.bind('keydown', function(e) {\n      if (!disabled) {\n        if (e.which === 38) { // up\n          e.preventDefault();\n          $scope.incrementHours();\n          $scope.$apply();\n        } else if (e.which === 40) { // down\n          e.preventDefault();\n          $scope.decrementHours();\n          $scope.$apply();\n        }\n      }\n    });\n\n    minutesInputEl.bind('keydown', function(e) {\n      if (!disabled) {\n        if (e.which === 38) { // up\n          e.preventDefault();\n          $scope.incrementMinutes();\n          $scope.$apply();\n        } else if (e.which === 40) { // down\n          e.preventDefault();\n          $scope.decrementMinutes();\n          $scope.$apply();\n        }\n      }\n    });\n\n    secondsInputEl.bind('keydown', function(e) {\n      if (!disabled) {\n        if (e.which === 38) { // up\n          e.preventDefault();\n          $scope.incrementSeconds();\n          $scope.$apply();\n        } else if (e.which === 40) { // down\n          e.preventDefault();\n          $scope.decrementSeconds();\n          $scope.$apply();\n        }\n      }\n    });\n  };\n\n  this.setupInputEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {\n    if ($scope.readonlyInput) {\n      $scope.updateHours = angular.noop;\n      $scope.updateMinutes = angular.noop;\n      $scope.updateSeconds = angular.noop;\n      return;\n    }\n\n    var invalidate = function(invalidHours, invalidMinutes, invalidSeconds) {\n      ngModelCtrl.$setViewValue(null);\n      ngModelCtrl.$setValidity('time', false);\n      if (angular.isDefined(invalidHours)) {\n        $scope.invalidHours = invalidHours;\n      }\n\n      if (angular.isDefined(invalidMinutes)) {\n        $scope.invalidMinutes = invalidMinutes;\n      }\n\n      if (angular.isDefined(invalidSeconds)) {\n        $scope.invalidSeconds = invalidSeconds;\n      }\n    };\n\n    $scope.updateHours = function() {\n      var hours = getHoursFromTemplate(),\n        minutes = getMinutesFromTemplate();\n\n      ngModelCtrl.$setDirty();\n\n      if (angular.isDefined(hours) && angular.isDefined(minutes)) {\n        selected.setHours(hours);\n        selected.setMinutes(minutes);\n        if (selected < min || selected > max) {\n          invalidate(true);\n        } else {\n          refresh('h');\n        }\n      } else {\n        invalidate(true);\n      }\n    };\n\n    hoursInputEl.bind('blur', function(e) {\n      ngModelCtrl.$setTouched();\n      if (modelIsEmpty()) {\n        makeValid();\n      } else if ($scope.hours === null || $scope.hours === '') {\n        invalidate(true);\n      } else if (!$scope.invalidHours && $scope.hours < 10) {\n        $scope.$apply(function() {\n          $scope.hours = pad($scope.hours, !padHours);\n        });\n      }\n    });\n\n    $scope.updateMinutes = function() {\n      var minutes = getMinutesFromTemplate(),\n        hours = getHoursFromTemplate();\n\n      ngModelCtrl.$setDirty();\n\n      if (angular.isDefined(minutes) && angular.isDefined(hours)) {\n        selected.setHours(hours);\n        selected.setMinutes(minutes);\n        if (selected < min || selected > max) {\n          invalidate(undefined, true);\n        } else {\n          refresh('m');\n        }\n      } else {\n        invalidate(undefined, true);\n      }\n    };\n\n    minutesInputEl.bind('blur', function(e) {\n      ngModelCtrl.$setTouched();\n      if (modelIsEmpty()) {\n        makeValid();\n      } else if ($scope.minutes === null) {\n        invalidate(undefined, true);\n      } else if (!$scope.invalidMinutes && $scope.minutes < 10) {\n        $scope.$apply(function() {\n          $scope.minutes = pad($scope.minutes);\n        });\n      }\n    });\n\n    $scope.updateSeconds = function() {\n      var seconds = getSecondsFromTemplate();\n\n      ngModelCtrl.$setDirty();\n\n      if (angular.isDefined(seconds)) {\n        selected.setSeconds(seconds);\n        refresh('s');\n      } else {\n        invalidate(undefined, undefined, true);\n      }\n    };\n\n    secondsInputEl.bind('blur', function(e) {\n      if (modelIsEmpty()) {\n        makeValid();\n      } else if (!$scope.invalidSeconds && $scope.seconds < 10) {\n        $scope.$apply( function() {\n          $scope.seconds = pad($scope.seconds);\n        });\n      }\n    });\n\n  };\n\n  this.render = function() {\n    var date = ngModelCtrl.$viewValue;\n\n    if (isNaN(date)) {\n      ngModelCtrl.$setValidity('time', false);\n      $log.error('Timepicker directive: \"ng-model\" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');\n    } else {\n      if (date) {\n        selected = date;\n      }\n\n      if (selected < min || selected > max) {\n        ngModelCtrl.$setValidity('time', false);\n        $scope.invalidHours = true;\n        $scope.invalidMinutes = true;\n      } else {\n        makeValid();\n      }\n      updateTemplate();\n    }\n  };\n\n  // Call internally when we know that model is valid.\n  function refresh(keyboardChange) {\n    makeValid();\n    ngModelCtrl.$setViewValue(new Date(selected));\n    updateTemplate(keyboardChange);\n  }\n\n  function makeValid() {\n    ngModelCtrl.$setValidity('time', true);\n    $scope.invalidHours = false;\n    $scope.invalidMinutes = false;\n    $scope.invalidSeconds = false;\n  }\n\n  function updateTemplate(keyboardChange) {\n    if (!ngModelCtrl.$modelValue) {\n      $scope.hours = null;\n      $scope.minutes = null;\n      $scope.seconds = null;\n      $scope.meridian = meridians[0];\n    } else {\n      var hours = selected.getHours(),\n        minutes = selected.getMinutes(),\n        seconds = selected.getSeconds();\n\n      if ($scope.showMeridian) {\n        hours = hours === 0 || hours === 12 ? 12 : hours % 12; // Convert 24 to 12 hour system\n      }\n\n      $scope.hours = keyboardChange === 'h' ? hours : pad(hours, !padHours);\n      if (keyboardChange !== 'm') {\n        $scope.minutes = pad(minutes);\n      }\n      $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];\n\n      if (keyboardChange !== 's') {\n        $scope.seconds = pad(seconds);\n      }\n      $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];\n    }\n  }\n\n  function addSecondsToSelected(seconds) {\n    selected = addSeconds(selected, seconds);\n    refresh();\n  }\n\n  function addMinutes(selected, minutes) {\n    return addSeconds(selected, minutes*60);\n  }\n\n  function addSeconds(date, seconds) {\n    var dt = new Date(date.getTime() + seconds * 1000);\n    var newDate = new Date(date);\n    newDate.setHours(dt.getHours(), dt.getMinutes(), dt.getSeconds());\n    return newDate;\n  }\n\n  function modelIsEmpty() {\n    return ($scope.hours === null || $scope.hours === '') &&\n      ($scope.minutes === null || $scope.minutes === '') &&\n      (!$scope.showSeconds || $scope.showSeconds && ($scope.seconds === null || $scope.seconds === ''));\n  }\n\n  $scope.showSpinners = angular.isDefined($attrs.showSpinners) ?\n    $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners;\n\n  $scope.incrementHours = function() {\n    if (!$scope.noIncrementHours()) {\n      addSecondsToSelected(hourStep * 60 * 60);\n    }\n  };\n\n  $scope.decrementHours = function() {\n    if (!$scope.noDecrementHours()) {\n      addSecondsToSelected(-hourStep * 60 * 60);\n    }\n  };\n\n  $scope.incrementMinutes = function() {\n    if (!$scope.noIncrementMinutes()) {\n      addSecondsToSelected(minuteStep * 60);\n    }\n  };\n\n  $scope.decrementMinutes = function() {\n    if (!$scope.noDecrementMinutes()) {\n      addSecondsToSelected(-minuteStep * 60);\n    }\n  };\n\n  $scope.incrementSeconds = function() {\n    if (!$scope.noIncrementSeconds()) {\n      addSecondsToSelected(secondStep);\n    }\n  };\n\n  $scope.decrementSeconds = function() {\n    if (!$scope.noDecrementSeconds()) {\n      addSecondsToSelected(-secondStep);\n    }\n  };\n\n  $scope.toggleMeridian = function() {\n    var minutes = getMinutesFromTemplate(),\n        hours = getHoursFromTemplate();\n\n    if (!$scope.noToggleMeridian()) {\n      if (angular.isDefined(minutes) && angular.isDefined(hours)) {\n        addSecondsToSelected(12 * 60 * (selected.getHours() < 12 ? 60 : -60));\n      } else {\n        $scope.meridian = $scope.meridian === meridians[0] ? meridians[1] : meridians[0];\n      }\n    }\n  };\n\n  $scope.blur = function() {\n    ngModelCtrl.$setTouched();\n  };\n\n  $scope.$on('$destroy', function() {\n    while (watchers.length) {\n      watchers.shift()();\n    }\n  });\n}])\n\n.directive('uibTimepicker', ['uibTimepickerConfig', function(uibTimepickerConfig) {\n  return {\n    require: ['uibTimepicker', '?^ngModel'],\n    controller: 'UibTimepickerController',\n    controllerAs: 'timepicker',\n    replace: true,\n    scope: {},\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || uibTimepickerConfig.templateUrl;\n    },\n    link: function(scope, element, attrs, ctrls) {\n      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if (ngModelCtrl) {\n        timepickerCtrl.init(ngModelCtrl, element.find('input'));\n      }\n    }\n  };\n}]);\n\nangular.module('ui.bootstrap.typeahead', ['ui.bootstrap.debounce', 'ui.bootstrap.position'])\n\n/**\n * A helper service that can parse typeahead's syntax (string provided by users)\n * Extracted to a separate service for ease of unit testing\n */\n  .factory('uibTypeaheadParser', ['$parse', function($parse) {\n    //                      00000111000000000000022200000000000000003333333333333330000000000044000\n    var TYPEAHEAD_REGEXP = /^\\s*([\\s\\S]+?)(?:\\s+as\\s+([\\s\\S]+?))?\\s+for\\s+(?:([\\$\\w][\\$\\w\\d]*))\\s+in\\s+([\\s\\S]+?)$/;\n    return {\n      parse: function(input) {\n        var match = input.match(TYPEAHEAD_REGEXP);\n        if (!match) {\n          throw new Error(\n            'Expected typeahead specification in form of \"_modelValue_ (as _label_)? for _item_ in _collection_\"' +\n              ' but got \"' + input + '\".');\n        }\n\n        return {\n          itemName: match[3],\n          source: $parse(match[4]),\n          viewMapper: $parse(match[2] || match[1]),\n          modelMapper: $parse(match[1])\n        };\n      }\n    };\n  }])\n\n  .controller('UibTypeaheadController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$$debounce', '$uibPosition', 'uibTypeaheadParser',\n    function(originalScope, element, attrs, $compile, $parse, $q, $timeout, $document, $window, $rootScope, $$debounce, $position, typeaheadParser) {\n    var HOT_KEYS = [9, 13, 27, 38, 40];\n    var eventDebounceTime = 200;\n    var modelCtrl, ngModelOptions;\n    //SUPPORTED ATTRIBUTES (OPTIONS)\n\n    //minimal no of characters that needs to be entered before typeahead kicks-in\n    var minLength = originalScope.$eval(attrs.typeaheadMinLength);\n    if (!minLength && minLength !== 0) {\n      minLength = 1;\n    }\n\n    originalScope.$watch(attrs.typeaheadMinLength, function (newVal) {\n        minLength = !newVal && newVal !== 0 ? 1 : newVal;\n    });\n\n    //minimal wait time after last character typed before typeahead kicks-in\n    var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;\n\n    //should it restrict model values to the ones selected from the popup only?\n    var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;\n    originalScope.$watch(attrs.typeaheadEditable, function (newVal) {\n      isEditable = newVal !== false;\n    });\n\n    //binding to a variable that indicates if matches are being retrieved asynchronously\n    var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;\n\n    //a function to determine if an event should cause selection\n    var isSelectEvent = attrs.typeaheadShouldSelect ? $parse(attrs.typeaheadShouldSelect) : function(scope, vals) {\n      var evt = vals.$event;\n      return evt.which === 13 || evt.which === 9;\n    };\n\n    //a callback executed when a match is selected\n    var onSelectCallback = $parse(attrs.typeaheadOnSelect);\n\n    //should it select highlighted popup value when losing focus?\n    var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;\n\n    //binding to a variable that indicates if there were no results after the query is completed\n    var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;\n\n    var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;\n\n    var appendToBody = attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;\n\n    var appendTo = attrs.typeaheadAppendTo ?\n      originalScope.$eval(attrs.typeaheadAppendTo) : null;\n\n    var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;\n\n    //If input matches an item of the list exactly, select it automatically\n    var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;\n\n    //binding to a variable that indicates if dropdown is open\n    var isOpenSetter = $parse(attrs.typeaheadIsOpen).assign || angular.noop;\n\n    var showHint = originalScope.$eval(attrs.typeaheadShowHint) || false;\n\n    //INTERNAL VARIABLES\n\n    //model setter executed upon match selection\n    var parsedModel = $parse(attrs.ngModel);\n    var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');\n    var $setModelValue = function(scope, newValue) {\n      if (angular.isFunction(parsedModel(originalScope)) &&\n        ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter) {\n        return invokeModelSetter(scope, {$$$p: newValue});\n      }\n\n      return parsedModel.assign(scope, newValue);\n    };\n\n    //expressions used by typeahead\n    var parserResult = typeaheadParser.parse(attrs.uibTypeahead);\n\n    var hasFocus;\n\n    //Used to avoid bug in iOS webview where iOS keyboard does not fire\n    //mousedown & mouseup events\n    //Issue #3699\n    var selected;\n\n    //create a child scope for the typeahead directive so we are not polluting original scope\n    //with typeahead-specific data (matches, query etc.)\n    var scope = originalScope.$new();\n    var offDestroy = originalScope.$on('$destroy', function() {\n      scope.$destroy();\n    });\n    scope.$on('$destroy', offDestroy);\n\n    // WAI-ARIA\n    var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);\n    element.attr({\n      'aria-autocomplete': 'list',\n      'aria-expanded': false,\n      'aria-owns': popupId\n    });\n\n    var inputsContainer, hintInputElem;\n    //add read-only input to show hint\n    if (showHint) {\n      inputsContainer = angular.element('<div></div>');\n      inputsContainer.css('position', 'relative');\n      element.after(inputsContainer);\n      hintInputElem = element.clone();\n      hintInputElem.attr('placeholder', '');\n      hintInputElem.attr('tabindex', '-1');\n      hintInputElem.val('');\n      hintInputElem.css({\n        'position': 'absolute',\n        'top': '0px',\n        'left': '0px',\n        'border-color': 'transparent',\n        'box-shadow': 'none',\n        'opacity': 1,\n        'background': 'none 0% 0% / auto repeat scroll padding-box border-box rgb(255, 255, 255)',\n        'color': '#999'\n      });\n      element.css({\n        'position': 'relative',\n        'vertical-align': 'top',\n        'background-color': 'transparent'\n      });\n      inputsContainer.append(hintInputElem);\n      hintInputElem.after(element);\n    }\n\n    //pop-up element used to display matches\n    var popUpEl = angular.element('<div uib-typeahead-popup></div>');\n    popUpEl.attr({\n      id: popupId,\n      matches: 'matches',\n      active: 'activeIdx',\n      select: 'select(activeIdx, evt)',\n      'move-in-progress': 'moveInProgress',\n      query: 'query',\n      position: 'position',\n      'assign-is-open': 'assignIsOpen(isOpen)',\n      debounce: 'debounceUpdate'\n    });\n    //custom item template\n    if (angular.isDefined(attrs.typeaheadTemplateUrl)) {\n      popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);\n    }\n\n    if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {\n      popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);\n    }\n\n    var resetHint = function() {\n      if (showHint) {\n        hintInputElem.val('');\n      }\n    };\n\n    var resetMatches = function() {\n      scope.matches = [];\n      scope.activeIdx = -1;\n      element.attr('aria-expanded', false);\n      resetHint();\n    };\n\n    var getMatchId = function(index) {\n      return popupId + '-option-' + index;\n    };\n\n    // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.\n    // This attribute is added or removed automatically when the `activeIdx` changes.\n    scope.$watch('activeIdx', function(index) {\n      if (index < 0) {\n        element.removeAttr('aria-activedescendant');\n      } else {\n        element.attr('aria-activedescendant', getMatchId(index));\n      }\n    });\n\n    var inputIsExactMatch = function(inputValue, index) {\n      if (scope.matches.length > index && inputValue) {\n        return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();\n      }\n\n      return false;\n    };\n\n    var getMatchesAsync = function(inputValue, evt) {\n      var locals = {$viewValue: inputValue};\n      isLoadingSetter(originalScope, true);\n      isNoResultsSetter(originalScope, false);\n      $q.when(parserResult.source(originalScope, locals)).then(function(matches) {\n        //it might happen that several async queries were in progress if a user were typing fast\n        //but we are interested only in responses that correspond to the current view value\n        var onCurrentRequest = inputValue === modelCtrl.$viewValue;\n        if (onCurrentRequest && hasFocus) {\n          if (matches && matches.length > 0) {\n            scope.activeIdx = focusFirst ? 0 : -1;\n            isNoResultsSetter(originalScope, false);\n            scope.matches.length = 0;\n\n            //transform labels\n            for (var i = 0; i < matches.length; i++) {\n              locals[parserResult.itemName] = matches[i];\n              scope.matches.push({\n                id: getMatchId(i),\n                label: parserResult.viewMapper(scope, locals),\n                model: matches[i]\n              });\n            }\n\n            scope.query = inputValue;\n            //position pop-up with matches - we need to re-calculate its position each time we are opening a window\n            //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page\n            //due to other elements being rendered\n            recalculatePosition();\n\n            element.attr('aria-expanded', true);\n\n            //Select the single remaining option if user input matches\n            if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {\n              if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {\n                $$debounce(function() {\n                  scope.select(0, evt);\n                }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);\n              } else {\n                scope.select(0, evt);\n              }\n            }\n\n            if (showHint) {\n              var firstLabel = scope.matches[0].label;\n              if (angular.isString(inputValue) &&\n                inputValue.length > 0 &&\n                firstLabel.slice(0, inputValue.length).toUpperCase() === inputValue.toUpperCase()) {\n                hintInputElem.val(inputValue + firstLabel.slice(inputValue.length));\n              } else {\n                hintInputElem.val('');\n              }\n            }\n          } else {\n            resetMatches();\n            isNoResultsSetter(originalScope, true);\n          }\n        }\n        if (onCurrentRequest) {\n          isLoadingSetter(originalScope, false);\n        }\n      }, function() {\n        resetMatches();\n        isLoadingSetter(originalScope, false);\n        isNoResultsSetter(originalScope, true);\n      });\n    };\n\n    // bind events only if appendToBody params exist - performance feature\n    if (appendToBody) {\n      angular.element($window).on('resize', fireRecalculating);\n      $document.find('body').on('scroll', fireRecalculating);\n    }\n\n    // Declare the debounced function outside recalculating for\n    // proper debouncing\n    var debouncedRecalculate = $$debounce(function() {\n      // if popup is visible\n      if (scope.matches.length) {\n        recalculatePosition();\n      }\n\n      scope.moveInProgress = false;\n    }, eventDebounceTime);\n\n    // Default progress type\n    scope.moveInProgress = false;\n\n    function fireRecalculating() {\n      if (!scope.moveInProgress) {\n        scope.moveInProgress = true;\n        scope.$digest();\n      }\n\n      debouncedRecalculate();\n    }\n\n    // recalculate actual position and set new values to scope\n    // after digest loop is popup in right position\n    function recalculatePosition() {\n      scope.position = appendToBody ? $position.offset(element) : $position.position(element);\n      scope.position.top += element.prop('offsetHeight');\n    }\n\n    //we need to propagate user's query so we can higlight matches\n    scope.query = undefined;\n\n    //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later\n    var timeoutPromise;\n\n    var scheduleSearchWithTimeout = function(inputValue) {\n      timeoutPromise = $timeout(function() {\n        getMatchesAsync(inputValue);\n      }, waitTime);\n    };\n\n    var cancelPreviousTimeout = function() {\n      if (timeoutPromise) {\n        $timeout.cancel(timeoutPromise);\n      }\n    };\n\n    resetMatches();\n\n    scope.assignIsOpen = function (isOpen) {\n      isOpenSetter(originalScope, isOpen);\n    };\n\n    scope.select = function(activeIdx, evt) {\n      //called from within the $digest() cycle\n      var locals = {};\n      var model, item;\n\n      selected = true;\n      locals[parserResult.itemName] = item = scope.matches[activeIdx].model;\n      model = parserResult.modelMapper(originalScope, locals);\n      $setModelValue(originalScope, model);\n      modelCtrl.$setValidity('editable', true);\n      modelCtrl.$setValidity('parse', true);\n\n      onSelectCallback(originalScope, {\n        $item: item,\n        $model: model,\n        $label: parserResult.viewMapper(originalScope, locals),\n        $event: evt\n      });\n\n      resetMatches();\n\n      //return focus to the input element if a match was selected via a mouse click event\n      // use timeout to avoid $rootScope:inprog error\n      if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {\n        $timeout(function() { element[0].focus(); }, 0, false);\n      }\n    };\n\n    //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)\n    element.on('keydown', function(evt) {\n      //typeahead is open and an \"interesting\" key was pressed\n      if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {\n        return;\n      }\n\n      var shouldSelect = isSelectEvent(originalScope, {$event: evt});\n\n      /**\n       * if there's nothing selected (i.e. focusFirst) and enter or tab is hit\n       * or\n       * shift + tab is pressed to bring focus to the previous element\n       * then clear the results\n       */\n      if (scope.activeIdx === -1 && shouldSelect || evt.which === 9 && !!evt.shiftKey) {\n        resetMatches();\n        scope.$digest();\n        return;\n      }\n\n      evt.preventDefault();\n      var target;\n      switch (evt.which) {\n        case 27: // escape\n          evt.stopPropagation();\n\n          resetMatches();\n          originalScope.$digest();\n          break;\n        case 38: // up arrow\n          scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;\n          scope.$digest();\n          target = popUpEl.find('li')[scope.activeIdx];\n          target.parentNode.scrollTop = target.offsetTop;\n          break;\n        case 40: // down arrow\n          scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;\n          scope.$digest();\n          target = popUpEl.find('li')[scope.activeIdx];\n          target.parentNode.scrollTop = target.offsetTop;\n          break;\n        default:\n          if (shouldSelect) {\n            scope.$apply(function() {\n              if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {\n                $$debounce(function() {\n                  scope.select(scope.activeIdx, evt);\n                }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);\n              } else {\n                scope.select(scope.activeIdx, evt);\n              }\n            });\n          }\n      }\n    });\n\n    element.bind('focus', function (evt) {\n      hasFocus = true;\n      if (minLength === 0 && !modelCtrl.$viewValue) {\n        $timeout(function() {\n          getMatchesAsync(modelCtrl.$viewValue, evt);\n        }, 0);\n      }\n    });\n\n    element.bind('blur', function(evt) {\n      if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {\n        selected = true;\n        scope.$apply(function() {\n          if (angular.isObject(scope.debounceUpdate) && angular.isNumber(scope.debounceUpdate.blur)) {\n            $$debounce(function() {\n              scope.select(scope.activeIdx, evt);\n            }, scope.debounceUpdate.blur);\n          } else {\n            scope.select(scope.activeIdx, evt);\n          }\n        });\n      }\n      if (!isEditable && modelCtrl.$error.editable) {\n        modelCtrl.$setViewValue();\n        // Reset validity as we are clearing\n        modelCtrl.$setValidity('editable', true);\n        modelCtrl.$setValidity('parse', true);\n        element.val('');\n      }\n      hasFocus = false;\n      selected = false;\n    });\n\n    // Keep reference to click handler to unbind it.\n    var dismissClickHandler = function(evt) {\n      // Issue #3973\n      // Firefox treats right click as a click on document\n      if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {\n        resetMatches();\n        if (!$rootScope.$$phase) {\n          originalScope.$digest();\n        }\n      }\n    };\n\n    $document.on('click', dismissClickHandler);\n\n    originalScope.$on('$destroy', function() {\n      $document.off('click', dismissClickHandler);\n      if (appendToBody || appendTo) {\n        $popup.remove();\n      }\n\n      if (appendToBody) {\n        angular.element($window).off('resize', fireRecalculating);\n        $document.find('body').off('scroll', fireRecalculating);\n      }\n      // Prevent jQuery cache memory leak\n      popUpEl.remove();\n\n      if (showHint) {\n          inputsContainer.remove();\n      }\n    });\n\n    var $popup = $compile(popUpEl)(scope);\n\n    if (appendToBody) {\n      $document.find('body').append($popup);\n    } else if (appendTo) {\n      angular.element(appendTo).eq(0).append($popup);\n    } else {\n      element.after($popup);\n    }\n\n    this.init = function(_modelCtrl, _ngModelOptions) {\n      modelCtrl = _modelCtrl;\n      ngModelOptions = _ngModelOptions;\n\n      scope.debounceUpdate = modelCtrl.$options && $parse(modelCtrl.$options.debounce)(originalScope);\n\n      //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM\n      //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue\n      modelCtrl.$parsers.unshift(function(inputValue) {\n        hasFocus = true;\n\n        if (minLength === 0 || inputValue && inputValue.length >= minLength) {\n          if (waitTime > 0) {\n            cancelPreviousTimeout();\n            scheduleSearchWithTimeout(inputValue);\n          } else {\n            getMatchesAsync(inputValue);\n          }\n        } else {\n          isLoadingSetter(originalScope, false);\n          cancelPreviousTimeout();\n          resetMatches();\n        }\n\n        if (isEditable) {\n          return inputValue;\n        }\n\n        if (!inputValue) {\n          // Reset in case user had typed something previously.\n          modelCtrl.$setValidity('editable', true);\n          return null;\n        }\n\n        modelCtrl.$setValidity('editable', false);\n        return undefined;\n      });\n\n      modelCtrl.$formatters.push(function(modelValue) {\n        var candidateViewValue, emptyViewValue;\n        var locals = {};\n\n        // The validity may be set to false via $parsers (see above) if\n        // the model is restricted to selected values. If the model\n        // is set manually it is considered to be valid.\n        if (!isEditable) {\n          modelCtrl.$setValidity('editable', true);\n        }\n\n        if (inputFormatter) {\n          locals.$model = modelValue;\n          return inputFormatter(originalScope, locals);\n        }\n\n        //it might happen that we don't have enough info to properly render input value\n        //we need to check for this situation and simply return model value if we can't apply custom formatting\n        locals[parserResult.itemName] = modelValue;\n        candidateViewValue = parserResult.viewMapper(originalScope, locals);\n        locals[parserResult.itemName] = undefined;\n        emptyViewValue = parserResult.viewMapper(originalScope, locals);\n\n        return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;\n      });\n    };\n  }])\n\n  .directive('uibTypeahead', function() {\n    return {\n      controller: 'UibTypeaheadController',\n      require: ['ngModel', '^?ngModelOptions', 'uibTypeahead'],\n      link: function(originalScope, element, attrs, ctrls) {\n        ctrls[2].init(ctrls[0], ctrls[1]);\n      }\n    };\n  })\n\n  .directive('uibTypeaheadPopup', ['$$debounce', function($$debounce) {\n    return {\n      scope: {\n        matches: '=',\n        query: '=',\n        active: '=',\n        position: '&',\n        moveInProgress: '=',\n        select: '&',\n        assignIsOpen: '&',\n        debounce: '&'\n      },\n      replace: true,\n      templateUrl: function(element, attrs) {\n        return attrs.popupTemplateUrl || 'uib/template/typeahead/typeahead-popup.html';\n      },\n      link: function(scope, element, attrs) {\n        scope.templateUrl = attrs.templateUrl;\n\n        scope.isOpen = function() {\n          var isDropdownOpen = scope.matches.length > 0;\n          scope.assignIsOpen({ isOpen: isDropdownOpen });\n          return isDropdownOpen;\n        };\n\n        scope.isActive = function(matchIdx) {\n          return scope.active === matchIdx;\n        };\n\n        scope.selectActive = function(matchIdx) {\n          scope.active = matchIdx;\n        };\n\n        scope.selectMatch = function(activeIdx, evt) {\n          var debounce = scope.debounce();\n          if (angular.isNumber(debounce) || angular.isObject(debounce)) {\n            $$debounce(function() {\n              scope.select({activeIdx: activeIdx, evt: evt});\n            }, angular.isNumber(debounce) ? debounce : debounce['default']);\n          } else {\n            scope.select({activeIdx: activeIdx, evt: evt});\n          }\n        };\n      }\n    };\n  }])\n\n  .directive('uibTypeaheadMatch', ['$templateRequest', '$compile', '$parse', function($templateRequest, $compile, $parse) {\n    return {\n      scope: {\n        index: '=',\n        match: '=',\n        query: '='\n      },\n      link: function(scope, element, attrs) {\n        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'uib/template/typeahead/typeahead-match.html';\n        $templateRequest(tplUrl).then(function(tplContent) {\n          var tplEl = angular.element(tplContent.trim());\n          element.replaceWith(tplEl);\n          $compile(tplEl)(scope);\n        });\n      }\n    };\n  }])\n\n  .filter('uibTypeaheadHighlight', ['$sce', '$injector', '$log', function($sce, $injector, $log) {\n    var isSanitizePresent;\n    isSanitizePresent = $injector.has('$sanitize');\n\n    function escapeRegexp(queryToEscape) {\n      // Regex: capture the whole query string and replace it with the string that will be used to match\n      // the results, for example if the capture is \"a\" the result will be \\a\n      return queryToEscape.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n    }\n\n    function containsHtml(matchItem) {\n      return /<.*>/g.test(matchItem);\n    }\n\n    return function(matchItem, query) {\n      if (!isSanitizePresent && containsHtml(matchItem)) {\n        $log.warn('Unsafe use of typeahead please use ngSanitize'); // Warn the user about the danger\n      }\n      matchItem = query ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem; // Replaces the capture string with a the same string inside of a \"strong\" tag\n      if (!isSanitizePresent) {\n        matchItem = $sce.trustAsHtml(matchItem); // If $sanitize is not present we pack the string in a $sce object for the ng-bind-html directive\n      }\n      return matchItem;\n    };\n  }]);\n\nangular.module(\"uib/template/accordion/accordion-group.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/accordion/accordion-group.html\",\n    \"<div class=\\\"panel\\\" ng-class=\\\"panelClass || 'panel-default'\\\">\\n\" +\n    \"  <div role=\\\"tab\\\" id=\\\"{{::headingId}}\\\" aria-selected=\\\"{{isOpen}}\\\" class=\\\"panel-heading\\\" ng-keypress=\\\"toggleOpen($event)\\\">\\n\" +\n    \"    <h4 class=\\\"panel-title\\\">\\n\" +\n    \"      <a role=\\\"button\\\" data-toggle=\\\"collapse\\\" href aria-expanded=\\\"{{isOpen}}\\\" aria-controls=\\\"{{::panelId}}\\\" tabindex=\\\"0\\\" class=\\\"accordion-toggle\\\" ng-click=\\\"toggleOpen()\\\" uib-accordion-transclude=\\\"heading\\\"><span uib-accordion-header ng-class=\\\"{'text-muted': isDisabled}\\\">{{heading}}</span></a>\\n\" +\n    \"    </h4>\\n\" +\n    \"  </div>\\n\" +\n    \"  <div id=\\\"{{::panelId}}\\\" aria-labelledby=\\\"{{::headingId}}\\\" aria-hidden=\\\"{{!isOpen}}\\\" role=\\\"tabpanel\\\" class=\\\"panel-collapse collapse\\\" uib-collapse=\\\"!isOpen\\\">\\n\" +\n    \"    <div class=\\\"panel-body\\\" ng-transclude></div>\\n\" +\n    \"  </div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/accordion/accordion.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/accordion/accordion.html\",\n    \"<div role=\\\"tablist\\\" class=\\\"panel-group\\\" ng-transclude></div>\");\n}]);\n\nangular.module(\"uib/template/alert/alert.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/alert/alert.html\",\n    \"<div class=\\\"alert\\\" ng-class=\\\"['alert-' + (type || 'warning'), closeable ? 'alert-dismissible' : null]\\\" role=\\\"alert\\\">\\n\" +\n    \"    <button ng-show=\\\"closeable\\\" type=\\\"button\\\" class=\\\"close\\\" ng-click=\\\"close({$event: $event})\\\">\\n\" +\n    \"        <span aria-hidden=\\\"true\\\">&times;</span>\\n\" +\n    \"        <span class=\\\"sr-only\\\">Close</span>\\n\" +\n    \"    </button>\\n\" +\n    \"    <div ng-transclude></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/carousel/carousel.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/carousel/carousel.html\",\n    \"<div ng-mouseenter=\\\"pause()\\\" ng-mouseleave=\\\"play()\\\" class=\\\"carousel\\\" ng-swipe-right=\\\"prev()\\\" ng-swipe-left=\\\"next()\\\">\\n\" +\n    \"  <div class=\\\"carousel-inner\\\" ng-transclude></div>\\n\" +\n    \"  <a role=\\\"button\\\" href class=\\\"left carousel-control\\\" ng-click=\\\"prev()\\\" ng-class=\\\"{ disabled: isPrevDisabled() }\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n    \"    <span aria-hidden=\\\"true\\\" class=\\\"glyphicon glyphicon-chevron-left\\\"></span>\\n\" +\n    \"    <span class=\\\"sr-only\\\">previous</span>\\n\" +\n    \"  </a>\\n\" +\n    \"  <a role=\\\"button\\\" href class=\\\"right carousel-control\\\" ng-click=\\\"next()\\\" ng-class=\\\"{ disabled: isNextDisabled() }\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n    \"    <span aria-hidden=\\\"true\\\" class=\\\"glyphicon glyphicon-chevron-right\\\"></span>\\n\" +\n    \"    <span class=\\\"sr-only\\\">next</span>\\n\" +\n    \"  </a>\\n\" +\n    \"  <ol class=\\\"carousel-indicators\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n    \"    <li ng-repeat=\\\"slide in slides | orderBy:indexOfSlide track by $index\\\" ng-class=\\\"{ active: isActive(slide) }\\\" ng-click=\\\"select(slide)\\\">\\n\" +\n    \"      <span class=\\\"sr-only\\\">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if=\\\"isActive(slide)\\\">, currently active</span></span>\\n\" +\n    \"    </li>\\n\" +\n    \"  </ol>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/carousel/slide.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/carousel/slide.html\",\n    \"<div ng-class=\\\"{\\n\" +\n    \"    'active': active\\n\" +\n    \"  }\\\" class=\\\"item text-center\\\" ng-transclude></div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/datepicker/datepicker.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/datepicker/datepicker.html\",\n    \"<div class=\\\"uib-datepicker\\\" ng-switch=\\\"datepickerMode\\\" role=\\\"application\\\" ng-keydown=\\\"keydown($event)\\\">\\n\" +\n    \"  <uib-daypicker ng-switch-when=\\\"day\\\" tabindex=\\\"0\\\"></uib-daypicker>\\n\" +\n    \"  <uib-monthpicker ng-switch-when=\\\"month\\\" tabindex=\\\"0\\\"></uib-monthpicker>\\n\" +\n    \"  <uib-yearpicker ng-switch-when=\\\"year\\\" tabindex=\\\"0\\\"></uib-yearpicker>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/datepicker/day.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/datepicker/day.html\",\n    \"<table class=\\\"uib-daypicker\\\" role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n    \"  <thead>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left uib-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\n    \"      <th colspan=\\\"{{::5 + showWeeks}}\\\"><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm uib-title\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\"><strong>{{title}}</strong></button></th>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right uib-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\n    \"    </tr>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <th ng-if=\\\"showWeeks\\\" class=\\\"text-center\\\"></th>\\n\" +\n    \"      <th ng-repeat=\\\"label in ::labels track by $index\\\" class=\\\"text-center\\\"><small aria-label=\\\"{{::label.full}}\\\">{{::label.abbr}}</small></th>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </thead>\\n\" +\n    \"  <tbody>\\n\" +\n    \"    <tr class=\\\"uib-weeks\\\" ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\n    \"      <td ng-if=\\\"showWeeks\\\" class=\\\"text-center h6\\\"><em>{{ weekNumbers[$index] }}</em></td>\\n\" +\n    \"      <td ng-repeat=\\\"dt in row\\\" class=\\\"uib-day text-center\\\" role=\\\"gridcell\\\"\\n\" +\n    \"        id=\\\"{{::dt.uid}}\\\"\\n\" +\n    \"        ng-class=\\\"::dt.customClass\\\">\\n\" +\n    \"        <button type=\\\"button\\\" class=\\\"btn btn-default btn-sm\\\"\\n\" +\n    \"          uib-is-class=\\\"\\n\" +\n    \"            'btn-info' for selectedDt,\\n\" +\n    \"            'active' for activeDt\\n\" +\n    \"            on dt\\\"\\n\" +\n    \"          ng-click=\\\"select(dt.date)\\\"\\n\" +\n    \"          ng-disabled=\\\"::dt.disabled\\\"\\n\" +\n    \"          tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-muted': dt.secondary, 'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\n    \"      </td>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </tbody>\\n\" +\n    \"</table>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/datepicker/month.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/datepicker/month.html\",\n    \"<table class=\\\"uib-monthpicker\\\" role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n    \"  <thead>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left uib-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\n    \"      <th><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm uib-title\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\"><strong>{{title}}</strong></button></th>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right uib-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </thead>\\n\" +\n    \"  <tbody>\\n\" +\n    \"    <tr class=\\\"uib-months\\\" ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\n    \"      <td ng-repeat=\\\"dt in row\\\" class=\\\"uib-month text-center\\\" role=\\\"gridcell\\\"\\n\" +\n    \"        id=\\\"{{::dt.uid}}\\\"\\n\" +\n    \"        ng-class=\\\"::dt.customClass\\\">\\n\" +\n    \"        <button type=\\\"button\\\" class=\\\"btn btn-default\\\"\\n\" +\n    \"          uib-is-class=\\\"\\n\" +\n    \"            'btn-info' for selectedDt,\\n\" +\n    \"            'active' for activeDt\\n\" +\n    \"            on dt\\\"\\n\" +\n    \"          ng-click=\\\"select(dt.date)\\\"\\n\" +\n    \"          ng-disabled=\\\"::dt.disabled\\\"\\n\" +\n    \"          tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\n    \"      </td>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </tbody>\\n\" +\n    \"</table>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/datepicker/year.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/datepicker/year.html\",\n    \"<table class=\\\"uib-yearpicker\\\" role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n    \"  <thead>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left uib-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\n    \"      <th colspan=\\\"{{::columns - 2}}\\\"><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm uib-title\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\"><strong>{{title}}</strong></button></th>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right uib-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </thead>\\n\" +\n    \"  <tbody>\\n\" +\n    \"    <tr class=\\\"uib-years\\\" ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\n    \"      <td ng-repeat=\\\"dt in row\\\" class=\\\"uib-year text-center\\\" role=\\\"gridcell\\\"\\n\" +\n    \"        id=\\\"{{::dt.uid}}\\\"\\n\" +\n    \"        ng-class=\\\"::dt.customClass\\\">\\n\" +\n    \"        <button type=\\\"button\\\" class=\\\"btn btn-default\\\"\\n\" +\n    \"          uib-is-class=\\\"\\n\" +\n    \"            'btn-info' for selectedDt,\\n\" +\n    \"            'active' for activeDt\\n\" +\n    \"            on dt\\\"\\n\" +\n    \"          ng-click=\\\"select(dt.date)\\\"\\n\" +\n    \"          ng-disabled=\\\"::dt.disabled\\\"\\n\" +\n    \"          tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\n    \"      </td>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </tbody>\\n\" +\n    \"</table>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/datepickerPopup/popup.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/datepickerPopup/popup.html\",\n    \"<div>\\n\" +\n    \"  <ul class=\\\"uib-datepicker-popup dropdown-menu uib-position-measure\\\" dropdown-nested ng-if=\\\"isOpen\\\" ng-keydown=\\\"keydown($event)\\\" ng-click=\\\"$event.stopPropagation()\\\">\\n\" +\n    \"    <li ng-transclude></li>\\n\" +\n    \"    <li ng-if=\\\"showButtonBar\\\" class=\\\"uib-button-bar\\\">\\n\" +\n    \"      <span class=\\\"btn-group pull-left\\\">\\n\" +\n    \"        <button type=\\\"button\\\" class=\\\"btn btn-sm btn-info uib-datepicker-current\\\" ng-click=\\\"select('today', $event)\\\" ng-disabled=\\\"isDisabled('today')\\\">{{ getText('current') }}</button>\\n\" +\n    \"        <button type=\\\"button\\\" class=\\\"btn btn-sm btn-danger uib-clear\\\" ng-click=\\\"select(null, $event)\\\">{{ getText('clear') }}</button>\\n\" +\n    \"      </span>\\n\" +\n    \"      <button type=\\\"button\\\" class=\\\"btn btn-sm btn-success pull-right uib-close\\\" ng-click=\\\"close($event)\\\">{{ getText('close') }}</button>\\n\" +\n    \"    </li>\\n\" +\n    \"  </ul>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/modal/backdrop.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/modal/backdrop.html\",\n    \"<div class=\\\"modal-backdrop\\\"\\n\" +\n    \"     uib-modal-animation-class=\\\"fade\\\"\\n\" +\n    \"     modal-in-class=\\\"in\\\"\\n\" +\n    \"     ng-style=\\\"{'z-index': 1040 + (index && 1 || 0) + index*10}\\\"\\n\" +\n    \"></div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/modal/window.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/modal/window.html\",\n    \"<div modal-render=\\\"{{$isRendered}}\\\" tabindex=\\\"-1\\\" role=\\\"dialog\\\" class=\\\"modal\\\"\\n\" +\n    \"    uib-modal-animation-class=\\\"fade\\\"\\n\" +\n    \"    modal-in-class=\\\"in\\\"\\n\" +\n    \"    ng-style=\\\"{'z-index': 1050 + index*10, display: 'block'}\\\">\\n\" +\n    \"    <div class=\\\"modal-dialog {{size ? 'modal-' + size : ''}}\\\"><div class=\\\"modal-content\\\" uib-modal-transclude></div></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/pager/pager.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/pager/pager.html\",\n    \"<ul class=\\\"pager\\\">\\n\" +\n    \"  <li ng-class=\\\"{disabled: noPrevious()||ngDisabled, previous: align}\\\"><a href ng-click=\\\"selectPage(page - 1, $event)\\\">{{::getText('previous')}}</a></li>\\n\" +\n    \"  <li ng-class=\\\"{disabled: noNext()||ngDisabled, next: align}\\\"><a href ng-click=\\\"selectPage(page + 1, $event)\\\">{{::getText('next')}}</a></li>\\n\" +\n    \"</ul>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/pagination/pagination.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/pagination/pagination.html\",\n    \"<ul class=\\\"pagination\\\">\\n\" +\n    \"  <li ng-if=\\\"::boundaryLinks\\\" ng-class=\\\"{disabled: noPrevious()||ngDisabled}\\\" class=\\\"pagination-first\\\"><a href ng-click=\\\"selectPage(1, $event)\\\">{{::getText('first')}}</a></li>\\n\" +\n    \"  <li ng-if=\\\"::directionLinks\\\" ng-class=\\\"{disabled: noPrevious()||ngDisabled}\\\" class=\\\"pagination-prev\\\"><a href ng-click=\\\"selectPage(page - 1, $event)\\\">{{::getText('previous')}}</a></li>\\n\" +\n    \"  <li ng-repeat=\\\"page in pages track by $index\\\" ng-class=\\\"{active: page.active,disabled: ngDisabled&&!page.active}\\\" class=\\\"pagination-page\\\"><a href ng-click=\\\"selectPage(page.number, $event)\\\">{{page.text}}</a></li>\\n\" +\n    \"  <li ng-if=\\\"::directionLinks\\\" ng-class=\\\"{disabled: noNext()||ngDisabled}\\\" class=\\\"pagination-next\\\"><a href ng-click=\\\"selectPage(page + 1, $event)\\\">{{::getText('next')}}</a></li>\\n\" +\n    \"  <li ng-if=\\\"::boundaryLinks\\\" ng-class=\\\"{disabled: noNext()||ngDisabled}\\\" class=\\\"pagination-last\\\"><a href ng-click=\\\"selectPage(totalPages, $event)\\\">{{::getText('last')}}</a></li>\\n\" +\n    \"</ul>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/tooltip/tooltip-html-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/tooltip/tooltip-html-popup.html\",\n    \"<div class=\\\"tooltip\\\"\\n\" +\n    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n    \"  uib-tooltip-classes\\n\" +\n    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n    \"  <div class=\\\"tooltip-inner\\\" ng-bind-html=\\\"contentExp()\\\"></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/tooltip/tooltip-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/tooltip/tooltip-popup.html\",\n    \"<div class=\\\"tooltip\\\"\\n\" +\n    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n    \"  uib-tooltip-classes\\n\" +\n    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n    \"  <div class=\\\"tooltip-inner\\\" ng-bind=\\\"content\\\"></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/tooltip/tooltip-template-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/tooltip/tooltip-template-popup.html\",\n    \"<div class=\\\"tooltip\\\"\\n\" +\n    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n    \"  uib-tooltip-classes\\n\" +\n    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n    \"  <div class=\\\"tooltip-inner\\\"\\n\" +\n    \"    uib-tooltip-template-transclude=\\\"contentExp()\\\"\\n\" +\n    \"    tooltip-template-transclude-scope=\\\"originScope()\\\"></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/popover/popover-html.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/popover/popover-html.html\",\n    \"<div class=\\\"popover\\\"\\n\" +\n    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n    \"  uib-tooltip-classes\\n\" +\n    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n    \"  <div class=\\\"arrow\\\"></div>\\n\" +\n    \"\\n\" +\n    \"  <div class=\\\"popover-inner\\\">\\n\" +\n    \"      <h3 class=\\\"popover-title\\\" ng-bind=\\\"uibTitle\\\" ng-if=\\\"uibTitle\\\"></h3>\\n\" +\n    \"      <div class=\\\"popover-content\\\" ng-bind-html=\\\"contentExp()\\\"></div>\\n\" +\n    \"  </div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/popover/popover-template.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/popover/popover-template.html\",\n    \"<div class=\\\"popover\\\"\\n\" +\n    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n    \"  uib-tooltip-classes\\n\" +\n    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n    \"  <div class=\\\"arrow\\\"></div>\\n\" +\n    \"\\n\" +\n    \"  <div class=\\\"popover-inner\\\">\\n\" +\n    \"      <h3 class=\\\"popover-title\\\" ng-bind=\\\"uibTitle\\\" ng-if=\\\"uibTitle\\\"></h3>\\n\" +\n    \"      <div class=\\\"popover-content\\\"\\n\" +\n    \"        uib-tooltip-template-transclude=\\\"contentExp()\\\"\\n\" +\n    \"        tooltip-template-transclude-scope=\\\"originScope()\\\"></div>\\n\" +\n    \"  </div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/popover/popover.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/popover/popover.html\",\n    \"<div class=\\\"popover\\\"\\n\" +\n    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n    \"  uib-tooltip-classes\\n\" +\n    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n    \"  <div class=\\\"arrow\\\"></div>\\n\" +\n    \"\\n\" +\n    \"  <div class=\\\"popover-inner\\\">\\n\" +\n    \"      <h3 class=\\\"popover-title\\\" ng-bind=\\\"uibTitle\\\" ng-if=\\\"uibTitle\\\"></h3>\\n\" +\n    \"      <div class=\\\"popover-content\\\" ng-bind=\\\"content\\\"></div>\\n\" +\n    \"  </div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/progressbar/bar.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/progressbar/bar.html\",\n    \"<div class=\\\"progress-bar\\\" ng-class=\\\"type && 'progress-bar-' + type\\\" role=\\\"progressbar\\\" aria-valuenow=\\\"{{value}}\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{max}}\\\" ng-style=\\\"{width: (percent < 100 ? percent : 100) + '%'}\\\" aria-valuetext=\\\"{{percent | number:0}}%\\\" aria-labelledby=\\\"{{::title}}\\\" ng-transclude></div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/progressbar/progress.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/progressbar/progress.html\",\n    \"<div class=\\\"progress\\\" ng-transclude aria-labelledby=\\\"{{::title}}\\\"></div>\");\n}]);\n\nangular.module(\"uib/template/progressbar/progressbar.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/progressbar/progressbar.html\",\n    \"<div class=\\\"progress\\\">\\n\" +\n    \"  <div class=\\\"progress-bar\\\" ng-class=\\\"type && 'progress-bar-' + type\\\" role=\\\"progressbar\\\" aria-valuenow=\\\"{{value}}\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{max}}\\\" ng-style=\\\"{width: (percent < 100 ? percent : 100) + '%'}\\\" aria-valuetext=\\\"{{percent | number:0}}%\\\" aria-labelledby=\\\"{{::title}}\\\" ng-transclude></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/rating/rating.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/rating/rating.html\",\n    \"<span ng-mouseleave=\\\"reset()\\\" ng-keydown=\\\"onKeydown($event)\\\" tabindex=\\\"0\\\" role=\\\"slider\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{range.length}}\\\" aria-valuenow=\\\"{{value}}\\\" aria-valuetext=\\\"{{title}}\\\">\\n\" +\n    \"    <span ng-repeat-start=\\\"r in range track by $index\\\" class=\\\"sr-only\\\">({{ $index < value ? '*' : ' ' }})</span>\\n\" +\n    \"    <i ng-repeat-end ng-mouseenter=\\\"enter($index + 1)\\\" ng-click=\\\"rate($index + 1)\\\" class=\\\"glyphicon\\\" ng-class=\\\"$index < value && (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\\\" ng-attr-title=\\\"{{r.title}}\\\"></i>\\n\" +\n    \"</span>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/tabs/tab.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/tabs/tab.html\",\n    \"<li ng-class=\\\"[{active: active, disabled: disabled}, classes]\\\" class=\\\"uib-tab nav-item\\\">\\n\" +\n    \"  <a href ng-click=\\\"select($event)\\\" class=\\\"nav-link\\\" uib-tab-heading-transclude>{{heading}}</a>\\n\" +\n    \"</li>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/tabs/tabset.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/tabs/tabset.html\",\n    \"<div>\\n\" +\n    \"  <ul class=\\\"nav nav-{{tabset.type || 'tabs'}}\\\" ng-class=\\\"{'nav-stacked': vertical, 'nav-justified': justified}\\\" ng-transclude></ul>\\n\" +\n    \"  <div class=\\\"tab-content\\\">\\n\" +\n    \"    <div class=\\\"tab-pane\\\"\\n\" +\n    \"         ng-repeat=\\\"tab in tabset.tabs\\\"\\n\" +\n    \"         ng-class=\\\"{active: tabset.active === tab.index}\\\"\\n\" +\n    \"         uib-tab-content-transclude=\\\"tab\\\">\\n\" +\n    \"    </div>\\n\" +\n    \"  </div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/timepicker/timepicker.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/timepicker/timepicker.html\",\n    \"<table class=\\\"uib-timepicker\\\">\\n\" +\n    \"  <tbody>\\n\" +\n    \"    <tr class=\\\"text-center\\\" ng-show=\\\"::showSpinners\\\">\\n\" +\n    \"      <td class=\\\"uib-increment hours\\\"><a ng-click=\\\"incrementHours()\\\" ng-class=\\\"{disabled: noIncrementHours()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noIncrementHours()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-up\\\"></span></a></td>\\n\" +\n    \"      <td>&nbsp;</td>\\n\" +\n    \"      <td class=\\\"uib-increment minutes\\\"><a ng-click=\\\"incrementMinutes()\\\" ng-class=\\\"{disabled: noIncrementMinutes()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noIncrementMinutes()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-up\\\"></span></a></td>\\n\" +\n    \"      <td ng-show=\\\"showSeconds\\\">&nbsp;</td>\\n\" +\n    \"      <td ng-show=\\\"showSeconds\\\" class=\\\"uib-increment seconds\\\"><a ng-click=\\\"incrementSeconds()\\\" ng-class=\\\"{disabled: noIncrementSeconds()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noIncrementSeconds()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-up\\\"></span></a></td>\\n\" +\n    \"      <td ng-show=\\\"showMeridian\\\"></td>\\n\" +\n    \"    </tr>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <td class=\\\"form-group uib-time hours\\\" ng-class=\\\"{'has-error': invalidHours}\\\">\\n\" +\n    \"        <input type=\\\"text\\\" placeholder=\\\"HH\\\" ng-model=\\\"hours\\\" ng-change=\\\"updateHours()\\\" class=\\\"form-control text-center\\\" ng-readonly=\\\"::readonlyInput\\\" maxlength=\\\"2\\\" tabindex=\\\"{{::tabindex}}\\\" ng-disabled=\\\"noIncrementHours()\\\" ng-blur=\\\"blur()\\\">\\n\" +\n    \"      </td>\\n\" +\n    \"      <td class=\\\"uib-separator\\\">:</td>\\n\" +\n    \"      <td class=\\\"form-group uib-time minutes\\\" ng-class=\\\"{'has-error': invalidMinutes}\\\">\\n\" +\n    \"        <input type=\\\"text\\\" placeholder=\\\"MM\\\" ng-model=\\\"minutes\\\" ng-change=\\\"updateMinutes()\\\" class=\\\"form-control text-center\\\" ng-readonly=\\\"::readonlyInput\\\" maxlength=\\\"2\\\" tabindex=\\\"{{::tabindex}}\\\" ng-disabled=\\\"noIncrementMinutes()\\\" ng-blur=\\\"blur()\\\">\\n\" +\n    \"      </td>\\n\" +\n    \"      <td ng-show=\\\"showSeconds\\\" class=\\\"uib-separator\\\">:</td>\\n\" +\n    \"      <td class=\\\"form-group uib-time seconds\\\" ng-class=\\\"{'has-error': invalidSeconds}\\\" ng-show=\\\"showSeconds\\\">\\n\" +\n    \"        <input type=\\\"text\\\" placeholder=\\\"SS\\\" ng-model=\\\"seconds\\\" ng-change=\\\"updateSeconds()\\\" class=\\\"form-control text-center\\\" ng-readonly=\\\"readonlyInput\\\" maxlength=\\\"2\\\" tabindex=\\\"{{::tabindex}}\\\" ng-disabled=\\\"noIncrementSeconds()\\\" ng-blur=\\\"blur()\\\">\\n\" +\n    \"      </td>\\n\" +\n    \"      <td ng-show=\\\"showMeridian\\\" class=\\\"uib-time am-pm\\\"><button type=\\\"button\\\" ng-class=\\\"{disabled: noToggleMeridian()}\\\" class=\\\"btn btn-default text-center\\\" ng-click=\\\"toggleMeridian()\\\" ng-disabled=\\\"noToggleMeridian()\\\" tabindex=\\\"{{::tabindex}}\\\">{{meridian}}</button></td>\\n\" +\n    \"    </tr>\\n\" +\n    \"    <tr class=\\\"text-center\\\" ng-show=\\\"::showSpinners\\\">\\n\" +\n    \"      <td class=\\\"uib-decrement hours\\\"><a ng-click=\\\"decrementHours()\\\" ng-class=\\\"{disabled: noDecrementHours()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noDecrementHours()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-down\\\"></span></a></td>\\n\" +\n    \"      <td>&nbsp;</td>\\n\" +\n    \"      <td class=\\\"uib-decrement minutes\\\"><a ng-click=\\\"decrementMinutes()\\\" ng-class=\\\"{disabled: noDecrementMinutes()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noDecrementMinutes()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-down\\\"></span></a></td>\\n\" +\n    \"      <td ng-show=\\\"showSeconds\\\">&nbsp;</td>\\n\" +\n    \"      <td ng-show=\\\"showSeconds\\\" class=\\\"uib-decrement seconds\\\"><a ng-click=\\\"decrementSeconds()\\\" ng-class=\\\"{disabled: noDecrementSeconds()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noDecrementSeconds()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-down\\\"></span></a></td>\\n\" +\n    \"      <td ng-show=\\\"showMeridian\\\"></td>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </tbody>\\n\" +\n    \"</table>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/typeahead/typeahead-match.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/typeahead/typeahead-match.html\",\n    \"<a href\\n\" +\n    \"   tabindex=\\\"-1\\\"\\n\" +\n    \"   ng-bind-html=\\\"match.label | uibTypeaheadHighlight:query\\\"\\n\" +\n    \"   ng-attr-title=\\\"{{match.label}}\\\"></a>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/typeahead/typeahead-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/typeahead/typeahead-popup.html\",\n    \"<ul class=\\\"dropdown-menu\\\" ng-show=\\\"isOpen() && !moveInProgress\\\" ng-style=\\\"{top: position().top+'px', left: position().left+'px'}\\\" role=\\\"listbox\\\" aria-hidden=\\\"{{!isOpen()}}\\\">\\n\" +\n    \"    <li ng-repeat=\\\"match in matches track by $index\\\" ng-class=\\\"{active: isActive($index) }\\\" ng-mouseenter=\\\"selectActive($index)\\\" ng-click=\\\"selectMatch($index, $event)\\\" role=\\\"option\\\" id=\\\"{{::match.id}}\\\">\\n\" +\n    \"        <div uib-typeahead-match index=\\\"$index\\\" match=\\\"match\\\" query=\\\"query\\\" template-url=\\\"templateUrl\\\"></div>\\n\" +\n    \"    </li>\\n\" +\n    \"</ul>\\n\" +\n    \"\");\n}]);\nangular.module('ui.bootstrap.carousel').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibCarouselCss && angular.element(document).find('head').prepend('<style type=\"text/css\">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>'); angular.$$uibCarouselCss = true; });\nangular.module('ui.bootstrap.datepicker').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibDatepickerCss && angular.element(document).find('head').prepend('<style type=\"text/css\">.uib-datepicker .uib-title{width:100%;}.uib-day button,.uib-month button,.uib-year button{min-width:100%;}.uib-left,.uib-right{width:100%}</style>'); angular.$$uibDatepickerCss = true; });\nangular.module('ui.bootstrap.position').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibPositionCss && angular.element(document).find('head').prepend('<style type=\"text/css\">.uib-position-measure{display:block !important;visibility:hidden !important;position:absolute !important;top:-9999px !important;left:-9999px !important;}.uib-position-scrollbar-measure{position:absolute !important;top:-9999px !important;width:50px !important;height:50px !important;overflow:scroll !important;}.uib-position-body-scrollbar-measure{overflow:scroll !important;}</style>'); angular.$$uibPositionCss = true; });\nangular.module('ui.bootstrap.datepickerPopup').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibDatepickerpopupCss && angular.element(document).find('head').prepend('<style type=\"text/css\">.uib-datepicker-popup.dropdown-menu{display:block;float:none;margin:0;}.uib-button-bar{padding:10px 9px 2px;}</style>'); angular.$$uibDatepickerpopupCss = true; });\nangular.module('ui.bootstrap.tooltip').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibTooltipCss && angular.element(document).find('head').prepend('<style type=\"text/css\">[uib-tooltip-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-bottom > .tooltip-arrow,[uib-popover-popup].popover.top-left > .arrow,[uib-popover-popup].popover.top-right > .arrow,[uib-popover-popup].popover.bottom-left > .arrow,[uib-popover-popup].popover.bottom-right > .arrow,[uib-popover-popup].popover.left-top > .arrow,[uib-popover-popup].popover.left-bottom > .arrow,[uib-popover-popup].popover.right-top > .arrow,[uib-popover-popup].popover.right-bottom > .arrow,[uib-popover-html-popup].popover.top-left > .arrow,[uib-popover-html-popup].popover.top-right > .arrow,[uib-popover-html-popup].popover.bottom-left > .arrow,[uib-popover-html-popup].popover.bottom-right > .arrow,[uib-popover-html-popup].popover.left-top > .arrow,[uib-popover-html-popup].popover.left-bottom > .arrow,[uib-popover-html-popup].popover.right-top > .arrow,[uib-popover-html-popup].popover.right-bottom > .arrow,[uib-popover-template-popup].popover.top-left > .arrow,[uib-popover-template-popup].popover.top-right > .arrow,[uib-popover-template-popup].popover.bottom-left > .arrow,[uib-popover-template-popup].popover.bottom-right > .arrow,[uib-popover-template-popup].popover.left-top > .arrow,[uib-popover-template-popup].popover.left-bottom > .arrow,[uib-popover-template-popup].popover.right-top > .arrow,[uib-popover-template-popup].popover.right-bottom > .arrow{top:auto;bottom:auto;left:auto;right:auto;margin:0;}[uib-popover-popup].popover,[uib-popover-html-popup].popover,[uib-popover-template-popup].popover{display:block !important;}</style>'); angular.$$uibTooltipCss = true; });\nangular.module('ui.bootstrap.timepicker').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibTimepickerCss && angular.element(document).find('head').prepend('<style type=\"text/css\">.uib-time input{width:50px;}</style>'); angular.$$uibTimepickerCss = true; });\nangular.module('ui.bootstrap.typeahead').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibTypeaheadCss && angular.element(document).find('head').prepend('<style type=\"text/css\">[uib-typeahead-popup].dropdown-menu{display:block;}</style>'); angular.$$uibTypeaheadCss = true; });\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-ui-bootstrap/dist/ui-bootstrap-tpls.js\n ** module id = 8\n ** module chunks = 0\n **/","export default function routes($stateProvider) {\r\n\t$stateProvider\r\n\t\t.state('weather', {\r\n\t\t\turl: '/',\r\n\t\t\ttemplate: require('./weather.html'),\r\n\t\t\tcontroller: 'WeatherCtrl',\r\n\t\t\tcontrollerAs: 'weather'\r\n\t\t});\r\n}\r\n\r\nroutes.$inject = ['$stateProvider'];\n\n\n/** WEBPACK FOOTER **\n ** ./app/weather/weather.routes.js\n **/","module.exports = \"<div> {{weather.forecast.query.results.channel.item.forecast}} </div> <p>Select a tab by setting active binding to true:</p> <p> <button type=button class=\\\"btn btn-default btn-sm\\\" ng-click=\\\"active = 1\\\">Select second tab</button> <button type=button class=\\\"btn btn-default btn-sm\\\" ng-click=\\\"active = 2\\\">Select third tab</button> </p> <hr/> <uib-tabset active=active> <uib-tab index=0 heading=\\\"Static title\\\">Static content</uib-tab> <uib-tab index=\\\"$index + 1\\\" ng-repeat=\\\"tab in weather.tabs\\\" heading={{tab.title}} disable=tab.disabled> {{tab.content}} </uib-tab> </uib-tabset> <hr/>\";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/weather/weather.html\n ** module id = 10\n ** module chunks = 0\n **/","export default class WeatherCtrl {\r\n\tconstructor(apiservice) {\r\n\t\tthis.tabs = [\r\n    \t\t{ title:'Dynamic Title 1', content:'Dynamic content 1' },\r\n    \t\t{ title:'Dynamic Title 2', content:'Dynamic content 2', disabled: true }\r\n  \t\t\t];\r\n\t\tthis.woeid = '9807';\r\n\t\tapiservice.getWeather(this.woeid)\r\n\t\t\t.then(result => this.forecast = result.data);\r\n\t}\r\n}\r\n\r\nWeatherCtrl.$inject = ['apiservice'];\n\n\n/** WEBPACK FOOTER **\n ** ./app/weather/weather.controller.js\n **/","import angular from 'angular';\r\n\r\nclass apiservice {\r\n\tconstructor($http){\r\n\t\tthis.$http = $http;\r\n\r\n\t\tthis.GEOCODE_ENDPOINT = \"http://where.yahooapis.com/geocode\";\r\n\t\tthis.YAHOO_GEO_APP_ID = \"v6wFWp30\"; \r\n\t\tthis.APP_ID = \"&appid=\" + this.YAHOO_GEO_APP_ID;\r\n\t\tthis.LOCATION = \"?location=\";\r\n\t\tthis.FLAGS = \"&flags=J&gflags=R\";\r\n\t\t\r\n\t\t//http://query.yahooapis.com/v1/public/yql?q=select item from weather.forecast where location=\"48907\"&format=json\r\n\t\t//select * from weather.forecast where woeid in (select woeid from geo.places(1) location=\"48907\"&format=json)\r\n\t\t//https://query.yahooapis.com/v1/public/yql?q=select\r\n\t\tthis.FORECAST_ENDPOINT = \"http://query.yahooapis.com/v1/public/yql?q=\";\r\n\t\tthis.FORECAST_YQL_OPEN \t= \"select * from weather.forecast where woeid='\";\r\n\t\tthis.FORECAST_YQL_CLOSE = \"'&format=json\";\r\n\t}\r\n\r\n\tgetWeather(woeid) {\r\n\t\tthis.woeid = woeid;\r\n\t\tthis.url = this.FORECAST_ENDPOINT + this.FORECAST_YQL_OPEN + this.woeid + this.FORECAST_YQL_CLOSE;\r\n\t\treturn this.$http.get(this.url);\r\n\t}\r\n}\r\n\r\nexport default angular.module('services.apiservice',[])\r\n.service('apiservice', apiservice)\r\n.name;\r\n\r\napiservice.$inject = ['$http'];\n\n\n/** WEBPACK FOOTER **\n ** ./app/weather/weather.service.js\n **/","export default function routing($urlRouterProvider, $locationProvider) {\r\n  $locationProvider.html5Mode(true);\r\n  $urlRouterProvider.otherwise('/');\r\n}\r\n\r\nrouting.$inject = ['$urlRouterProvider', '$locationProvider'];\n\n\n/** WEBPACK FOOTER **\n ** ./app/index.config.js\n **/"],"sourceRoot":""}